<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.moralok.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="假如生命只剩一天">
<meta property="og:type" content="website">
<meta property="og:title" content="Moralok">
<meta property="og:url" content="https://www.moralok.com/page/3/index.html">
<meta property="og:site_name" content="Moralok">
<meta property="og:description" content="假如生命只剩一天">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Moralok">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://www.moralok.com/page/3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Moralok</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-2MBCXKHJL0"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-2MBCXKHJL0","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Moralok</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Moralok</p>
  <div class="site-description" itemprop="description">假如生命只剩一天</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">46</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/moralok" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;moralok" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.moralok.com/2023/11/22/circular-dependencies-in-Spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Moralok">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Moralok">
      <meta itemprop="description" content="假如生命只剩一天">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Moralok">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/22/circular-dependencies-in-Spring/" class="post-title-link" itemprop="url">Spring 中的循环依赖</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-22 08:28:26" itemprop="dateCreated datePublished" datetime="2023-11-22T08:28:26+08:00">2023-11-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-01-25 19:49:56" itemprop="dateModified" datetime="2024-01-25T19:49:56+08:00">2024-01-25</time>
    </span>

  
    <span id="/2023/11/22/circular-dependencies-in-Spring/" class="post-meta-item leancloud_visitors" data-flag-title="Spring 中的循环依赖" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>15 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><code>Spring</code> 中的循环依赖是一个“大名鼎鼎”的问题，本文从原始的问题出发分析应当如何正确地看待和处理循环依赖现象，同时也会回归到源码详细介绍 <code>Spring</code> 的具体处理过程，并在最后给出笔者的个人思考。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/11/22/circular-dependencies-in-Spring/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.moralok.com/2023/11/19/how-does-Spring-AOP-create-proxy-beans/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Moralok">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Moralok">
      <meta itemprop="description" content="假如生命只剩一天">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Moralok">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/19/how-does-Spring-AOP-create-proxy-beans/" class="post-title-link" itemprop="url">Spring AOP 如何创建代理 beans</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-20 07:23:15" itemprop="dateCreated datePublished" datetime="2023-11-20T07:23:15+08:00">2023-11-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-01-25 19:49:56" itemprop="dateModified" datetime="2024-01-25T19:49:56+08:00">2024-01-25</time>
    </span>

  
    <span id="/2023/11/19/how-does-Spring-AOP-create-proxy-beans/" class="post-meta-item leancloud_visitors" data-flag-title="Spring AOP 如何创建代理 beans" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Spring AOP 是基于代理实现的，它既支持 JDK 动态代理也支持 CGLib。</p>
<ul>
<li>在什么时候创建代理对象的？</li>
<li>怎么创建代理对象的？</li>
</ul>
<h2 id="过程简单图解"><a href="#过程简单图解" class="headerlink" title="过程简单图解"></a>过程简单图解</h2><img src="/2023/11/19/how-does-Spring-AOP-create-proxy-beans/Pasted%20image%2020231120223506.png" class="" title="Spring AOP 创建代理的过程">

<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li>引入依赖<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>目标对象类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathCalculator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i / j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>切面类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspects</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(public int com.moralok.aop.MathCalculator.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointCut</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logStart</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        System.out.println(joinPoint.getSignature().getName() + <span class="string">&quot;除法运行@Before。。。参数列表为 &quot;</span> + Arrays.asList(joinPoint.getArgs()) + <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logEnd</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        System.out.println(joinPoint.getSignature().getName() + <span class="string">&quot;除法结束@After。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;pointCut()&quot;, returning = &quot;result&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logReturn</span><span class="params">(JoinPoint joinPoint, Object result)</span> &#123;</span><br><span class="line">        System.out.println(joinPoint.getSignature().getName() + <span class="string">&quot;除法正常返回@AfterReturning。。。运行结果 &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;pointCut()&quot;, throwing = &quot;e&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logException</span><span class="params">(JoinPoint joinPoint, Exception e)</span> &#123;</span><br><span class="line">        System.out.println(joinPoint.getSignature().getName() + <span class="string">&quot;除法异常@AfterThrowing。。。异常信息 &quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(value = &quot;execution(public String com.moralok.bean.Car.getName(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">logAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(joinPoint.getSignature().getName() + <span class="string">&quot; @Around开始&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> joinPoint.proceed();</span><br><span class="line">        System.out.println(joinPoint.getSignature().getName() + <span class="string">&quot; @Around结束&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>配置类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AopConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MathCalculator <span class="title function_">mathCalculator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MathCalculator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> LogAspects <span class="title function_">logAspects</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LogAspects</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>测试类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AopTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">aopTest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AopConfig.class);</span><br><span class="line">        <span class="type">MathCalculator</span> <span class="variable">mathCalculator</span> <span class="operator">=</span> ac.getBean(MathCalculator.class);</span><br><span class="line">        mathCalculator.div(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        mathCalculator.div(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        ac.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Debug 断点的判断条件（可选）<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanName.equals(&quot;mathCalculator&quot;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="创建代理-Bean-和创建普通-Bean-的区别"><a href="#创建代理-Bean-和创建普通-Bean-的区别" class="headerlink" title="创建代理 Bean 和创建普通 Bean 的区别"></a>创建代理 Bean 和创建普通 Bean 的区别</h2><p>其实创建代理 Bean 的过程和<a href="/2023/08/10/how-does-Spring-load-beans/" title="Spring Bean 加载过程">创建普通 Bean 的过程</a>直到进行初始化处理（initializeBean）前都是一样的。更具体地说，如很多资料所言，Spring 创建代理对象的工作，是在应用后置处理器阶段完成的。</p>
<h3 id="常规的入口-getBean"><a href="#常规的入口-getBean" class="headerlink" title="常规的入口 getBean"></a>常规的入口 getBean</h3><p>mathCalculator 以 getBean 方法为起点，开始创建的过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="comment">// ...（mathCalculator）</span></span><br><span class="line">    getBean(beanName);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="应用后置处理器"><a href="#应用后置处理器" class="headerlink" title="应用后置处理器"></a>应用后置处理器</h3><p>在正常地实例化 Bean 后，初始化 Bean 时，会对 Bean 实例应用后置处理器。</p>
<p>可是，<strong>究竟是哪一个后置处理器做的呢</strong>？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, RootBeanDefinition mbd)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">    <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AnnotationAwareAspectJAutoProxyCreator"><a href="#AnnotationAwareAspectJAutoProxyCreator" class="headerlink" title="AnnotationAwareAspectJAutoProxyCreator"></a>AnnotationAwareAspectJAutoProxyCreator</h3><p>在本示例中，创建代理的后置处理器就是 AnnotationAwareAspectJAutoProxyCreator，它继承自 AbstractAutoProxyCreator，AbstractAutoProxyCreator 实现了 BeanPostProcessor 接口。</p>
<p>那么，<strong>它是什么时候，怎么加入到 beanFactory 中呢</strong>？</p>
<p>PS: 显然，还有其他继承自 AbstractAutoProxyCreator 的后置处理器，暂时不谈。</p>
<h4 id="BeanPostProcessor-的方法"><a href="#BeanPostProcessor-的方法" class="headerlink" title="BeanPostProcessor 的方法"></a>BeanPostProcessor 的方法</h4><p>postProcessBeforeInitialization 和 postProcessAfterInitialization 方法，前者什么都没做，后者在必要时对 Bean 进行包装。</p>
<ul>
<li><strong><code>AbstractAutoProxyCreator#postProcessAfterInitialization</code> 就是创建代理对象的入口。</strong></li>
<li><strong>wrapIfNecessary 就是将 Bean 包装成代理 Bean 的入口方法</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title class_">ProxyProcessorSupport</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">SmartInstantiationAwareBeanPostProcessor</span>, BeanFactoryAware &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> &#123;</span><br><span class="line">        <span class="comment">// 什么都没做</span></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">this</span>.earlyProxyReferences.contains(cacheKey)) &#123;</span><br><span class="line">                <span class="comment">// 如有必要，将 bean 包装成代理对象</span></span><br><span class="line">                <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建代理-Bean-的过程"><a href="#创建代理-Bean-的过程" class="headerlink" title="创建代理 Bean 的过程"></a>创建代理 Bean 的过程</h2><h3 id="按需包装成代理-wrapIfNecessary"><a href="#按需包装成代理-wrapIfNecessary" class="headerlink" title="按需包装成代理 wrapIfNecessary"></a>按需包装成代理 wrapIfNecessary</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否直接返回 bean</span></span><br><span class="line">    <span class="keyword">if</span> (beanName != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Boolean.FALSE.equals(<span class="built_in">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有适用于当前 bean 的 advise 则为其创建代理</span></span><br><span class="line">    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">        <span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> createProxy(</span><br><span class="line">                bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> <span class="title class_">SingletonTargetSource</span>(bean));</span><br><span class="line">        <span class="built_in">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AbstractAutoProxyCreator-视角，创建代理"><a href="#AbstractAutoProxyCreator-视角，创建代理" class="headerlink" title="AbstractAutoProxyCreator 视角，创建代理"></a>AbstractAutoProxyCreator 视角，创建代理</h3><p>AbstractAutoProxyCreator#createProxy，创建一个 ProxyFactory，将工作交给它处理。</p>
<ol>
<li>创建一个代理工厂 ProxyFactory</li>
<li>设置相关信息</li>
<li>通过 ProxyFactory 获取代理</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createProxy</span><span class="params">(</span></span><br><span class="line"><span class="params">        Class&lt;?&gt; beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">        AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="built_in">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ProxyFactory</span> <span class="variable">proxyFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">    proxyFactory.copyFrom(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">            proxyFactory.setProxyTargetClass(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">    proxyFactory.addAdvisors(advisors);</span><br><span class="line">    proxyFactory.setTargetSource(targetSource);</span><br><span class="line">    customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">    proxyFactory.setFrozen(<span class="built_in">this</span>.freezeProxy);</span><br><span class="line">    <span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">        proxyFactory.setPreFiltered(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ProxyFactory-视角，获取代理"><a href="#ProxyFactory-视角，获取代理" class="headerlink" title="ProxyFactory 视角，获取代理"></a>ProxyFactory 视角，获取代理</h3><p>ProxyFactory#getProxy，创建一个 AopProxy 并委托它实现 getProxy。</p>
<blockquote>
<p>AopProxy 的含义与职责从字面上有点不好理解。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">(ClassLoader classLoader)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> createAopProxy().getProxy(classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ProxyFactor视角，创建-AopProxy"><a href="#ProxyFactor视角，创建-AopProxy" class="headerlink" title="ProxyFactor视角，创建 AopProxy"></a>ProxyFactor视角，创建 AopProxy</h4><p>ProxyFactory#createAopProxy，获取一个 AopProxyFactory 创建 AopProxy。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> AopProxy <span class="title function_">createAopProxy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.active) &#123;</span><br><span class="line">        activate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取 AopProxy 工厂并创建一个 AopProxy</span></span><br><span class="line">    <span class="keyword">return</span> getAopProxyFactory().createAopProxy(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AopProxyFactory视角，创建-AopProxy"><a href="#AopProxyFactory视角，创建-AopProxy" class="headerlink" title="AopProxyFactory视角，创建 AopProxy"></a>AopProxyFactory视角，创建 AopProxy</h4><p>AopProxyFactory#createAopProxy。</p>
<ul>
<li>AopProxyFactory 有且仅有一个默认实现 DefaultAopProxyFactory。</li>
<li>createAopProxy 方法会根据配置信息，返回具体实现：开箱即用的有 JdkDynamicAopProxy 或者 ObjenesisCglibAopProxy。</li>
</ul>
<p>这里的处理，决定了 Spring AOP 会使用哪一种动态代理实现。比如 Spring AOP 默认使用 JDK 动态代理，如果目标对象实现了接口 Spring 会使用 JDK 动态代理，这些结论的依据就在于此。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultAopProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">AopProxyFactory</span>, Serializable &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> AopProxy <span class="title function_">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException &#123;</span><br><span class="line">		<span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">			Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">			<span class="keyword">if</span> (targetClass == <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AopConfigException</span>(<span class="string">&quot;TargetSource cannot determine target class: &quot;</span> +</span><br><span class="line">						<span class="string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ObjenesisCglibAopProxy</span>(config);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取代理-AopProxy-getProxy"><a href="#获取代理-AopProxy-getProxy" class="headerlink" title="获取代理 AopProxy#getProxy"></a>获取代理 AopProxy#getProxy</h3><p>AopProxy 视角，获取代理。</p>
<h4 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h4><p>JdkDynamicAopProxy。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">(ClassLoader classLoader)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// JDK 动态代理，已经和 Spring 无关</span></span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="InvocationHandler-的-invoke-方法"><a href="#InvocationHandler-的-invoke-方法" class="headerlink" title="InvocationHandler 的 invoke 方法"></a>InvocationHandler 的 invoke 方法</h5><p>根据 <code>Proxy.newProxyInstance(classLoader, proxiedInterfaces, this)</code> 可知，this 也就是 JdkDynamicAopProxy 同时也是一个 InvocationHandler，它必然实现了 invoke 方法，当代理对象调用方法时，就会进入到 invoke 方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CGLib-动态代理"><a href="#CGLib-动态代理" class="headerlink" title="CGLib 动态代理"></a>CGLib 动态代理</h4><p>ObjenesisCglibAopProxy。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">(ClassLoader classLoader)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// CGLib 动态代理，已经和 Spring 无关</span></span><br><span class="line">    <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> createEnhancer();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> createProxyClassAndInstance(enhancer, callbacks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="为什么-Spring-中没有依赖-CGLib"><a href="#为什么-Spring-中没有依赖-CGLib" class="headerlink" title="为什么 Spring 中没有依赖 CGLib"></a>为什么 Spring 中没有依赖 CGLib</h5><p>你可能会注意到 Spring 中并没有直接依赖 CGLib，像 Enhancer 所在的包是 <code>org.springframework.cglib.proxy</code>。根据文档：</p>
<blockquote>
<p>从 spring 3.2 开始，不再需要将 cglib 添加到类路径中，因为 cglib 类在 org.springframework 下重新打包并分布在 spring-core jar 中。 这样做既是为了方便，也是为了避免与使用不同版本 cglib 的其他项目发生潜在冲突。</p>
</blockquote>
<h2 id="创建代理前的准备"><a href="#创建代理前的准备" class="headerlink" title="创建代理前的准备"></a>创建代理前的准备</h2><p>在前面预留了一些问题，当初我在看网上的资料时就有这些困惑。</p>
<h3 id="Bean-后置处理器-AspectJAwareAdvisorAutoProxyCreator-在什么时候，怎么加入到-beanFactory-中的？"><a href="#Bean-后置处理器-AspectJAwareAdvisorAutoProxyCreator-在什么时候，怎么加入到-beanFactory-中的？" class="headerlink" title="Bean 后置处理器 AspectJAwareAdvisorAutoProxyCreator 在什么时候，怎么加入到 beanFactory 中的？"></a>Bean 后置处理器 AspectJAwareAdvisorAutoProxyCreator 在什么时候，怎么加入到 beanFactory 中的？</h3><p>Debug 停留在 Spring 上下文刷新方法中的 finishBeanFactoryInitialization。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 beanFatory 的 beanDefinitionMap 可以观察到，配置类 AopConfig 中的 MathCalculator 和 LogAspect 的信息已经就位。</p>
<img src="/2023/11/19/how-does-Spring-AOP-create-proxy-beans/Snipaste_2023-11-20_15-51-48.png" class="" title="初始化 beanFactory 时的 beanDefinitionMap">

<p>从 beanFactory 的 beanProcessor 可以观察到，AnnotationAwareAspectJAutoProxyCreator 已经就位。</p>
<img src="/2023/11/19/how-does-Spring-AOP-create-proxy-beans/Snipaste_2023-11-20_15-56-15.png" class="" title="初始化 beanFactory 时的 beanPostProcessor">

<h4 id="EnableXXX-的魔法"><a href="#EnableXXX-的魔法" class="headerlink" title="@EnableXXX 的魔法"></a>@EnableXXX 的魔法</h4><p>注解 @EnableXXX 往往伴随着注解 @Import，在 invokeBeanFactoryPostProcessors(beanFactory) 中，工厂后置处理器 ConfigurationClassPostProcessor 会处理它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(AspectJAutoProxyRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAspectJAutoProxy &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">exposeProxy</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 ConfigurationClassPostProcessor 的处理中，因为 AspectJAutoProxyRegistrar 实现了 ImportBeanDefinitionRegistrar，registerBeanDefinitions 方法会被调用，AnnotationAwareAspectJAutoProxyCreator 的 beanDefinition 随之被注册到 beanFactory，因 AnnotationAwareAspectJAutoProxyCreator 实现了 BeanPostProcessor 被提前创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AspectJAutoProxyRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(</span></span><br><span class="line"><span class="params">            AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 如有必要注册 AspectJAnnotationAutoProxyCreator</span></span><br><span class="line">        AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</span><br><span class="line">        <span class="comment">// 根据配置设置一些属性</span></span><br><span class="line">        <span class="type">AnnotationAttributes</span> <span class="variable">enableAspectJAutoProxy</span> <span class="operator">=</span></span><br><span class="line">                AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);</span><br><span class="line">        <span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">&quot;proxyTargetClass&quot;</span>)) &#123;</span><br><span class="line">            AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">&quot;exposeProxy&quot;</span>)) &#123;</span><br><span class="line">            AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BeanDefinition <span class="title function_">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="params">(BeanDefinitionRegistry registry, Object source)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="切面类-LogAspect-的解析是在什么时候？"><a href="#切面类-LogAspect-的解析是在什么时候？" class="headerlink" title="切面类 LogAspect 的解析是在什么时候？"></a>切面类 LogAspect 的解析是在什么时候？</h3><p>进入创建 Bean 的方法 createBean 后，除了 doCreateBean，应额外留意 resolveBeforeInstantiation 方法。</p>
<ol>
<li><code>Object bean = resolveBeforeInstantiation(beanName, mbdToUse)</code>，在实例化前进行解析。</li>
<li><code>Object beanInstance = doCreateBean(beanName, mbdToUse, args)</code>，创建 Bean 的具体过程。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> <span class="keyword">throws</span> BeanCreationException &#123; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">beanInstance</span> <span class="operator">=</span> doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="入口方法-resolveBeforeInstantiation"><a href="#入口方法-resolveBeforeInstantiation" class="headerlink" title="入口方法 resolveBeforeInstantiation"></a>入口方法 resolveBeforeInstantiation</h4><p>根据注释，该方法给 BeanPostProcessors 一个机会提前返回一个代理对象。在本示例中，返回 null，但是方法在第一次执行后已经提前解析得到 advisors 并缓存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">resolveBeforeInstantiation</span><span class="params">(String beanName, RootBeanDefinition mbd)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">            Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);</span><br><span class="line">            <span class="keyword">if</span> (targetType != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 注意，应用的是实例化前的处理</span></span><br><span class="line">                bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);</span><br><span class="line">                <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 注意，应用的是初始化后的处理</span></span><br><span class="line">                    bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mbd.beforeInstantiationResolved = (bean != <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="InstantiationAwareBeanPostProcessor"><a href="#InstantiationAwareBeanPostProcessor" class="headerlink" title="InstantiationAwareBeanPostProcessor"></a>InstantiationAwareBeanPostProcessor</h4><p>应用 InstantiationAwareBeanPostProcessor 的 postProcessBeforeInstantiation。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">applyBeanPostProcessorsBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">            <span class="type">InstantiationAwareBeanPostProcessor</span> <span class="variable">ibp</span> <span class="operator">=</span> (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">            <span class="comment">// 循环依次处理</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> ibp.postProcessBeforeInstantiation(beanClass, beanName);</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AnnotationAwareAspectJAutoProxyCreator 不仅仅是一个 BeanPostProcessor，它还是一个 InstantiationAwareBeanPostProcessor。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(beanClass, beanName);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (beanName == <span class="literal">null</span> || !<span class="built_in">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.advisedBeans.containsKey(cacheKey)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (beanName != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">TargetSource</span> <span class="variable">targetSource</span> <span class="operator">=</span> getCustomTargetSource(beanClass, beanName);</span><br><span class="line">        <span class="keyword">if</span> (targetSource != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.targetSourcedBeans.add(beanName);</span><br><span class="line">            Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> createProxy(beanClass, beanName, specificInterceptors, targetSource);</span><br><span class="line">            <span class="built_in">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">            <span class="keyword">return</span> proxy;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和 wrapIfNecessary 方法对比，容易发现两者有不少相似的处理。</p>
<img src="/2023/11/19/how-does-Spring-AOP-create-proxy-beans/Snipaste_2023-11-20_21-33-34.png" class="" title="实例化前后创建代理的对比">

<blockquote>
<p><strong>注意：以下方法应注意是否被子类重写</strong>。</p>
</blockquote>
<p>org.springframework.aop.aspectj.autoproxy.AspectJAwareAdvisorAutoProxyCreator#shouldSkip</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">shouldSkip</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> &#123;</span><br><span class="line">    <span class="comment">// 查找并缓存 advisors</span></span><br><span class="line">    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator#getAdvicesAndAdvisorsForBean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object[] getAdvicesAndAdvisorsForBean(Class&lt;?&gt; beanClass, String beanName, TargetSource targetSource) &#123;</span><br><span class="line">    List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator#findEligibleAdvisors</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title function_">findEligibleAdvisors</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> &#123;</span><br><span class="line">    <span class="comment">// 查找并缓存 advisors</span></span><br><span class="line">    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>容易注意到两者在创建代理前，<strong>都会调用 findCandidateAdvisors 方法查找候选的 advisors</strong>，其实这也是我们想要找的对切面类的解析处理所在。</p>
<h4 id="查找并缓存-advisors"><a href="#查找并缓存-advisors" class="headerlink" title="查找并缓存 advisors"></a>查找并缓存 advisors</h4><p>org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator#findCandidateAdvisors</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title function_">findCandidateAdvisors</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Advisor&gt; advisors = <span class="built_in">super</span>.findCandidateAdvisors();</span><br><span class="line">    advisors.addAll(<span class="built_in">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());</span><br><span class="line">    <span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>org.springframework.aop.aspectj.annotation.BeanFactoryAspectJAdvisorsBuilder#buildAspectJAdvisors</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title function_">buildAspectJAdvisors</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; aspectNames = <span class="built_in">this</span>.aspectBeanNames;  </span><br><span class="line">    <span class="keyword">if</span> (aspectNames == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 第一次进入，没有缓存</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            aspectNames = <span class="built_in">this</span>.aspectBeanNames;</span><br><span class="line">            <span class="keyword">if</span> (aspectNames == <span class="literal">null</span>) &#123;</span><br><span class="line">                List&lt;Advisor&gt; advisors = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Advisor&gt;();</span><br><span class="line">                aspectNames = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line">                String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">                        <span class="built_in">this</span>.beanFactory, Object.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">                    <span class="comment">// ...</span></span><br><span class="line">                    <span class="comment">// 如果是切面，解析得到 advisors</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">this</span>.advisorFactory.isAspect(beanType)) &#123;</span><br><span class="line">                        aspectNames.add(beanName);</span><br><span class="line">                        <span class="comment">// ...</span></span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line">                            <span class="built_in">this</span>.advisorsCache.put(beanName, classAdvisors);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="built_in">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">this</span>.aspectBeanNames = aspectNames;</span><br><span class="line">                <span class="keyword">return</span> advisors;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (aspectNames.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以后进来读缓存</span></span><br><span class="line">    List&lt;Advisor&gt; advisors = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Advisor&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String aspectName : aspectNames) &#123;</span><br><span class="line">        List&lt;Advisor&gt; cachedAdvisors = <span class="built_in">this</span>.advisorsCache.get(aspectName);</span><br><span class="line">        <span class="keyword">if</span> (cachedAdvisors != <span class="literal">null</span>) &#123;</span><br><span class="line">            advisors.addAll(cachedAdvisors);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">MetadataAwareAspectInstanceFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="built_in">this</span>.aspectFactoryCache.get(aspectName);</span><br><span class="line">            advisors.addAll(<span class="built_in">this</span>.advisorFactory.getAdvisors(factory));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过 <code>beanFactory-&gt;beanPostProcessors-&gt;aspectJAdvisorsBuilder-&gt;advisorsCache</code> 观察 advisors 的查找情况。</p>
<img src="/2023/11/19/how-does-Spring-AOP-create-proxy-beans/Snipaste_2023-11-20_20-50-04.png" class="" title="观察 advisors">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.moralok.com/2023/11/19/JDK-dynamic-proxy-and-CGLib/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Moralok">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Moralok">
      <meta itemprop="description" content="假如生命只剩一天">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Moralok">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/19/JDK-dynamic-proxy-and-CGLib/" class="post-title-link" itemprop="url">JDK 动态代理和 CGLib</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-19 14:20:39" itemprop="dateCreated datePublished" datetime="2023-11-19T14:20:39+08:00">2023-11-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-01-25 19:49:56" itemprop="dateModified" datetime="2024-01-25T19:49:56+08:00">2024-01-25</time>
    </span>

  
    <span id="/2023/11/19/JDK-dynamic-proxy-and-CGLib/" class="post-meta-item leancloud_visitors" data-flag-title="JDK 动态代理和 CGLib" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h3><p>Java 标准库提供了动态代理功能，允许程序在运行期动态创建指定接口的实例。</p>
<h3 id="CGLib-动态代理"><a href="#CGLib-动态代理" class="headerlink" title="CGLib 动态代理"></a>CGLib 动态代理</h3><p>使用 ASM 框架，加载代理对象的 Class 文件，通过修改其字节码生成子类。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/cglib/cglib">cglib Github 仓库</a></p>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li>JDK 动态代理适用于实现接口的类，对未实现接口的类无能为力。</li>
<li>CGLib 不要求类实现接口，但对 final 方法无能为力。</li>
</ul>
<h3 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h3><ul>
<li>在 JDK 8 以前，CGLib 性能更好</li>
<li>从 JDK 8 开始，JDK 动态代理性能更好</li>
</ul>
<blockquote>
<p>根据 README.md 的提醒，cglib 已经不再维护，且在较新版本的 JDK 尤其是 JDK 17+ 中表现不佳，官方推荐可以考虑迁移到 <a target="_blank" rel="noopener" href="https://bytebuddy.net/">ByteBuddy</a>。在如今越来越多的项目迁移到 JDK 17 的背景下，值得注意。</p>
</blockquote>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="代理对象的类和接口"><a href="#代理对象的类和接口" class="headerlink" title="代理对象的类和接口"></a>代理对象的类和接口</h3><p>代理对象的类和实现的接口：</p>
<ul>
<li><p>HelloService.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>HelloService.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;name can not be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="JDK-动态代理示例"><a href="#JDK-动态代理示例" class="headerlink" title="JDK 动态代理示例"></a>JDK 动态代理示例</h3><ul>
<li>自定义 InvocationHandler<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;do sth. before invocation&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">            System.out.println(<span class="string">&quot;do sth. after invocation&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;do sth. when exception occurs&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;do sth. finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>测试类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkProxyTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HelloService</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloServiceImpl</span>();</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> target.getClass().getClassLoader();</span><br><span class="line">        Class&lt;?&gt;[] interfaces = target.getClass().getInterfaces();</span><br><span class="line">        <span class="type">UserServiceInvocationHandler</span> <span class="variable">invocationHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceInvocationHandler</span>(target);</span><br><span class="line"></span><br><span class="line">        <span class="type">HelloService</span> <span class="variable">proxy</span> <span class="operator">=</span> (HelloService) Proxy.newProxyInstance(classLoader, interfaces, invocationHandler);</span><br><span class="line">        proxy.sayHello(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;=================&quot;</span>);</span><br><span class="line">        proxy.sayHello(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>结果<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">do sth. before invocation</span><br><span class="line">Hello Tom</span><br><span class="line">do sth. after invocation</span><br><span class="line">do sth. finally</span><br><span class="line">=================</span><br><span class="line">do sth. before invocation</span><br><span class="line">do sth. when exception occurs</span><br><span class="line">do sth. finally</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.reflect.UndeclaredThrowableException</span><br><span class="line">	at com.sun.proxy.$Proxy0.sayHello(Unknown Source)</span><br><span class="line">	at com.moralok.proxy.jdk.JdkProxyTest.main(JdkProxyTest.java:19)</span><br><span class="line">Caused by: java.lang.reflect.InvocationTargetException</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">	at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">	at com.moralok.proxy.jdk.UserServiceInvocationHandler.invoke(UserServiceInvocationHandler.java:18)</span><br><span class="line">	... 2 more</span><br><span class="line">Caused by: java.lang.IllegalArgumentException: name can not be null</span><br><span class="line">	at com.moralok.proxy.HelloServiceImpl.sayHello(HelloServiceImpl.java:8)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="CGLib-动态代理示例"><a href="#CGLib-动态代理示例" class="headerlink" title="CGLib 动态代理示例"></a>CGLib 动态代理示例</h3><ul>
<li>引入依赖<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>自定义 MethodInterceptor<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceMethodInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;do sth. before invocation&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> proxy.invokeSuper(obj, args);</span><br><span class="line">            System.out.println(<span class="string">&quot;do sth. after invocation&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;do sth. when exception occurs&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;do sth. finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>测试类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserServiceMethodInterceptor</span> <span class="variable">methodInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceMethodInterceptor</span>();</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(HelloServiceImpl.class);</span><br><span class="line">        enhancer.setCallback(methodInterceptor);</span><br><span class="line"></span><br><span class="line">        <span class="type">HelloService</span> <span class="variable">proxy</span> <span class="operator">=</span> (HelloService) enhancer.create();</span><br><span class="line">        proxy.sayHello(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;=================&quot;</span>);</span><br><span class="line">        proxy.sayHello(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>结果<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">do sth. before invocation</span><br><span class="line">Hello Tom</span><br><span class="line">do sth. after invocation</span><br><span class="line">do sth. finally</span><br><span class="line">=================</span><br><span class="line">do sth. before invocation</span><br><span class="line">do sth. when exception occurs</span><br><span class="line">do sth. finally</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: name can not be null</span><br><span class="line">	at com.moralok.proxy.HelloServiceImpl.sayHello(HelloServiceImpl.java:8)</span><br><span class="line">	at com.moralok.proxy.HelloServiceImpl$$EnhancerByCGLIB$$c51b2c31.CGLIB$sayHello$0(&lt;generated&gt;)</span><br><span class="line">	at com.moralok.proxy.HelloServiceImpl$$EnhancerByCGLIB$$c51b2c31$$FastClassByCGLIB$$c068b511.invoke(&lt;generated&gt;)</span><br><span class="line">	at net.sf.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:228)</span><br><span class="line">	at com.moralok.proxy.cglib.UserServiceMethodInterceptor.intercept(UserServiceMethodInterceptor.java:14)</span><br><span class="line">	at com.moralok.proxy.HelloServiceImpl$$EnhancerByCGLIB$$c51b2c31.sayHello(&lt;generated&gt;)</span><br><span class="line">	at com.moralok.proxy.cglib.CglibTest.main(CglibTest.java:18)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="查看-JDK-生成的代理类"><a href="#查看-JDK-生成的代理类" class="headerlink" title="查看 JDK 生成的代理类"></a>查看 JDK 生成的代理类</h2><p>使用以下语句，将在工作目录下生成代理类的 Class 文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(<span class="string">&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="comment">// 将 InvocationHandler 传递给父类 Proxy</span></span><br><span class="line">        <span class="built_in">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m1, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代理方法调用 InvocationHandler 的 invoke 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String var1)</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m3, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m2, (Object[])<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m0, (Object[])<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态代码块，初始化 Method 属性。</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>));</span><br><span class="line">            m3 = Class.forName(<span class="string">&quot;com.moralok.proxy.HelloService&quot;</span>).getMethod(<span class="string">&quot;sayHello&quot;</span>, Class.forName(<span class="string">&quot;java.lang.String&quot;</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodError</span>(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoClassDefFoundError</span>(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查看-CGLib-生成的子类"><a href="#查看-CGLib-生成的子类" class="headerlink" title="查看 CGLib 生成的子类"></a>查看 CGLib 生成的子类</h2><p>使用以下语句，将 CGLib 生成的子类的 Class 文件输出到指定目录，会发现出现了 3 个 Class 文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, <span class="string">&quot;C:\\Users\\username\\Class&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>HelloServiceImpl$$EnhancerByCGLIB$$c51b2c31.class，代理类</li>
<li>HelloServiceImpl$$FastClassByCGLIB$$a5654167.class，被代理类的 FastClass</li>
<li>HelloServiceImpl$$EnhancerByCGLIB$$c51b2c31$$FastClassByCGLIB$$c068b511.class，代理类的 FastClass</li>
</ul>
<img src="/2023/11/19/JDK-dynamic-proxy-and-CGLib/Snipaste_2023-11-28_02-01-40.png" class="" title="CGLib 生成的子类的 Class 文件">

<h3 id="代理类定义"><a href="#代理类定义" class="headerlink" title="代理类定义"></a>代理类定义</h3><p>继承了被代理类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServiceImpl$$EnhancerByCGLIB$$c51b2c31</span> <span class="keyword">extends</span> <span class="title class_">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 调用静态钩子方法</span></span><br><span class="line">    CGLIB$STATICHOOK1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> CGLIB$STATICHOOK1() &#123;</span><br><span class="line">    CGLIB$THREAD_CALLBACKS = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();</span><br><span class="line">    CGLIB$emptyArgs = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="type">Class</span> <span class="variable">var0</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.moralok.proxy.HelloServiceImpl$$EnhancerByCGLIB$$c51b2c31&quot;</span>);</span><br><span class="line">    Class var1;</span><br><span class="line">    <span class="comment">// 获取 Object 类的 equals、toString、hashCode、clone 这几个特定方法的 Method 对象</span></span><br><span class="line">    Method[] var10000 = ReflectUtils.findMethods(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;equals&quot;</span>, <span class="string">&quot;(Ljava/lang/Object;)Z&quot;</span>, <span class="string">&quot;toString&quot;</span>, <span class="string">&quot;()Ljava/lang/String;&quot;</span>, <span class="string">&quot;hashCode&quot;</span>, <span class="string">&quot;()I&quot;</span>, <span class="string">&quot;clone&quot;</span>, <span class="string">&quot;()Ljava/lang/Object;&quot;</span>&#125;, (var1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>)).getDeclaredMethods());</span><br><span class="line">    <span class="comment">// 还生成了相对应的 Method 属性保存（为了减少一次寻址吗？）</span></span><br><span class="line">    CGLIB$equals$<span class="number">1</span>$Method = var10000[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 为每一个 Method 创建一个 MethodProxy</span></span><br><span class="line">    CGLIB$equals$<span class="number">1</span>$Proxy = MethodProxy.create(var1, var0, <span class="string">&quot;(Ljava/lang/Object;)Z&quot;</span>, <span class="string">&quot;equals&quot;</span>, <span class="string">&quot;CGLIB$equals$1&quot;</span>);</span><br><span class="line">    CGLIB$toString$<span class="number">2</span>$Method = var10000[<span class="number">1</span>];</span><br><span class="line">    CGLIB$toString$<span class="number">2</span>$Proxy = MethodProxy.create(var1, var0, <span class="string">&quot;()Ljava/lang/String;&quot;</span>, <span class="string">&quot;toString&quot;</span>, <span class="string">&quot;CGLIB$toString$2&quot;</span>);</span><br><span class="line">    CGLIB$hashCode$<span class="number">3</span>$Method = var10000[<span class="number">2</span>];</span><br><span class="line">    CGLIB$hashCode$<span class="number">3</span>$Proxy = MethodProxy.create(var1, var0, <span class="string">&quot;()I&quot;</span>, <span class="string">&quot;hashCode&quot;</span>, <span class="string">&quot;CGLIB$hashCode$3&quot;</span>);</span><br><span class="line">    CGLIB$clone$<span class="number">4</span>$Method = var10000[<span class="number">3</span>];</span><br><span class="line">    CGLIB$clone$<span class="number">4</span>$Proxy = MethodProxy.create(var1, var0, <span class="string">&quot;()Ljava/lang/Object;&quot;</span>, <span class="string">&quot;clone&quot;</span>, <span class="string">&quot;CGLIB$clone$4&quot;</span>);</span><br><span class="line">    <span class="comment">// 被代理类的方法也做相同处理</span></span><br><span class="line">    CGLIB$sayHello$<span class="number">0</span>$Method = ReflectUtils.findMethods(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;sayHello&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>&#125;, (var1 = Class.forName(<span class="string">&quot;com.moralok.proxy.HelloServiceImpl&quot;</span>)).getDeclaredMethods())[<span class="number">0</span>];</span><br><span class="line">    CGLIB$sayHello$<span class="number">0</span>$Proxy = MethodProxy.create(var1, var0, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="string">&quot;sayHello&quot;</span>, <span class="string">&quot;CGLIB$sayHello$0&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MethodProxy 稍后再做介绍。</p>
<h3 id="构造器方法"><a href="#构造器方法" class="headerlink" title="构造器方法"></a>构造器方法</h3><p>构造器方法内，调用了绑定回调（Callbacks）方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> HelloServiceImpl$$EnhancerByCGLIB$$c51b2c31() &#123;</span><br><span class="line">    CGLIB$BIND_CALLBACKS(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标识是否已经绑定过回调</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> CGLIB$BOUND;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> CGLIB$BIND_CALLBACKS(Object var0) &#123;</span><br><span class="line">    <span class="type">HelloServiceImpl$$EnhancerByCGLIB$$c51b2c31</span> <span class="variable">var1</span> <span class="operator">=</span> (HelloServiceImpl$$EnhancerByCGLIB$$c51b2c31)var0;</span><br><span class="line">    <span class="keyword">if</span> (!var1.CGLIB$BOUND) &#123;</span><br><span class="line">        <span class="comment">// 未绑定过回调则进行绑定，更新标识</span></span><br><span class="line">        var1.CGLIB$BOUND = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 先获取 THREAD_CALLBACKS</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">var10000</span> <span class="operator">=</span> CGLIB$THREAD_CALLBACKS.get();</span><br><span class="line">        <span class="keyword">if</span> (var10000 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果为 null，再获取 STATIC_CALLBACKS</span></span><br><span class="line">            var10000 = CGLIB$STATIC_CALLBACKS;</span><br><span class="line">            <span class="keyword">if</span> (var10000 == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果仍然为 null，直接返回</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每一个 Callback （像之前的 Method 一样）都有专门的属性保存</span></span><br><span class="line">        var1.CGLIB$CALLBACK_0 = (MethodInterceptor)((Callback[])var10000)[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="生成的代理方法"><a href="#生成的代理方法" class="headerlink" title="生成的代理方法"></a>生成的代理方法</h3><p>CGLib 会为每一个代理方法生成两个对应的方法，一个直接调用父类方法，一个则调用回调（拦截器）的 intercept 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> CGLIB$sayHello$<span class="number">0</span>(String var1) &#123;</span><br><span class="line">    <span class="built_in">super</span>.sayHello(var1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String var1)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取回调（拦截器）</span></span><br><span class="line">    <span class="type">MethodInterceptor</span> <span class="variable">var10000</span> <span class="operator">=</span> <span class="built_in">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">    <span class="keyword">if</span> (var10000 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果为 null，先进行回调绑定</span></span><br><span class="line">        CGLIB$BIND_CALLBACKS(<span class="built_in">this</span>);</span><br><span class="line">        var10000 = <span class="built_in">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (var10000 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果回调（拦截器）不为 null，则调用 intercept 方法</span></span><br><span class="line">        var10000.intercept(<span class="built_in">this</span>, CGLIB$sayHello$<span class="number">0</span>$Method, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;var1&#125;, CGLIB$sayHello$<span class="number">0</span>$Proxy);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则直接调用父类方法</span></span><br><span class="line">        <span class="built_in">super</span>.sayHello(var1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CGLib 通过继承实现动态代理的过程，在查看生成的子类的 Class 后，是非常容易理解的。拦截器的参数有代理对象、Method、方法参数和 MethodProxy 对象。</p>
<h2 id="分析-MethodProxy"><a href="#分析-MethodProxy" class="headerlink" title="分析 MethodProxy"></a>分析 MethodProxy</h2><p>如何在拦截器中调用被代理的方法呢？就是通过 MethodProxy 实现的。</p>
<h3 id="创建-MethodProxy"><a href="#创建-MethodProxy" class="headerlink" title="创建 MethodProxy"></a>创建 MethodProxy</h3><p>MethodProxy 是 CGLib 为每一个代理方法创建的方法代理，当调用拦截的方法时，它被传递给 MethodInterceptor 对象的 intercept 方法。它可以用于调用原始方法，或对同一类型的不同对象调用相同方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CGLIB$sayHello$<span class="number">0</span>$Proxy = MethodProxy.create(var1, var0, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="string">&quot;sayHello&quot;</span>, <span class="string">&quot;CGLIB$sayHello$0&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> MethodProxy <span class="title function_">create</span><span class="params">(Class c1, Class c2, String desc, String name1, String name2)</span> &#123;</span><br><span class="line">    <span class="type">MethodProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodProxy</span>();</span><br><span class="line">    <span class="comment">// sayHello 方法签名</span></span><br><span class="line">    proxy.sig1 = <span class="keyword">new</span> <span class="title class_">Signature</span>(name1, desc);</span><br><span class="line">    <span class="comment">// CGLIB$sayHello$0 方法签名</span></span><br><span class="line">    proxy.sig2 = <span class="keyword">new</span> <span class="title class_">Signature</span>(name2, desc);</span><br><span class="line">    <span class="comment">// 被代理类和代理类</span></span><br><span class="line">    proxy.createInfo = <span class="keyword">new</span> <span class="title class_">CreateInfo</span>(c1, c2);</span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CreateInfo 静态内部类，保存被代理类和代理类以及其他一些信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CreateInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 被代理类</span></span><br><span class="line">    Class c1;</span><br><span class="line">    <span class="comment">// 代理类</span></span><br><span class="line">    Class c2;</span><br><span class="line">    NamingPolicy namingPolicy;</span><br><span class="line">    GeneratorStrategy strategy;</span><br><span class="line">    <span class="type">boolean</span> attemptLoad;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CreateInfo</span><span class="params">(Class c1, Class c2)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.c1 = c1;</span><br><span class="line">        <span class="built_in">this</span>.c2 = c2;</span><br><span class="line">        <span class="type">AbstractClassGenerator</span> <span class="variable">fromEnhancer</span> <span class="operator">=</span> AbstractClassGenerator.getCurrent();</span><br><span class="line">        <span class="keyword">if</span> (fromEnhancer != <span class="literal">null</span>) &#123;</span><br><span class="line">            namingPolicy = fromEnhancer.getNamingPolicy();</span><br><span class="line">            strategy = fromEnhancer.getStrategy();</span><br><span class="line">            attemptLoad = fromEnhancer.getAttemptLoad();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FastClass-和方法索引对"><a href="#FastClass-和方法索引对" class="headerlink" title="FastClass 和方法索引对"></a>FastClass 和方法索引对</h3><h4 id="调用原始方法-invokeSuper"><a href="#调用原始方法-invokeSuper" class="headerlink" title="调用原始方法 invokeSuper"></a>调用原始方法 invokeSuper</h4><p>MethodProxy 通过 invokeSuper 调用原始方法（父类方法）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// invoke 方法的代码相似</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invokeSuper</span><span class="params">(Object obj, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化，生成 FastClassInfo</span></span><br><span class="line">        init();</span><br><span class="line">        <span class="type">FastClassInfo</span> <span class="variable">fci</span> <span class="operator">=</span> fastClassInfo;</span><br><span class="line">        <span class="comment">// 调用原始（父类）方法</span></span><br><span class="line">        <span class="keyword">return</span> fci.f2.invoke(fci.i2, obj, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.getTargetException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="生成-FastClass-信息"><a href="#生成-FastClass-信息" class="headerlink" title="生成 FastClass 信息"></a>生成 FastClass 信息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 双重校验锁，生成 FastClass 和方法索引对</span></span><br><span class="line">    <span class="keyword">if</span> (fastClassInfo == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (initLock)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (fastClassInfo == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">CreateInfo</span> <span class="variable">ci</span> <span class="operator">=</span> createInfo;</span><br><span class="line"></span><br><span class="line">                <span class="type">FastClassInfo</span> <span class="variable">fci</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FastClassInfo</span>();</span><br><span class="line">                <span class="comment">// 生成 FastClass</span></span><br><span class="line">                fci.f1 = helper(ci, ci.c1);</span><br><span class="line">                fci.f2 = helper(ci, ci.c2);</span><br><span class="line">                <span class="comment">// 获取方法索引</span></span><br><span class="line">                fci.i1 = fci.f1.getIndex(sig1);</span><br><span class="line">                fci.i2 = fci.f2.getIndex(sig2);</span><br><span class="line">                fastClassInfo = fci;</span><br><span class="line">                createInfo = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="FastClass-信息"><a href="#FastClass-信息" class="headerlink" title="FastClass 信息"></a>FastClass 信息</h4><ul>
<li>f1 是被代理类的 FastClass 对象，i1 是 <code>CGLIB$sayHello$0</code> 方法在生成的 FastClass 中的索引。</li>
<li>f2 是代理类的 FastClass 对象，i2 是 <code>sayHello</code> 方法在生成的 FastClass 中的索引。</li>
</ul>
<p>invoke 方法根据传入的方法索引，快速定位要调用对象 obj 的哪个方法。</p>
<blockquote>
<p>CGLib 完全有能力获得 <code>CGLIB$sayHello$0</code> 的 Method 对象，通过反射实现调用，这样处理逻辑更加清楚。但是早期 Java 反射的性能并不好，通过 FastClass 机制避免使用反射从而提升了性能。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">FastClassInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    FastClass f1;</span><br><span class="line">    FastClass f2;</span><br><span class="line">    <span class="type">int</span> i1;</span><br><span class="line">    <span class="type">int</span> i2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FastClass-的-invoke-方法"><a href="#FastClass-的-invoke-方法" class="headerlink" title="FastClass 的 invoke 方法"></a>FastClass 的 invoke 方法</h3><p>以代理类的 FastClass <code>HelloServiceImpl$$EnhancerByCGLIB$$c51b2c31$$FastClassByCGLIB$$c068b511</code> 为例，当传入的方法索引为 16 时，就会调用 <code>CGLIB$sayHello$0</code> 方法。</p>
<ol>
<li>获取代理对象</li>
<li>根据传入的方法索引，调用</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(<span class="type">int</span> var1, Object var2, Object[] var3)</span> <span class="keyword">throws</span> InvocationTargetException &#123;</span><br><span class="line">    HelloServiceImpl..EnhancerByCGLIB..<span class="type">c51b2c31</span> <span class="variable">var10000</span> <span class="operator">=</span> (HelloServiceImpl..EnhancerByCGLIB..c51b2c31)var2;</span><br><span class="line">    <span class="type">int</span> <span class="variable">var10001</span> <span class="operator">=</span> var1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (var10001) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(var10000.equals(var3[<span class="number">0</span>]));</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line">                var10000.CGLIB$sayHello$<span class="number">0</span>((String)var3[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvocationTargetException</span>(var4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Cannot find matching method/constructor&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取方法索引"><a href="#获取方法索引" class="headerlink" title="获取方法索引"></a>获取方法索引</h4><p>怎么知道方法的索引呢？在初始化 FastClass 信息时，不仅生成了 FastClass，还通过 getIndex 获取方法的索引。</p>
<blockquote>
<p>在 JDK 7 之后，switch 不仅可以支持 int、enum，还能支持 String，CGLib 这样实现是出于兼容性的考虑还是说有什么性能提升？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(Signature var1)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">var10000</span> <span class="operator">=</span> var1.toString();</span><br><span class="line">    <span class="keyword">switch</span> (var10000.hashCode()) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">case</span> -<span class="number">1721191351</span>:</span><br><span class="line">            <span class="keyword">if</span> (var10000.equals(<span class="string">&quot;CGLIB$sayHello$0(Ljava/lang/String;)V&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">16</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结和思考"><a href="#总结和思考" class="headerlink" title="总结和思考"></a>总结和思考</h2><p>两者在使用上是相仿的。</p>
<ul>
<li>对于两者的源码，读得不多。有时候会感慨，看这么多年前的代码，还是感觉吃力。有时候想，如果不好好看源码，心里不踏实；如果花很多时间理清楚了，但是发现更多只是知道了一些细节，于整体理解的提升不大，又会感觉不值得。</li>
<li>但也提醒自己，不要太在意，用得本就不多，涉及源码的机会更是没有，如果方方面面都要细究，人生太短，智商不够，等涉足相关问题再回头研究。</li>
<li>基础的用法和概念应该了解，不然看到 Spring AOP 源码时，分不清 Spring 封装的边界在哪里。</li>
</ul>
<blockquote>
<p>借着梳理 Spring 的机会回头再看，又感觉轻松不少。</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.moralok.com/2023/11/18/setup-monitoring-using-grafana-and-prometheus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Moralok">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Moralok">
      <meta itemprop="description" content="假如生命只剩一天">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Moralok">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/18/setup-monitoring-using-grafana-and-prometheus/" class="post-title-link" itemprop="url">使用 Grafana 和 Prometheus 搭建监控</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-18 13:48:40" itemprop="dateCreated datePublished" datetime="2023-11-18T13:48:40+08:00">2023-11-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-01-25 19:49:56" itemprop="dateModified" datetime="2024-01-25T19:49:56+08:00">2024-01-25</time>
    </span>

  
    <span id="/2023/11/18/setup-monitoring-using-grafana-and-prometheus/" class="post-meta-item leancloud_visitors" data-flag-title="使用 Grafana 和 Prometheus 搭建监控" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文介绍如何通过 <code>Dockers Compose</code> 安装 <code>Grafana</code> 和 <code>Prometheus</code> 在局域网中配合各类 <code>exporter</code> 为主机和诸多内部服务搭建监控。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/11/18/setup-monitoring-using-grafana-and-prometheus/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.moralok.com/2023/11/13/simple-implementation-of-distributed-lock-based-on-Redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Moralok">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Moralok">
      <meta itemprop="description" content="假如生命只剩一天">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Moralok">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/13/simple-implementation-of-distributed-lock-based-on-Redis/" class="post-title-link" itemprop="url">基于 Redis 的分布式锁的简单实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-13 14:02:49" itemprop="dateCreated datePublished" datetime="2023-11-13T14:02:49+08:00">2023-11-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-01-25 19:49:56" itemprop="dateModified" datetime="2024-01-25T19:49:56+08:00">2024-01-25</time>
    </span>

  
    <span id="/2023/11/13/simple-implementation-of-distributed-lock-based-on-Redis/" class="post-meta-item leancloud_visitors" data-flag-title="基于 Redis 的分布式锁的简单实现" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在分布式应用中，并发访问资源需要谨慎考虑。比如读取和修改保存并不是一个原子操作，在并发时，就可能发生修改的结果被覆盖的问题。</p>
<img src="/2023/11/13/simple-implementation-of-distributed-lock-based-on-Redis/Pasted%20image%2020231110180458.png" class="" title="分布式应用中的并发问题">

<p>很多人都了解在必要的时候需要使用分布式锁来限制程序的并发执行，但是在具体的细节上，往往并不正确。</p>
<h2 id="基于-Redis-的分布式锁简单实现"><a href="#基于-Redis-的分布式锁简单实现" class="headerlink" title="基于 Redis 的分布式锁简单实现"></a>基于 Redis 的分布式锁简单实现</h2><p>本质上要实现的目标就是在 Redis 中占坑，告诉后来者资源已经被锁定，放弃或者稍后重试。Redis 原生支持 set if not exists 的语义。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">setnx lock:user1 <span class="literal">true</span></span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">... do something</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">del lock:user1</span></span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<h3 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h3><h4 id="问题一：异常引发死锁-1"><a href="#问题一：异常引发死锁-1" class="headerlink" title="问题一：异常引发死锁 1"></a>问题一：异常引发死锁 1</h4><p>如果在处理过程中，程序出现异常，将导致 del 指令没有执行成功。锁无法释放，其他线程将无法再获取锁。</p>
<img src="/2023/11/13/simple-implementation-of-distributed-lock-based-on-Redis/Pasted%20image%2020231110182254.png" class="" title="异常引发死锁 1">

<h4 id="改进一：设置超时时间"><a href="#改进一：设置超时时间" class="headerlink" title="改进一：设置超时时间"></a>改进一：设置超时时间</h4><p>对 key 设置过期时间，如果在处理过程中，程序出现异常，导致 del 指令没有执行成功，设置的过期时间一到，key 将自动被删除，锁也就等于被释放了。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">setnx lock:user1 <span class="literal">true</span></span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">expire lock:user1 5</span></span><br><span class="line"></span><br><span class="line">... do something</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">del lock:user1</span></span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<h4 id="问题二：异常引发死锁-2"><a href="#问题二：异常引发死锁-2" class="headerlink" title="问题二：异常引发死锁 2"></a>问题二：异常引发死锁 2</h4><p>事实上，上述措施并没有彻底解决问题。如果在设置 key 的超时时间之前，程序出现异常，一切仍旧会发生。</p>
<img src="/2023/11/13/simple-implementation-of-distributed-lock-based-on-Redis/Pasted%20image%2020231110190407.png" class="" title="异常引发死锁 2">

<p>本质原因是 setnx 和 expire 两个指令不是一个原子操作。那么是否可以使用 Redis 的事务解决呢？不行。因为 expire 依赖于 setnx 的执行结果，如果 setnx 没有成功，expire 就不应该执行。</p>
<h4 id="改进二：setnx-expire-的原子指令"><a href="#改进二：setnx-expire-的原子指令" class="headerlink" title="改进二：setnx + expire 的原子指令"></a>改进二：setnx + expire 的原子指令</h4><p>如果 setnx 和 expire 可以用一个原子指令实现就好了。</p>
<img src="/2023/11/13/simple-implementation-of-distributed-lock-based-on-Redis/Pasted%20image%2020231110190442.png" class="" title="setnx + expire 原子指令">

<h5 id="基于原生指令的实现"><a href="#基于原生指令的实现" class="headerlink" title="基于原生指令的实现"></a>基于原生指令的实现</h5><p>在 Redis 2.8 版本中，Redis 的作者加入 set 指令扩展参数，允许 setnx 和 expire 组合成一个原子指令。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">set</span> lock:user1 <span class="literal">true</span> ex 5 nx</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">... do something</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">del lock:user1</span></span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<h5 id="基于-Lua-脚本的实现"><a href="#基于-Lua-脚本的实现" class="headerlink" title="基于 Lua 脚本的实现"></a>基于 Lua 脚本的实现</h5><p>除了使用原生的指令外，还可以使用 Lua 脚本，将多个 Redis 指令组合成一个原子指令。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;setnx&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]) == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">  redis.call(<span class="string">&#x27;expire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>])</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="超时问题"><a href="#超时问题" class="headerlink" title="超时问题"></a>超时问题</h3><p>基于 Redis 的分布式锁还会面临超时问题。如果在加锁和释放之间的处理逻辑过于耗时，以至于超出了 key 的过期时间，锁将在处理结束前被释放，就可能发生问题。</p>
<img src="/2023/11/13/simple-implementation-of-distributed-lock-based-on-Redis/Pasted%20image%2020231110191738.png" class="" title="其他线程提前进入临界区">

<h4 id="问题一：其他线程提前进入临界区"><a href="#问题一：其他线程提前进入临界区" class="headerlink" title="问题一：其他线程提前进入临界区"></a>问题一：其他线程提前进入临界区</h4><p>如果第一个线程因为处理逻辑过于耗时导致在处理结束前锁已经被释放，其他线程将可以提前获得锁，临界区的代码将不能保证严格串行执行。</p>
<h4 id="问题二：错误释放其他线程的锁"><a href="#问题二：错误释放其他线程的锁" class="headerlink" title="问题二：错误释放其他线程的锁"></a>问题二：错误释放其他线程的锁</h4><p>如果在第二个线程获得锁后，第一个线程刚好处理逻辑结束去释放锁，将导致第二个线程的锁提前被释放，引发连锁问题。</p>
<h4 id="改进一：不要用于较长时间的任务"><a href="#改进一：不要用于较长时间的任务" class="headerlink" title="改进一：不要用于较长时间的任务"></a>改进一：不要用于较长时间的任务</h4><p>与其说是改进，不如说是注意事项。如果真的出现问题，造成的数据错误可能需要人工介入解决。</p>
<p>如果真的存在这样的业务场景，应考虑使用其他解决方案加以优化。</p>
<h4 id="改进二：使用-watchdog-实现锁续期"><a href="#改进二：使用-watchdog-实现锁续期" class="headerlink" title="改进二：使用 watchdog 实现锁续期"></a>改进二：使用 watchdog 实现锁续期</h4><p>为 Redis 的 key 设置过期时间，其实是为了解决死锁问题而做出的兜底措施。可以为获得的锁设置定时任务定期地为锁续期，以避免锁被提前释放。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">scheduleRenewal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> lockValue.get();</span><br><span class="line">    ScheduledFuture&lt;?&gt; scheduledFuture = sScheduler.scheduleAtFixedRate(</span><br><span class="line">        () -&gt; <span class="built_in">this</span>.renewal(value), RENEWAL_INTERVAL, RENEWAL_INTERVAL, TimeUnit.MILLISECONDS</span><br><span class="line">    );</span><br><span class="line">    renewalTask.set(scheduledFuture);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这个方式仍然不能避免解锁失败时的其他线程的等待时间。</p>
<h4 id="改进三：加锁时指定-tag"><a href="#改进三：加锁时指定-tag" class="headerlink" title="改进三：加锁时指定 tag"></a>改进三：加锁时指定 tag</h4><p>可以将 set 指令的 value 参数设置为一个随机数，释放锁时先匹配持有的 tag 是否和 value 一致，如果一致再删除 key，以此避免锁被其他线程错误释放。</p>
<h5 id="基于原生指令的实现-1"><a href="#基于原生指令的实现-1" class="headerlink" title="基于原生指令的实现"></a>基于原生指令的实现</h5><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tag = random.nextint()</span><br><span class="line">if redis.set(key, tag, nx= True, ex=5):</span><br><span class="line">	do_something()</span><br><span class="line">	redis.delifequals(key, tag)</span><br></pre></td></tr></table></figure>

<p>但是注意，Redis 并没有提供语义为 delete if equals 的原子指令，这样的话问题并不能被彻底解决。如果在第一个线程判断 tag 是否和 value 相等之后，第二个线程刚好获得了锁，然后第一个线程因为匹配成功执行删除 key 操作，仍然将导致第二个线程获得的锁被第一个线程错误释放。</p>
<img src="/2023/11/13/simple-implementation-of-distributed-lock-based-on-Redis/Pasted%20image%2020231110193919.png" class="" title="错误释放其他线程的锁">

<h5 id="基于-Lua-脚本的实现-1"><a href="#基于-Lua-脚本的实现-1" class="headerlink" title="基于 Lua 脚本的实现"></a>基于 Lua 脚本的实现</h5><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h3><p>可重入性是指线程在已经持有锁的情况下再次请求加锁，如果一个锁支持同一个线程多次加锁，那么就称这个锁是可重入的，类似 Java 的 ReentrantLock。</p>
<h4 id="使用-ThreadLocal-实现锁计数"><a href="#使用-ThreadLocal-实现锁计数" class="headerlink" title="使用 ThreadLocal 实现锁计数"></a>使用 ThreadLocal 实现锁计数</h4><p>Redis 分布式锁如果要支持可重入，可以使用线程的 ThreadLocal 变量存储当前持有的锁计数。但是在多次获得锁后，过期时间并没有得到延长，后续获得锁后持有锁的时间其实比设置的时间更短。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ThreadLocal&lt;Integer&gt; lockCount = ThreadLocal.withInitial(() -&gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> lockCount.get();  </span><br><span class="line">    <span class="keyword">if</span> (count != <span class="literal">null</span> &amp;&amp; count &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">        lockCount.set(count + <span class="number">1</span>);   </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;    </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> commands.set(lockKey, lockValue.get(), SetArgs.Builder.nx().px(RedisLockManager.LOCK_EXPIRE));  </span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;OK&quot;</span>.equals(result)) &#123;  </span><br><span class="line">        lockCount.set(<span class="number">1</span>);  </span><br><span class="line">        scheduleRenewal();  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;    </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用-Redis-hash-实现锁计数"><a href="#使用-Redis-hash-实现锁计数" class="headerlink" title="使用 Redis hash 实现锁计数"></a>使用 Redis hash 实现锁计数</h4><p>还可以使用 Redis 的 hash 数据结构实现锁计数，支持重新获取锁后重置过期时间。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;exists&#x27;</span>, KEYS[<span class="number">1</span>]) == <span class="number">0</span>) <span class="keyword">then</span> </span><br><span class="line">	redis.call(<span class="string">&#x27;hset&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>], <span class="number">1</span>);</span><br><span class="line">	redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;hexists&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>]) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">	redis.call(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>], <span class="number">1</span>);</span><br><span class="line">	redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">return</span> redis.call(<span class="string">&#x27;pttl&#x27;</span>, KEYS[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<p>书的作者<strong>不推荐使用可重入锁</strong>，他提出可重入锁会加重客户端的复杂度，如果在编写代码时注意在逻辑结构上进行调整，完全可以避免使用可重入锁。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><a target="_blank" rel="noopener" href="https://github.com/moralok/redis-lock">redis-lock</a></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li>《Redis 深度历险，核心原理与应用实践》</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.moralok.com/2023/11/09/some-examples-of-Java-bytecode-instruction-analysis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Moralok">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Moralok">
      <meta itemprop="description" content="假如生命只剩一天">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Moralok">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/09/some-examples-of-Java-bytecode-instruction-analysis/" class="post-title-link" itemprop="url">关于 Java 字节码指令的一些例子分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-09 23:13:11" itemprop="dateCreated datePublished" datetime="2023-11-09T23:13:11+08:00">2023-11-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-01-25 19:49:56" itemprop="dateModified" datetime="2024-01-25T19:49:56+08:00">2024-01-25</time>
    </span>

  
    <span id="/2023/11/09/some-examples-of-Java-bytecode-instruction-analysis/" class="post-meta-item leancloud_visitors" data-flag-title="关于 Java 字节码指令的一些例子分析" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>925</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="演示字节码指令的执行"><a href="#演示字节码指令的执行" class="headerlink" title="演示字节码指令的执行"></a>演示字节码指令的执行</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteCodeTest_2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Short.MAX_VALUE + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="操作数栈和本地变量表的大小"><a href="#操作数栈和本地变量表的大小" class="headerlink" title="操作数栈和本地变量表的大小"></a>操作数栈和本地变量表的大小</h3><p>在编译期间就可计算得到操作数栈和本地变量表的大小。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack=2, locals=4, args_size=1</span><br></pre></td></tr></table></figure>

<h3 id="本地变量表"><a href="#本地变量表" class="headerlink" title="本地变量表"></a>本地变量表</h3><p>Slot，即槽位，可理解为索引。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Start  Length  Slot  Name   Signature</span><br><span class="line">    0      18     0  args   [Ljava/lang/String;</span><br><span class="line">    3      15     1     a   I</span><br><span class="line">    6      12     2     b   I</span><br><span class="line">   10       8     3     c   I</span><br></pre></td></tr></table></figure>

<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3 = Integer            32768</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4 = Fieldref           <span class="comment">#27.#28        // java/lang/System.out:Ljava/io/PrintStream;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">5 = Methodref          <span class="comment">#29.#30        // java/io/PrintStream.println:(I)V</span></span> </span><br></pre></td></tr></table></figure>

<img src="/2023/11/09/some-examples-of-Java-bytecode-instruction-analysis/Snipaste_2023-11-10_00-28-14.png" class="" title="字节码指令执行栈帧示意图">

<h3 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h3><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> 0: bipush        10</span><br><span class="line"> 2: istore_1</span><br><span class="line"> 3: ldc           #3             // int 32768</span><br><span class="line"> 5: istore_2</span><br><span class="line"> 6: iload_1</span><br><span class="line"> 7: iload_2</span><br><span class="line"> 8: iadd</span><br><span class="line"> 9: istore_3</span><br><span class="line">10: getstatic     #4             // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">13: iload_3</span><br><span class="line">14: invokevirtual #5             // Method java/io/PrintStream.println:(I)V</span><br><span class="line">17: return</span><br></pre></td></tr></table></figure>
<ul>
<li>bipush，将一个 byte，推入操作数栈。<ul>
<li>short 范围内的数是和字节码指令一起存储的，范围外的数是存储在运行时常量池中的。</li>
<li>操作数栈的宽度是 4 个字节，short 范围内的数在推入操作数栈前会经过符号扩展成为 int。</li>
</ul>
</li>
<li>istore_1，将栈顶的 int，存入局部变量表，槽位 1。</li>
<li>ldc，从运行时常量池中将指定常量推入操作数栈。</li>
<li>istore_2，将栈顶的 int，存入局部变量表，槽位 2。</li>
<li>iload_1 iload_2，依次从局部变量表将两个 int 推入操作数栈，槽位分别是 1 和 2。</li>
<li>iadd，将栈顶的两个 int 弹出并相加，将结果推入操作数栈。</li>
<li>istore_3，将栈顶的 int，存入局部变量表，槽位 3。</li>
<li>getstatic，获取类的静态属性，推入操作数栈。</li>
<li>iload_3，从局部变量表将 int 推入操作数栈，槽位 3。</li>
<li>invokevirtual，将栈顶的参数依次弹出，调用实例方法。</li>
<li>return，返回 void</li>
</ul>
<h2 id="分析-a-和-a"><a href="#分析-a-和-a" class="headerlink" title="分析 a++ 和 ++a"></a>分析 a++ 和 ++a</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteCodeTest_3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a++ + ++a + a--;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字节码指令-1"><a href="#字节码指令-1" class="headerlink" title="字节码指令"></a>字节码指令</h3><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> 0: bipush        10</span><br><span class="line"> 2: istore_1</span><br><span class="line"> 3: iload_1</span><br><span class="line"> 4: iinc          1, 1</span><br><span class="line"> 7: iinc          1, 1</span><br><span class="line">10: iload_1</span><br><span class="line">11: iadd</span><br><span class="line">12: iload_1</span><br><span class="line">13: iinc          1, -1</span><br><span class="line">16: iadd</span><br><span class="line">17: istore_2</span><br></pre></td></tr></table></figure>

<ul>
<li>a++ 和 ++a 的区别是先 load 还是先 iinc。</li>
<li>iinc，将局部变量表指定槽位的数加上一个常数。</li>
<li>注意 a 只 load 到操作数栈并没有 store 回局部变量表。</li>
<li>b &#x3D; 10 + 12 + 12 &#x3D; 34</li>
<li>a &#x3D; 10 + 1 + 1 - 1 &#x3D; 11</li>
</ul>
<h2 id="分析判断条件"><a href="#分析判断条件" class="headerlink" title="分析判断条件"></a>分析判断条件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteCodeTest_4</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// ifeq, goto</span></span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">            a = <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            a = <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字节码指令-2"><a href="#字节码指令-2" class="headerlink" title="字节码指令"></a>字节码指令</h3><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> 0: iconst_0</span><br><span class="line"> 1: istore_1</span><br><span class="line"> 2: iload_1</span><br><span class="line"> 3: ifne          12</span><br><span class="line"> 6: bipush        10</span><br><span class="line"> 8: istore_1</span><br><span class="line"> 9: goto          15</span><br><span class="line">12: bipush        20</span><br><span class="line">14: istore_1</span><br><span class="line">15: return</span><br></pre></td></tr></table></figure>

<ul>
<li>iconst，将一个 int 常量推入操作数栈。</li>
<li>if<code>&lt;cond&gt;</code>，一个 int 和 0 的比较成立时进入分支，跳转到指定行号。</li>
<li>goto，总是进入的分支，跳转到指定行号。</li>
</ul>
<h2 id="涉及的字节码指令"><a href="#涉及的字节码指令" class="headerlink" title="涉及的字节码指令"></a>涉及的字节码指令</h2><ul>
<li>bipush，将一个 byte 符号扩展为一个 int，推入操作数栈。</li>
<li>istore，将栈顶的 int，存入局部变量表的指定槽位。</li>
<li>iload，将局部变量表指定槽位的 int，推入操作数栈。</li>
<li>ldc，从运行时常量池将指定常量推入操作数栈。</li>
<li>iadd，将栈顶的两个 int 弹出并相加，将结果推入操作数栈。</li>
<li>getstatic，获取类的静态属性，推入操作数栈。</li>
<li>invokevirtual，将栈顶的参数依次弹出，调用实例方法。</li>
<li>return，返回 void。</li>
<li>iinc，将局部变量表中指定槽位的数加一个常量。</li>
<li>if<code>&lt;cond&gt;</code>，一个 int 和 0 的比较成立时进入分支，跳转到指定行号。<ul>
<li>ifeq，equals</li>
<li>ifne，not equals</li>
<li>iflt，less than</li>
<li>ifge，greater than or equals</li>
<li>ifgt，great than</li>
<li>ifle，less than or equals</li>
</ul>
</li>
<li>goto，总是进入的分支，跳转到指定行号。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.moralok.com/2023/11/07/garbage-collection-in-Java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Moralok">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Moralok">
      <meta itemprop="description" content="假如生命只剩一天">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Moralok">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/07/garbage-collection-in-Java/" class="post-title-link" itemprop="url">Java 垃圾收集</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-08 00:44:21" itemprop="dateCreated datePublished" datetime="2023-11-08T00:44:21+08:00">2023-11-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-01-25 19:49:56" itemprop="dateModified" datetime="2024-01-25T19:49:56+08:00">2024-01-25</time>
    </span>

  
    <span id="/2023/11/07/garbage-collection-in-Java/" class="post-meta-item leancloud_visitors" data-flag-title="Java 垃圾收集" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>28 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>每一次重新阅读，都有新的收获，也将过去这段时间以来一些新的零散的知识点串联在一起。<br>沿着周志明老师的行文脉络，了解问题发生的背景，当时的人如何思考，提出了哪些方案，各自有什么优缺点，附带产生的问题如何解决，理论研究如何应用到工程实践中，就像真实地经历一段研发历史。这让人对垃圾收集的认识不再停留在记忆上，而是深入到理解中，相关的知识点不再是空中楼阁，无根之水，而是从一些事实基础和问题自然延申出来。<br>尽管在更底层的实现上仍然缺乏认识和想象力，以至于在一些细节上还是疑惑重重，但是仍然有豁然开朗的感觉呢。比如以前看不同垃圾收集器的过程示意图如鸡肋，如今看其中的停顿和并发，只觉充满智慧。</p>
</blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>垃圾收集（Garbage Collection，简称 GC）需要考虑什么？</strong></p>
<ul>
<li>哪些内存需要回收？</li>
<li>什么时候回收？</li>
<li>如何回收？</li>
</ul>
<p><strong>为什么要去了解垃圾收集和内存分配？</strong><br>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就需要对这些“自动化技术”实施必要的监控和调节。</p>
<p><strong>在 Java 中，垃圾收集需要关注哪些内存区域？</strong><br>程序计数器、虚拟机栈和本地方法栈，随线程而生，随线程而灭，栈中的栈帧随着方法的进入和退出有条不紊地执行着入栈和出栈操作，每个栈帧中分配多少内存可以认为是<strong>编译期可知</strong>的，因此这几个区域地内存分配和回收具备确定性。<br>但是 Java 堆和方法区这两个区域则有显著的不确定性，只有<strong>运行期间</strong>，我们才知道程序会创建哪些对象，创建多少个对象，这部分内存的分配和回收是动态的。</p>
<h2 id="哪些内存需要回收？"><a href="#哪些内存需要回收？" class="headerlink" title="哪些内存需要回收？"></a>哪些内存需要回收？</h2><p><strong>哪些对象是还存活着，哪些已经死亡？</strong></p>
<blockquote>
<p>对象死亡即不可能再被任何途径使用。其实曾经的我会怀疑，遗落在内存中的对象，真的没有办法“魔法般地”获取其引用地址吗？引用变量的值不就是 64 位的数字吗？</p>
</blockquote>
<h3 id="引用计数算法（Reference-Counting）"><a href="#引用计数算法（Reference-Counting）" class="headerlink" title="引用计数算法（Reference Counting）"></a>引用计数算法（Reference Counting）</h3><p>优点：</p>
<ul>
<li>原理简单</li>
<li>判定效率高</li>
</ul>
<p>缺点：</p>
<ul>
<li>例外情况多，需要额外处理（比如循环引用）</li>
</ul>
<blockquote>
<p>提及引用计数算法，人们好像认定它无法应对循环引用因而被抛弃。虽说 Java 虚拟机中没有选用它，但是在其他计算机领域有所运用。循环引用也并非它绕不过去的难题，事实上，跨代引用问题中，老年代引用新生代形成的引用链不是也可能是一个尚未回收的孤岛吗？</p>
</blockquote>
<h3 id="可达性分析算法（Reachability-Analysis）"><a href="#可达性分析算法（Reachability-Analysis）" class="headerlink" title="可达性分析算法（Reachability Analysis）"></a>可达性分析算法（Reachability Analysis）</h3><ul>
<li>选取一系列称为“GC Roots”的根对象作为起始节点集。</li>
<li>根据引用关系向下搜索。</li>
<li>如果某个对象到 GC Roots 间没有任何引用链相连，即该对象不可能再被使用。用图论的话说，就是 GC Roots 到该对象不可达。</li>
</ul>
<img src="/2023/11/07/garbage-collection-in-Java/Pasted%20image%2020231108011042.png" class="" title="利用可达性分析算法判定对象是否可回收">

<p><strong>那么可作为 GC Roots 的对象有哪些呢？</strong><br>固定的 GC Roots，主要是在全局性引用和执行上下文中：</p>
<ol>
<li>在虚拟机栈（栈帧中的本地变量表）中引用的对象，比如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</li>
<li>在方法区中类静态属性引用的变量。</li>
<li>在方法区中类常量引用的对象，比如字符串常量池（String Table）里的引用。</li>
<li>在本地方法栈中 JNI，即 Native 方法引用的对象。</li>
<li>Java 虚拟机内部的引用，如基本类型的 Class 对象，常驻的异常类型，还有系统类加载器。</li>
<li>所有被同步锁（synchronized）持有的对象</li>
<li>反映 Java 虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等（不懂）。</li>
</ol>
<p>临时性的GC Roots：<br>除了固定的 GC Roots 集合外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入。</p>
<blockquote>
<p>比如，当针对新生代发起垃圾收集时，如果老年代对象引用了它，那么被引用的对象就不应该被回收，尽管老年代对象可能已经不可达。为此，老年代对象需要临时性加入 GC Roots 集合。<br>当然，为了避免将所有老年代对象加入 GC Roots 集合这样一看就很不合理的操作，会做一些优化处理。</p>
</blockquote>
<img src="/2023/11/07/garbage-collection-in-Java/Snipaste_2023-11-08_20-01-41.png" class="" title="跨代引用问题">

<h3 id="“引用”的概念扩充"><a href="#“引用”的概念扩充" class="headerlink" title="“引用”的概念扩充"></a>“引用”的概念扩充</h3><p>对于判断对象是否存活而言，“引用”的重要性不言而喻。但是如果对象只有“被引用”和“未被引用”两种状态，对于描述一些“内存足够就保留，内存不足就抛弃”的对象就显得无能为力。<br>缓存系统就是这样的一个典型应用场景。当内存充足时，就保留作为缓存；当内存不足时，就抛弃腾出空间给其他资源。</p>
<blockquote>
<p>曾经有一位热衷实践技术的同事就和我介绍了他在项目中使用弱引用实现的缓存模块，当时我还不太理解他为何这样做。事实上，享受自动垃圾收集的我并不能在一开始就敏锐地把握到对象在应用程序中的创建、存活和消亡过程。<br>当然我们并不推荐自己实现基于 JVM 的缓存系统，事实上他之所以提及，正是因为出了 bug。</p>
</blockquote>
<h4 id="引用的分类"><a href="#引用的分类" class="headerlink" title="引用的分类"></a>引用的分类</h4><ul>
<li>强引用（Strongly Reference），只要强引用还在，绝不会回收。</li>
<li>软引用（Soft Reference），只被软引用关联的对象，在系统发生 OOM 前，会被列入回收范围进行第二次回收。</li>
<li>弱引用（Weak Reference），只被弱引用关联的对象，只能生存到下一次垃圾收集发生为止，无论内存是否 足够，都会回收。</li>
<li>虚引用（Phantom Reference），一个对象是否有虚引用，不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。设置虚引用的唯一目的就是为了在对象被回收时收到一个系统通知。</li>
</ul>
<p>虚引用的一个经典应用是是 ByteBuffer 对象被回收时自动释放直接内存。</p>
<h4 id="弱引用的测试"><a href="#弱引用的测试" class="headerlink" title="弱引用的测试"></a>弱引用的测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceTest_3</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_4MB</span> <span class="operator">=</span> <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -Xmx20m -XX:+PrintGCDetails -verbose:gc</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// list -&gt; WeakReference -&gt; byte[]</span></span><br><span class="line">        List&lt;WeakReference&lt;<span class="type">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            WeakReference&lt;<span class="type">byte</span>[]&gt; ref = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[_4MB]);</span><br><span class="line">            list.add(ref);</span><br><span class="line">            System.out.print(list.size() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (WeakReference&lt;<span class="type">byte</span>[]&gt; w : list) &#123;</span><br><span class="line"></span><br><span class="line">                System.out.print(w.get() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;循环结束： &quot;</span> + list.size());</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在测试中，minor GC 并没有回收掉全部的只被弱引用关联的对象，full GC 才全部回收掉，我一度以为关于弱引用的表述不正确。后来进一步测试发现，是因为部分对象直接分配在老年代。因此更准确的表述是，每一次 GC 都会回收所在发生区域里只被弱引用关联的对象。<br>这是一个有趣的经验，让我对部分垃圾收集中的“部分”二字有更深刻的体会，原来非收集区域的对象真的对发生在其他区域的垃圾收集无感。</p>
</blockquote>
<blockquote>
<p>了解为什么扩充引用的概念，让人对引用的分类豁然开朗。我的脑海里情不自禁冒出了不太恰当的比喻：一个城市里的公民被区分了等级，一等公民（强）永远不会被强行驱逐；二等公民（软）在城市资源紧张时会被强行驱逐；三等公民（弱）被认为影响市容市貌，一旦有整顿就会被强行驱逐；一等公民里有一些需要被监视，一旦离开，会触发一个事件。</p>
</blockquote>
<h3 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize 方法"></a>finalize 方法</h3><blockquote>
<p>有趣的知识点，无趣的面试考点。</p>
</blockquote>
<h3 id="方法区的垃圾回收是什么样的？"><a href="#方法区的垃圾回收是什么样的？" class="headerlink" title="方法区的垃圾回收是什么样的？"></a>方法区的垃圾回收是什么样的？</h3><ul>
<li>《Java虚拟机规范》中提到可以不要求虚拟机在方法区实现垃圾收集</li>
<li>确实有未实现或未完整实现方法区类型卸载的收集器</li>
<li>原因是<strong>方法区垃圾收集的性价比通常比较低</strong></li>
</ul>
<p>方法区的垃圾收集主要回收两部分：</p>
<ul>
<li>废弃的常量</li>
<li>不再使用的类型</li>
</ul>
<p><strong>如何判定一个常量是否废弃？</strong><br>没有任何字符串对象引用常量池中的“java”常量，且虚拟机中也没有其他地方引用这个字面量。<br>如果这时发生垃圾回收，而且垃圾收集器判断确实有必要，才会将“java”常量清理出常量池。</p>
<blockquote>
<p>“虚拟机中也没有其他地方引用这个字面量”怎么理解？</p>
</blockquote>
<p><strong>如何判定一个类型是否可卸载？</strong></p>
<ul>
<li>该类的所有的实例都已经被回收</li>
<li>加载该类的类加载器已经被回收</li>
<li>该类对应的 Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li>
</ul>
<p>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是<br>和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot 虚拟机提供了 -Xnoclassgc 参数进行控制，还可以使用 -verbose:class 以及 -XX:+TraceClassLoading、-XX:+TraceClassUnLoading 查看类加载和卸载信息。</p>
<blockquote>
<p>条件二如此苛刻，系统类加载器不会被回收，是否意味着正常的应用程序，类一旦加载就不会卸载？<br>“无法在任何地方通过反射访问该类的方法”是否多余，Method 对象不是引用了 Class 对象吗？<br>Class 对象没有被引用时，会被回收吗？<br>卸载类是指回收 Class 对象加上清理方法区中的类的信息（怎么样的存储结构呢）吗？</p>
</blockquote>
<h2 id="如何回收：垃圾收集算法"><a href="#如何回收：垃圾收集算法" class="headerlink" title="如何回收：垃圾收集算法"></a>如何回收：垃圾收集算法</h2><p>分类：</p>
<ul>
<li>引用计数式垃圾收集（Reference Counting GC）</li>
<li>追踪式垃圾收集（Tracing GC）</li>
</ul>
<h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><p>分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则，它建立在<strong>两个分代假说</strong>之上：</p>
<ol>
<li>弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。</li>
<li>强分代假说（String Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。</li>
</ol>
<p>这两个分代假说共同奠定了多款常用垃圾收集器的<strong>一致的设计原则</strong>：收集器应该将 Java 堆划分出不同的区域，然后将回收对象依据其年龄分配到不同的区域之中存储。<br>正因为有了区域划分，垃圾收集器才可以每次只回收一个或某些部分的区域，因而才有了“Minor GC”、“Major GC”和“Full GC”等回收类型划分；针对不同区域安排与里面存储对象存亡特征相匹配的垃圾收集算法，因而才发展出“标记-复制”、“标记-清除”和“标记-整理”等垃圾收集算法。</p>
<blockquote>
<p>了解分代收集理论，分代收集算法更显得有理有据。</p>
</blockquote>
<p>一般把 Java 堆划分为新生代（Young Generation）和老年代（Old Generation）两个区域。</p>
<p><strong>针对不同分代的垃圾收集分类：</strong></p>
<ul>
<li>部分收集（Partial GC）：目标不是完整收集整个堆、<ul>
<li>新生代收集（Minor GC&#x2F;Young GC）</li>
<li>老年代收集（Major GC&#x2F;Old GC）：只有 CMS。Major GC有些混淆，应按上下文注意是老年代收集还是整堆收集。</li>
<li>混合收集（Mixed GC）：只有 G1</li>
</ul>
</li>
<li>整堆收集（Full GC）</li>
</ul>
<p>区域划分引起另一个问题，跨代引用。这个问题在前文的 GC Roots 选择时也提到过。<br>根据前两条假说可逻辑推理得出隐含推论：存在相互引用关系的两个对象，是应该倾向于同时生存或者同时消亡的。</p>
<ol start="3">
<li>跨代引用假说（Integenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。</li>
</ol>
<p>依据这条假说，我们不应再为少量的跨代引用而去扫描整个老年代。那么怎么处理跨代引用呢？在后面 HotSpot 的实现细节中我们再提。</p>
<h3 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark Sweep）"></a>标记-清除算法（Mark Sweep）</h3><p>在 1960 年由 Lisp 之父 John McCarthy 提出，分为标记和清除两个阶段。<br>缺点：</p>
<ul>
<li>执行效率不稳定，对象越多，且需要回收的对象越多，效率会降低。</li>
<li>内存空间碎片化，长时间后没有足够的连续内存分配大对象。</li>
</ul>
<img src="/2023/11/07/garbage-collection-in-Java/Pasted%20image%2020231108041337.png" class="" title="“标记-清除”算法示意图">

<h3 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h3><p>为解决标记-清除算法面对大量可回收对象时执行效率低的问题，1969 年 Fenichel 提出“半区复制”（Semispace Copying）。将内存划分为大小相等的两块，每次只使用一块，用完的时候，复制存活的对象到另一块。</p>
<p>优点：</p>
<ul>
<li>存活对象少时，仅需复制少量对象。</li>
<li>不存在内存空间碎片</li>
</ul>
<p>缺点：</p>
<ul>
<li>空间浪费</li>
</ul>
<p>适用场景：</p>
<ul>
<li>新生代。</li>
</ul>
<img src="/2023/11/07/garbage-collection-in-Java/Pasted%20image%2020231108042320.png" class="" title="标记-复制算法示意图">

<p><strong>怎么减少空间的浪费呢？</strong><br>IBM 公司研究表明新生代中 98% 的对象熬不过第一轮收集。在 1989 年，Andrew Appel 针对具备“朝生夕灭”特点的对象，提出了一种更优化的半区复制分代策略，现在称为“Appel 式回收”。具体做法是把新生代分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次分配内存只使用 Eden 和其中一块 Survivor。<br>HotSpot 虚拟机默认 Eden:Suvivor 为 8:1。</p>
<blockquote>
<p>在测试中，尽管 survivor 有空间，仍然只在 Eden 空间进行分配。</p>
</blockquote>
<p>如果 Survivor 空间不足以容纳一次 Minor GC 之后存活的对象时怎么办？<br>罕见情况的“逃生门”——使用其他区域（通常是老年代）进行分配担保（Handle Promotion）。</p>
<h3 id="标记-整理算法（Mark-Compact）"><a href="#标记-整理算法（Mark-Compact）" class="headerlink" title="标记-整理算法（Mark Compact）"></a>标记-整理算法（Mark Compact）</h3><p>标记-复制算法面对对象存活率较高的情况，效率会降低；更关键的是，它需要额外空间进行分配担保。<br>针对老年代对象的存亡特征，1974 年 Edward Lueders 提出了另外一种有针对性的“标记-整理”算法，让所有存活对象都向内存空间一端移动。</p>
<blockquote>
<p>移动和复制的开销有什么差距吗？撇开分配担保问题，大量复制和大量移动是类似的把？</p>
</blockquote>
<img src="/2023/11/07/garbage-collection-in-Java/Pasted%20image%2020231108044446.png" class="" title="标记-整理算法示意图">

<p>移动对象的弊端</p>
<ul>
<li>大量对象存活的话需要大量移动对象，负担重。在以前，对象移动操作必须全程暂停用户应用程序才能进行（STW，Stop The World）。</li>
<li>不整理内存碎片的话，需要依赖更复杂的内存分配器和内存访问器解决。内存访问最频繁，反而影响吞吐量。</li>
</ul>
<p>不移动对象停顿时间会更短，甚至可以不需要停顿，但是从整个程序的吞吐量来看，移动对象会更划算。在这点上的区别分别演变出两种发展方向，低延迟和高吞吐量。</p>
<blockquote>
<p>书中提到的内存分配器和内存访问器解决的是在碎片化的内存空间中进行内存分配，还是可以将大对象分散地存储到碎片化的空间中呢？还提到硬盘存储大文件不要求物理连续的磁盘空间以及内存访问环节的额外负担，应该是指一种分散存储的实现方案吧？</p>
</blockquote>
<blockquote>
<p>对于 CMS 的“和稀泥”解决方案，暂时容忍内存碎片，直到影响对象分配时再采用标记-整理算法收集一次，如果抛开备用的 Serial Old 单线程的效率问题不谈，除非在碎片化的内存空间中分配和访问内存在效率上低于在整理后的内存空间中，要不然“和稀泥”这种懒惰式的处理方案理论上效率更高吧？</p>
</blockquote>
<h2 id="HotSpot-的算法细节实现"><a href="#HotSpot-的算法细节实现" class="headerlink" title="HotSpot 的算法细节实现"></a>HotSpot 的算法细节实现</h2><h3 id="根节点枚举"><a href="#根节点枚举" class="headerlink" title="根节点枚举"></a>根节点枚举</h3><p><strong>对象浩如烟海，怎么实现高效查找根节点的呢？</strong></p>
<p>迄今为止，<strong>所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的</strong>。这是因为根节点枚举如果不在一个一致性快照中进行，准确性无法保证。</p>
<p>Exact VM 类型的虚拟机使用的是准确式垃圾回收，当用户线程停顿后，不需要一个不漏地检查完所有执行上下文和全局的引用位置，就有办法直接得到哪些地方存放着对象引用。HotSpot 的具体解决方案是使用一组称为 OopMap（Ordinary Object Pointer Map） 的数据结构。</p>
<ul>
<li>一旦类加载动作完成，HotSpot 会把对象内什么偏移量上是什么类型的数据计算出来。</li>
<li>在即时编译过程中，也会在特定位置记录下栈和寄存器里什么位置是引用。</li>
</ul>
<blockquote>
<p>看书时，在这个地方其实有很多困惑。对于 OopMap，就像知道了一个不太懂的东西，了解了它能做什么，最明确的是，在即时编译中，会在安全点位置生成 OopMap。</p>
</blockquote>
<h4 id="如何识别数据类型"><a href="#如何识别数据类型" class="headerlink" title="如何识别数据类型"></a>如何识别数据类型</h4><p>首先，我困惑的是，非准确式垃圾回收是什么东西，要找到对象引用得怎么做？<br>书中提到，准确式内存管理是指虚拟机可以知道内存中某个位置的数据具体是什么类型。比如内存中有一个 32 位的整数 123456，虚拟机将有能力分辨出它到底是一个指向了 123456 的内存地址的引用类型还是一个数值为 123456 的整数。<br>Exact VM 抛弃掉以前 Classic VM 基于句柄（Handle）的对象查找方式，因为在垃圾收集后对象可能被移动，如果地址改变（123456-&gt;654321），在没有明确信息表明内存中哪些数值式引用类型的情况下，虚拟机肯定不能把所有123456的值改为654321，所以要使用句柄来保持引用值得稳定。</p>
<blockquote>
<p>看到这个举例之后容易理解多了，可能是没有手动管理内存的经验，对这方面体会不深刻。</p>
</blockquote>
<p>以栈为例，栈帧里装有 int、double 等类型的数值，也有引用类型变量的地址，这些值在保守式 GC 看无法直接分辨是数值还是引用。但保守式 GC 其实还是有一定的分辨能力：</p>
<ol>
<li>是不是正确的对齐值（可以理解为是一个正确的指针的值）</li>
<li>是否指向堆内的地址</li>
<li>是否指向对象的头（从这点上看，虚拟机是会尝试获取对象头校验一下吗？）</li>
</ol>
<p>但是根据这些规则进行检测还是不够的，比如某一个 int 的值刚好指向某个对象的起始地址，就恰好满足上述的所有条件，这样就可能造成该对象被错误识别为存活对象，这个现象称为对堆的压迫。<br>保守式 GC 的“保守”二字体现在它将可疑的根看作是指针进行保守地处理。</p>
<img src="/2023/11/07/garbage-collection-in-Java/Snipaste_2023-11-09_01-02-45.png" class="" title="保守式 GC 视可以根为指针">

<blockquote>
<p>死亡的对象被错误保留下来，挤占了堆空间，称其为“压迫”还听形象的。这个“保守”在理解以后才不感觉违和。</p>
</blockquote>
<h4 id="OopMap-的类型"><a href="#OopMap-的类型" class="headerlink" title="OopMap 的类型"></a>OopMap 的类型</h4><ul>
<li>类型信息里记录了自己的 OopMap，这应该对应的是“一旦类加载动作完成，HotSpot 会把对象内什么偏移量上是什么类型的数据计算出来”，从对象向它引用的对象查找时使用。</li>
<li>被 JIT 编译后的指令流，也会在特定的位置（安全点）记录下 OopMap。</li>
<li>奇怪的是，暂时没有找到明确指出在 Java 字节码的特定位置（安全点）也记录着 OopMap。</li>
</ul>
<blockquote>
<p>方法区的类静态属性和类常量也是根据类型信息里的 OopMap 查找的吗？</p>
</blockquote>
<h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p><strong>为什么引入安全点，它解决了什么问题？</strong></p>
<p>在 OopMap 的协助下，HotSpot 可以快速准确地完成 GC Roots。但是非常多的指令可能导致 OopMap 的内容发生变化。</p>
<blockquote>
<p>书中“可能导致引用关系变化……的指令非常多”这句话让人困惑，OopMap 不是为了定位哪里是引用而非引用指向哪吧？如果只看“导致 OopMap 内容变化的指令非常多”更易理解。</p>
</blockquote>
<p><strong>在哪里生成 OopMap 呢？</strong><br>既然指令会导致 OopMap 内容发生变化，最简单粗暴的就是为每一条指令生成 OopMap，但是这样会空间成本会急剧上升。<br>HotSpot 只在特定的位置生成 OopMap，这些位置被称为“安全点”（Safepoint）。<br>安全点的设定决定了并非在代码指令流的任意位置都能够停顿下来开始垃圾收集，而是要求必须到达安全点才能够暂停。</p>
<p><strong>安全点怎么选择呢？</strong></p>
<ul>
<li>不能太少以至于让收集器等太久</li>
<li>不能太频繁以至于过分增大运行时的内存负担</li>
</ul>
<p>安全点的位置的选取基本上是以“是否具有让程序长时间执行的特征”为标准进行选定的：</p>
<ul>
<li>所有的非计数循环的末尾</li>
<li>方法返回之前&#x2F;调用方法的 call 指令后</li>
<li>每条 Java 编译后的字节码的边界（不理解）</li>
<li>可能抛异常的地方</li>
</ul>
<blockquote>
<p>有没有权威的标准描述啊。</p>
</blockquote>
<p><strong>如何在垃圾收集发生时，让所有线程（不包括 JNI 调用的线程）都跑到最近的安全点，然后停顿下来呢？</strong></p>
<ul>
<li>抢先式中断（Preemptive Suspension），系统先中断全部用户线程，如果有用户线程中断的地方不是安全点，就恢复该线程执行，再中断，直到跑到安全点。（没人选）</li>
<li>主动式中断（Voluntary Suspenstion），设置一个标志位，线程执行时不停主动轮询，发现中断标志为真就在最近的安全点主动挂起。</li>
</ul>
<blockquote>
<p>这个问题和如何通知多线程一起做一件事很像，设置标志位，再让线程运行过程中轮询。</p>
</blockquote>
<p><strong>什么时候进行轮询？</strong><br>轮询标志的地方与安全点是重合的，另外还要加上创建对象和其他需要在堆上分配内存的地方，这样可以检查是否即将发生垃圾收集，避免没有足够内存分配给新对象。</p>
<blockquote>
<p>仔细一想，与安全点重合似乎是理所当然，额外选取的地方也有恰当的理由。</p>
</blockquote>
<p><strong>轮询在印象里都意味着额外开销，虚拟机如何应对？</strong><br>HotSpot 使用内存保护陷阱的方式，把轮询操作精简至只有一条汇编指令的程度。</p>
<blockquote>
<p>很遗憾，看懂又不懂，总之，轮询操作优化得很高效。</p>
</blockquote>
<h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p><strong>为什么引入安全区域，它解决了什么问题？</strong></p>
<p>安全点机制保证了程序执行时，在不太长的时间内，就会遇到可进入垃圾收集过程的安全点，但是如果程序“不执行”的时候，比如线程处于 Sleep 或者 Blocked 时，就无法通过轮询获知中断标识。对于这种情况，引入了安全区域（Safe Region）来解决。</p>
<p>安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化。安全区域可以看作是扩展拉伸了的安全点。</p>
<ol>
<li>当用户线程执行到安全区域里的代码，首先会标识自己进入了安全区域</li>
<li>虚拟机发起垃圾回收时，不去管这些写线程</li>
<li>当线程要离开安全区域，会检查虚拟机是否已完成根节点枚举（或者其他需要暂定用户线程的阶段），<strong>看起来是否处于用户线程暂停是可以检测的</strong>。</li>
<li>如果已完成，继续；如果未完成，<strong>等待至收到可以离开安全区域的信号</strong></li>
</ol>
<blockquote>
<p>不去管处于安全区域的线程的意思是什么，不是线程主动轮询是否中断的标志吗？这个标志不是全局共享的吗，是虚拟机为各个线程单独设置的？</p>
</blockquote>
<h3 id="记忆集和卡表"><a href="#记忆集和卡表" class="headerlink" title="记忆集和卡表"></a>记忆集和卡表</h3><p><strong>为什么引入记忆集，它解决了什么问题？</strong></p>
<p>为了解决对象跨代引用所带来的问题，比如在标记新生代时，避免将整个老年代的对象都加入 GC Roots 进行扫描。</p>
<blockquote>
<p>这个问题起初让我很迷惑，直到我认识到“老年代里有一些已经不可达但还没回收的对象，它们可能引用了新生代里的对象”这个现象，我在想我可能理解了跨代问题。但是此时，我又迟疑了，如果引用新生代对象的老年代对象已经不可达，回收掉就好了，如果老年代对象可达，那么从固定的 GC Roots 一定可以找到老年代对象，再找到新生代对象。</p>
</blockquote>
<p>记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。<br>如果不考虑效率和成本，最简单的方法可以用非收集区域中所有含跨代引用的对象数组来实现。</p>
<p>设计者通常选择更为粗犷的记录粒度来节省记忆集的存储和维护成本，比如：</p>
<ul>
<li>字长精度：每个记录精确到一个机器字长，该字包含跨代指针。</li>
<li>对象精度：每个记录精确到一个对象，该对象里包含跨代指针。</li>
<li>卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。</li>
</ul>
<p>卡表（Card Table）是记忆集的一种具体实现。<br>卡表最简单的形式可以只是一个字节数组，HotSpot 虚拟机也是这样做的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CARD_TABLE[<span class="built_in">this</span> address &gt;&gt; <span class="number">9</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<img src="/2023/11/07/garbage-collection-in-Java/Pasted%20image%2020231108160535.png" class="" title="卡表与卡页对应示意图">

<p>一个卡页的内存中通常包含不止一个对象，只要卡页内有一个或更多对象的字段存在跨代引用指针，就将卡表的数组元素的值标识为 1，成该元素变脏（Dirty）。</p>
<blockquote>
<p>这是否以为着卡表长度为 (老年代容量 &#x2F; 512)，这内存占用还是不低欸。</p>
</blockquote>
<blockquote>
<p>区域内怎么判断出对象的开始和结束位置呢？虚拟机可以通过一个地址，知道该地址是一个对象的起始地址吗？</p>
</blockquote>
<h3 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h3><p><strong>卡表元素如何维护？它们何时变脏，谁来把它们变脏？</strong></p>
<p>卡表元素何时变脏的答案是明确的——有其他分代区域中对象引用本区域对象时，其对应的卡表元素就应该变脏。</p>
<p><strong>问题是如何在对象赋值的那一刻去更新维护卡表呢？</strong><br>在解释执行字节码的情况中，虚拟机有充分的介入空间；但是在编译执行的场景中，即时编译后的代码已经是纯粹的机器指令流了。<br>HotSpot 虚拟机是通过写屏障（Write Barrier）技术维护卡表状态，在机器码层面介入每一个赋值操作。</p>
<blockquote>
<p>又是一个看懂又不懂的事情，很多资料里尝试用伪代码表达，但是我很想知道它是怎么实现在机器码层面介入每一个赋值操作，是在 JVM 源码中用 C++ 实现的吗？是在解释器和 JIT 编译器共同支持下，在机器码层面加入了代码片段吗？<br>总之，理解为引用字段赋值的 AOP 切面吧。</p>
</blockquote>
<ul>
<li>写前屏障（Pre-Write Barrier），直到 G1 收集器才使用到。</li>
<li>写后屏障（Post-Write Barrier）。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">oop_field_store</span><span class="params">(oop* field, oop new_value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 引用字段赋值操作</span></span><br><span class="line">    *field = new_value;</span><br><span class="line">    <span class="comment">// 写后屏障，在这里完成卡表状态更新</span></span><br><span class="line">    <span class="built_in">post_write_barrier</span>(field, new_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这应该只是为了表达思路的伪代码吧？</p>
</blockquote>
<p>应用写屏障后，每次只要对引用更新，都会产生额外的开销，但是和 Minor GC 时扫描整个老年代的代价相比还是低很多的。</p>
<p><strong>除了写屏障的开销外，卡表在高并发场景下还面临着“伪共享”（False Sharing）问题。</strong></p>
<p>现代中央处理器的缓存系统中是以缓存行（Cache Line）为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影响而导致性能降低。<br>假设 64 个卡表元素共享一个缓存行，对应的卡页总内存为 32 KB，如果不同线程更新的对象都在这 32 KB 的内存区域内，就会导致更新卡表时发生伪共享问题。<br>一种简单的解决方案是不采用无条件的写屏障，而是先检查卡表标记，只有未被标记才标记为变脏。</p>
<p>在 JDK 7 后，新增 -XX:+UseCondCardMark 参数决定是否开启卡表更新的条件判断。开启后增加一次额外的判断开销，但能够避免伪共享问题。</p>
<h3 id="并发的可达性分析"><a href="#并发的可达性分析" class="headerlink" title="并发的可达性分析"></a>并发的可达性分析</h3><p>从 GC Roots 再继续向下遍历对象图，停顿时间必然与堆容量成正比。如果能够削减这部分的停顿时间，对于所有使用追踪式垃圾收集算法的收集器而言，“标记”阶段都能收益匪浅。</p>
<p><strong>为什么必须在一个能保障一致性的快照上才能进行对象图的遍历？</strong><br>三色标记（Tri-color Marking），扫描过程就想灰色波峰从黑向白推进。<br>白色：表示对象尚未被垃圾收集器访问到。<br>黑色：表示对象已经被垃圾收集器访问到，且这个对象的所有引用都已经扫描过了。<br>灰色：表示对象已经被垃圾收集器访问到，但这个对象上至少有一个引用还没有被扫描过。</p>
<p>如果用户线程是冻结的，那么不会有问题。如果用户线程在收集过程中修改了引用关系，就会出现两种后果：</p>
<ul>
<li>把原本消亡的对象，错误标记为存活。（尚可以容忍，只是产生了浮动垃圾，下次收集即可）</li>
<li>把原本存活的对象，错误标记为死亡。这是不允许发生的。</li>
</ul>
<p>Wilson 于 1994 年在理论上证明，当且仅当以下两个条件同时满足，会产生“对象消失”的问题：</p>
<ul>
<li>赋值器插入了一条或多条从黑色对象到白色对象的新引用。</li>
<li>赋值器删除了全部从灰色到<strong>该</strong>白色对象的直接<strong>或间接</strong>引用。</li>
</ul>
<blockquote>
<p>第二个条件的描述需要很精确，不能忽略关键字眼。</p>
</blockquote>
<p>要解决并发扫描时的对象消亡问题，只需要破坏这两个条件的任意一个即可。由此分别产生了两种解决方案：</p>
<ul>
<li>增量更新（Incremental Update），当黑色对象插入新的指向白色对象的引用时，记录，在并发扫描结束后，以这些黑色对象为根，重新扫描。</li>
<li>原始快照（Snapshot At The Beginning，SATB），当灰色对象要删除指向白色对象的引用关系时，记录，在并发扫描结束后，以这些灰色对象为根，重新扫描。</li>
</ul>
<blockquote>
<p>和破坏死锁的思路类似。</p>
</blockquote>
<blockquote>
<p>不太理解“以这些灰色对象为根，重新扫描”，反而是“按照扫描的那一刻的对象图进行扫描”更容易理解。<br>应该是以这些灰色对象为根，根据记录的被删除引用，继续扫描。把继续扫描到的对象，统统视为存活对象。<br>理解起来有点绕，因为第一次扫描是沿着引用链进行，删除引用后，确实没办法继续往下。但是引用关系的变化通过写屏障记录了下来。第二次扫描需要 STW。<br>如果没有理解错的话，这时候会产生一种错误将白标记为黑的浮动垃圾；第一种方案不会出现该情况；但两种方案都不能避免已标记为黑的对象在并发时成为浮动垃圾。</p>
</blockquote>
<blockquote>
<p>理解了这部分，再看垃圾收集器的过程示意图中的停顿和并发，不再枯燥反觉有趣了。</p>
</blockquote>
<blockquote>
<p>其实我不太理解</p>
</blockquote>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li>《深入理解Java虚拟机》</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014028317/article/details/107435049">JVM中的OopMap</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/441867302">图解 OopMap、Safe Point、Safe Region</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/377672271">详解GC（一）理论篇</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.moralok.com/2023/11/04/testing-and-analysis-of-jvm-memory-area/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Moralok">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Moralok">
      <meta itemprop="description" content="假如生命只剩一天">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Moralok">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/04/testing-and-analysis-of-jvm-memory-area/" class="post-title-link" itemprop="url">JVM 内存区域的测试和分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-04 19:21:25" itemprop="dateCreated datePublished" datetime="2023-11-04T19:21:25+08:00">2023-11-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-01-25 19:49:56" itemprop="dateModified" datetime="2024-01-25T19:49:56+08:00">2024-01-25</time>
    </span>

  
    <span id="/2023/11/04/testing-and-analysis-of-jvm-memory-area/" class="post-meta-item leancloud_visitors" data-flag-title="JVM 内存区域的测试和分析" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h2><p>JVM 内存区域划分为：</p>
<ul>
<li>程序计数器</li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
<li>堆</li>
<li>方法区</li>
</ul>
<img src="/2023/11/04/testing-and-analysis-of-jvm-memory-area/Pasted%20image%2020231102215652.png" class="" title="内存区域划分">

<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>Java 虚拟机栈（Java Virtual Machine Stack），线程私有，生命周期与线程相同。虚拟机栈描述的是 Java 方法执行的线程内存模型。每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。</p>
<p>可以使用 <code>-Xss1024k</code> 设置虚拟机栈的大小。默认情况下都是 1024k，只有 Windows 中取决于虚拟内存。</p>
<h3 id="栈内存溢出"><a href="#栈内存溢出" class="headerlink" title="栈内存溢出"></a>栈内存溢出</h3><ol>
<li>栈帧过多导致栈内存溢出</li>
<li>栈帧过大导致栈内存溢出（难复现）</li>
</ol>
<h4 id="不正确的递归调用"><a href="#不正确的递归调用" class="headerlink" title="不正确的递归调用"></a>不正确的递归调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackTest_4</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变栈的大小限制 -Xss256k，观察调用次数的变化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            method1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 默认情况下经过 20000+ 次，改变参数后 3000+ 次</span></span><br><span class="line">            System.out.println(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">        method1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="循环引用导致-JSON-解析无限循环"><a href="#循环引用导致-JSON-解析无限循环" class="headerlink" title="循环引用导致 JSON 解析无限循环"></a>循环引用导致 JSON 解析无限循环</h4><p>并非只有自己写的递归方法可能引发栈内存溢出，有可能第三方库也会引发栈内存溢出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackTest_5</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">        <span class="type">Department</span> <span class="variable">department</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Department</span>();</span><br><span class="line">        department.setName(<span class="string">&quot;Tech&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">employee1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">        employee1.setName(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        employee1.setDepartment(department);</span><br><span class="line"></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">employee2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">        employee2.setName(<span class="string">&quot;Tim&quot;</span>);</span><br><span class="line">        employee2.setDepartment(department);</span><br><span class="line"></span><br><span class="line">        department.setEmployees(Arrays.asList(employee1, employee2));</span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        System.out.println(objectMapper.writeValueAsString(department));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Department</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> List&lt;Employee&gt; employees;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> List&lt;Employee&gt; <span class="title function_">getEmployees</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> employees;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmployees</span><span class="params">(List&lt;Employee&gt; employees)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.employees = employees;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> Department department;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Department <span class="title function_">getDepartment</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> department;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDepartment</span><span class="params">(Department department)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.department = department;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="局部变量的线程安全问题"><a href="#局部变量的线程安全问题" class="headerlink" title="局部变量的线程安全问题"></a>局部变量的线程安全问题</h3><ol>
<li>局部变量如果未逃离方法的作用范围，就是线程安全的。</li>
<li>局部变量如果是引用类型且逃离了方法的作用范围，就是线程不安全的。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackTest_3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        method1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(<span class="number">1</span>);</span><br><span class="line">        sb.append(<span class="number">2</span>);</span><br><span class="line">        sb.append(<span class="number">3</span>);</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程不安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(StringBuilder sb)</span> &#123;</span><br><span class="line">        sb.append(<span class="number">1</span>);</span><br><span class="line">        sb.append(<span class="number">2</span>);</span><br><span class="line">        sb.append(<span class="number">3</span>);</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程不安全，看到一个说法：发生指令重排，sb 的 append 操作发生在返回之后（有待确认）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> StringBuilder <span class="title function_">method3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(<span class="number">1</span>);</span><br><span class="line">        sb.append(<span class="number">2</span>);</span><br><span class="line">        sb.append(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程问题排查"><a href="#线程问题排查" class="headerlink" title="线程问题排查"></a>线程问题排查</h3><h4 id="CPU-占用率居高不下"><a href="#CPU-占用率居高不下" class="headerlink" title="CPU 占用率居高不下"></a>CPU 占用率居高不下</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest_1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="literal">null</span>, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t1...&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="literal">null</span>, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t2...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="literal">null</span>, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t3...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread3&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当发现 CPU 占用率居高不下时，可以尝试以下步骤：</p>
<ol>
<li><code>top</code>，定位 cpu 占用高的进程 id。</li>
<li><code>ps H -eo pid,tid,%cpu | grep pid</code>，进一步定位引起 cpu 占用高的线程 id。</li>
<li><code>jstack pid</code>，根据线程 id 换算成 16进制的 nid 找到对应线程，进一步定位到问题的源码行号。</li>
</ol>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;thread1&quot; #8 prio=5 os_prio=0 tid=0x00007f9bd0162800 nid=0x1061ad runnable [0x00007f9bd56eb000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">	at com.moralok.jvm.thread.ThreadTest_1.lambda$main$0(ThreadTest_1.java:10)</span><br><span class="line">	at com.moralok.jvm.thread.ThreadTest_1$$Lambda$1/250421012.run(Unknown Source)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:750)</span><br></pre></td></tr></table></figure>

<h4 id="死锁，迟迟未返回结果"><a href="#死锁，迟迟未返回结果" class="headerlink" title="死锁，迟迟未返回结果"></a>死锁，迟迟未返回结果</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest_2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">A</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">B</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="literal">null</span>, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t1...&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; get A&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; get B&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="literal">null</span>, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t2...&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; get B&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; get A&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>jstack pid</code>，会显示找到死锁，以及死锁涉及的线程,，并各自持有的锁还有等待的锁。</li>
<li>其他工具如 jconsole 也具有检测死锁的功能。</li>
</ol>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆（Heap）的特点：</p>
<ol>
<li>线程共享，需要考虑线程安全问题。</li>
<li>存在垃圾回收机制。</li>
<li>使用 -Xmx8m 设置大小。</li>
</ol>
<h3 id="堆内存溢出"><a href="#堆内存溢出" class="headerlink" title="堆内存溢出"></a>堆内存溢出</h3><p>既然堆有垃圾回收机制，为什么还会发生内存溢出呢？最开始的时候，我也有这样的困惑。<br>后来我才认识到，还在使用中的对象是不能被强制回收的，不再使用的对象不是立刻回收的。当创建对象却没有足够的内存空间时，如果清理掉那些不再使用的对象就有足够的内存空间，就不会发生内存溢出，程序只是表现为卡顿。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapTest_1</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// -Xmx8m  </span></span><br><span class="line">    <span class="comment">// 不设置可能不提示 Java heap space，出错地方不同，报错信息不同  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;  </span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;  </span><br><span class="line">                list.add(s);  </span><br><span class="line">                s = s + s;  </span><br><span class="line">                i++;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;  </span><br><span class="line">            t.printStackTrace();  </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;运行次数 &quot;</span> + i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at java.util.Arrays.copyOf(Arrays.java:3332)</span><br><span class="line">	at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:124)</span><br><span class="line">	at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:448)</span><br><span class="line">	at java.lang.StringBuilder.append(StringBuilder.java:141)</span><br><span class="line">	at com.moralok.jvm.memory.heap.HeapTest_1.main(HeapTest_1.java:21)</span><br><span class="line">运行次数 17</span><br></pre></td></tr></table></figure>

<p>堆内存溢出的发生往往需要长时间的运行，因此在排查相关问题时，可以适当调小堆内存。</p>
<h3 id="监测堆内存"><a href="#监测堆内存" class="headerlink" title="监测堆内存"></a>监测堆内存</h3><ol>
<li>使用 jps 查看 Java 进程列表</li>
<li>使用 <code>jmap -heap pid</code> 查看堆内存信息</li>
<li>还可以使用 jconsole 观察堆内存变化曲线</li>
<li>还可以使用 VisualVM 查看堆信息</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapTest_2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1...&quot;</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">30</span>);</span><br><span class="line">        <span class="comment">// 堆空间占用上升 10MB</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>];</span><br><span class="line">        System.out.println(<span class="string">&quot;2...&quot;</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">30</span>);</span><br><span class="line">        bytes = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 堆空间占用下降</span></span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">&quot;3...&quot;</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>jmap -heap pid</code> 查看堆内存信息：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Eden Space:</span><br><span class="line">   capacity = 268435456 (256.0MB)</span><br><span class="line">   used     = 32212360 (30.72010040283203MB)</span><br><span class="line"></span><br><span class="line">   used     = 42698136 (40.720115661621094MB)</span><br><span class="line"></span><br><span class="line">   used     = 5368728 (5.120018005371094MB)</span><br></pre></td></tr></table></figure>

<p>使用 jconsole 查看堆内存信息：</p>
<img src="/2023/11/04/testing-and-analysis-of-jvm-memory-area/Pasted%20image%2020231104200411.png" class="" title="jconsole 观察堆内存占用">

<h3 id="堆内存占用居高不下"><a href="#堆内存占用居高不下" class="headerlink" title="堆内存占用居高不下"></a>堆内存占用居高不下</h3><p>当你发现堆内存占用居高不下，经过 GC，下降也不明显，如果你想查看一下堆内的具体情况，可以将其 dump 查看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapTest_3</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// jps 查进程，jmap 看堆内存，jconsole 执行GC，堆内存占用没有明显下降  </span></span><br><span class="line">    <span class="comment">// 使用 VisualVM 的堆 dump 功能，观察大对象  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">        List&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;  </span><br><span class="line">            students.add(<span class="keyword">new</span> <span class="title class_">Student</span>());  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.in.read();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="type">byte</span>[] score = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可使用 VisualVM 的 Heap Dump 功能：</p>
<img src="/2023/11/04/testing-and-analysis-of-jvm-memory-area/Pasted%20image%2020231104201139.png" class="" title="VisualVM 观察堆中的大对象">

<p>也可使用 <code>jmap -dump:format=b,file=filename.hprof pid</code>，需要其他分析工具搭配。</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>根据《Java虚拟机规范》，方法区在逻辑上是堆的一部分，但是在具体实现上，各个虚拟机厂商并不相同。对于 Hotspot 而言：</p>
<ul>
<li>JDK 8 之前，方法区的具体实现为永久代，使用堆内存，使用 -XX:MaxPermSize&#x3D;10m 设置大小。</li>
<li>JDK 8 开始，方法区的具体实现为元空间，使用直接内存，使用 -XX:MaxMetaspaceSize&#x3D;10m 设置大小。</li>
</ul>
<h3 id="方法区溢出"><a href="#方法区溢出" class="headerlink" title="方法区溢出"></a>方法区溢出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAreaTest_1</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -XX:MaxMetaspaceSize=8m MaxMetaspaceSize is too small.</span></span><br><span class="line">    <span class="comment">// -XX:MaxMetaspaceSize=10m java.lang.OutOfMemoryError: Compressed class space</span></span><br><span class="line">    <span class="comment">// 不是 Metaspace 应该是某个参数设置的问题</span></span><br><span class="line">    <span class="comment">// JDK 6: -XX:MaxPermSize=8m PermGen space</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">MethodAreaTest_1</span> <span class="variable">methodAreaTest1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodAreaTest_1</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++, j++) &#123;</span><br><span class="line">                <span class="type">ClassWriter</span> <span class="variable">classWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">// 版本号，public，类名，包名，父类，接口</span></span><br><span class="line">                classWriter.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, <span class="string">&quot;Class&quot;</span> + i, <span class="literal">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">                <span class="comment">// 返回二进制字节码</span></span><br><span class="line">                <span class="type">byte</span>[] code = classWriter.toByteArray();</span><br><span class="line">                <span class="comment">// 加载类</span></span><br><span class="line">                methodAreaTest1.defineClass(<span class="string">&quot;Class&quot;</span> + i, code, <span class="number">0</span>, code.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;次数 &quot;</span> + j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>当设置的值太小时 -XX:MaxMetaspaceSize&#x3D;8m，提示 MaxMetaspaceSize is too small。</li>
<li>实验中抛出 java.lang.OutOfMemoryError: Compressed class space。</li>
<li>添加参数 -XX:-UseCompressedClassPointers 后，抛出 java.lang.OutOfMemoryError: Metaspace。</li>
<li>JDK 6 设置 -XX:MaxPermSize&#x3D;8m，抛出 java.lang.OutOfMemoryError: PermGen space。</li>
</ol>
<p>不要认为自己不会写动态生成字节码相关的代码就忽略这方面的问题，如今很多框架使用字节码技术大量地动态生成类。</p>
<h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>二进制字节码文件主要包含三类信息：</p>
<ol>
<li>类的基本信息</li>
<li>类的常量池（Constant Pool）</li>
<li>类的方法信息</li>
</ol>
<h3 id="使用-javap-反编译"><a href="#使用-javap-反编译" class="headerlink" title="使用 javap 反编译"></a>使用 javap 反编译</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAreaTest_2</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">Classfile /C:/Users/username/Documents/github/jvm-study/target/classes/com/moralok/jvm/memory/methodarea/MethodAreaTest_2.class</span><br><span class="line">  Last modified 2023-11-4; size 619 bytes</span><br><span class="line">  MD5 checksum 0ed10a8f0a03be54fd4159958ee7446c</span><br><span class="line">  Compiled from &quot;MethodAreaTest_2.java&quot;</span><br><span class="line">public class com.moralok.jvm.memory.methodarea.MethodAreaTest_2</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">1 = Methodref          <span class="comment">#6.#20         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">2 = Fieldref           <span class="comment">#21.#22        // java/lang/System.out:Ljava/io/PrintStream;</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">3 = String             <span class="comment">#23            // hello world</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">4 = Methodref          <span class="comment">#24.#25        // java/io/PrintStream.println:(Ljava/lang/String;)V</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">5 = Class              <span class="comment">#26            // com/moralok/jvm/memory/methodarea/MethodAreaTest_2</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">6 = Class              <span class="comment">#27            // java/lang/Object</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">7 = Utf8               &lt;init&gt;</span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">8 = Utf8               ()V</span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">9 = Utf8               Code</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">10 = Utf8               LineNumberTable</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">11 = Utf8               LocalVariableTable</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">12 = Utf8               this</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">13 = Utf8               Lcom/moralok/jvm/memory/methodarea/MethodAreaTest_2;</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">14 = Utf8               main</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">15 = Utf8               ([Ljava/lang/String;)V</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">16 = Utf8               args</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">17 = Utf8               [Ljava/lang/String;</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">18 = Utf8               SourceFile</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">19 = Utf8               MethodAreaTest_2.java</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">20 = NameAndType        <span class="comment">#7:#8          // &quot;&lt;init&gt;&quot;:()V</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">21 = Class              <span class="comment">#28            // java/lang/System</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">22 = NameAndType        <span class="comment">#29:#30        // out:Ljava/io/PrintStream;</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">23 = Utf8               hello world</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">24 = Class              <span class="comment">#31            // java/io/PrintStream</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">25 = NameAndType        <span class="comment">#32:#33        // println:(Ljava/lang/String;)V</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">26 = Utf8               com/moralok/jvm/memory/methodarea/MethodAreaTest_2</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">27 = Utf8               java/lang/Object</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">28 = Utf8               java/lang/System</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">29 = Utf8               out</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">30 = Utf8               Ljava/io/PrintStream;</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">31 = Utf8               java/io/PrintStream</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">32 = Utf8               println</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">33 = Utf8               (Ljava/lang/String;)V</span></span><br><span class="line">&#123;</span><br><span class="line">  public com.moralok.jvm.memory.methodarea.MethodAreaTest_2();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom/moralok/jvm/memory/methodarea/MethodAreaTest_2;</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #3                  // String hello world</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 6: 0</span><br><span class="line">        line 7: 8</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       9     0  args   [Ljava/lang/String;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;MethodAreaTest_2.java&quot;</span><br></pre></td></tr></table></figure>

<ol>
<li>Class 文件的常量池就是一张表，虚拟机根据索引去查找类名、字段名及其类型，方法名及其参数类型和字面量等。</li>
<li>当类被加载到虚拟机之后，Class 文件中的常量池中的信息就进入到了运行时常量池。</li>
<li>这个过程其实就是信息从文件进入了内存。</li>
</ol>
<p>虚拟机解释器（interpreter）需要解释的字节码指令如下：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0: getstatic     #2</span><br><span class="line">3: ldc           #3</span><br><span class="line">5: invokevirtual #4</span><br></pre></td></tr></table></figure>
<p>索引 <code>#2</code> 的意思就是去常量表里查找对应项代表的事物。</p>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><ul>
<li>常见于 NIO 操作中的数据缓冲区。</li>
<li>分配和回收的成本较高，但读写性能更高。</li>
<li>不由 JVM 进行内存释放</li>
</ul>
<h3 id="NIO-和-IO-的拷贝性能"><a href="#NIO-和-IO-的拷贝性能" class="headerlink" title="NIO 和 IO 的拷贝性能"></a>NIO 和 IO 的拷贝性能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectMemoryTest_1</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FROM</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\username\\Videos\\jellyfin\\media\\movies\\Harry Potter and the Chamber of Secrets (2002) [1080p]\\Harry.Potter.and.the.Chamber.of.Secrets.2002.1080p.BrRip.x264.YIFY.mp4&quot;</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TO</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\username\\Videos\\jellyfin\\media\\movies\\Harry Potter and the Chamber of Secrets (2002) [1080p]\\Harry.Potter.and.the.Chamber.of.Secrets.2002.1080p.BrRip.x264.YIFY-copy.mp4&quot;</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1Mb</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        io();  </span><br><span class="line">        directBuffer();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">directBuffer</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();  </span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileChannel</span> <span class="variable">from</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(FROM).getChannel();  </span><br><span class="line">             <span class="type">FileChannel</span> <span class="variable">to</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(TO).getChannel()) &#123;  </span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(_1Mb);  </span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;  </span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> from.read(buffer);  </span><br><span class="line">                <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;  </span><br><span class="line">                    <span class="keyword">break</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">                buffer.flip();  </span><br><span class="line">                to.write(buffer);  </span><br><span class="line">                buffer.clear();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();  </span><br><span class="line">        System.out.println(<span class="string">&quot;directBuffer 用时 &quot;</span> + (end - start) / <span class="number">1000_000.0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">io</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();  </span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">from</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(FROM);  </span><br><span class="line">             <span class="type">FileOutputStream</span> <span class="variable">to</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(TO)) &#123;  </span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[_1Mb];  </span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;  </span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> from.read(buffer);  </span><br><span class="line">                <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;  </span><br><span class="line">                    <span class="keyword">break</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">                to.write(buffer);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();  </span><br><span class="line">        System.out.println(<span class="string">&quot;io 用时 &quot;</span> + (end - start) / <span class="number">1000_000.0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">io 用时 1676.9797</span><br><span class="line">directBuffer 用时 836.4796</span><br></pre></td></tr></table></figure>

<img src="/2023/11/04/testing-and-analysis-of-jvm-memory-area/Pasted%20image%2020231104235546.png" class="" title="普通的 IO 拷贝">

<img src="/2023/11/04/testing-and-analysis-of-jvm-memory-area/Pasted%20image%2020231104235846.png" class="" title="NIO 拷贝">


<h3 id="直接内存溢出"><a href="#直接内存溢出" class="headerlink" title="直接内存溢出"></a>直接内存溢出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectMemoryTest_2</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_100Mb</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        List&lt;ByteBuffer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;  </span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(_100Mb);  </span><br><span class="line">                list.add(byteBuffer);  </span><br><span class="line">                i++;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;  </span><br><span class="line">            t.printStackTrace();  </span><br><span class="line">        &#125; System.out.println(i);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Direct buffer memory</span><br><span class="line">	at java.nio.Bits.reserveMemory(Bits.java:695)</span><br><span class="line">	at java.nio.DirectByteBuffer.&lt;init&gt;(DirectByteBuffer.java:123)</span><br><span class="line">	at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:311)</span><br><span class="line">	at com.moralok.jvm.memory.direct.DirectMemoryTest_2.main(DirectMemoryTest_2.java:16)</span><br><span class="line">145</span><br></pre></td></tr></table></figure>

<p>这似乎是代码中抛出的异常，而不是真正的直接内存溢出？</p>
<h3 id="直接内存释放的原理"><a href="#直接内存释放的原理" class="headerlink" title="直接内存释放的原理"></a>直接内存释放的原理</h3><h4 id="演示直接内存的释放受-GC-影响"><a href="#演示直接内存的释放受-GC-影响" class="headerlink" title="演示直接内存的释放受 GC 影响"></a>演示直接内存的释放受 GC 影响</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectMemoryTest_3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1GB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(_1GB);</span><br><span class="line">        System.out.println(<span class="string">&quot;分配完毕&quot;</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line">        System.out.println(<span class="string">&quot;开始释放&quot;</span>);</span><br><span class="line">        byteBuffer = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 随着 ByteBuffer 的释放，从任务管理器界面看到程序的内存的占用迅速下降 1GB。</span></span><br><span class="line">        System.gc();</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="手动进行直接内存的分配和释放"><a href="#手动进行直接内存的分配和释放" class="headerlink" title="手动进行直接内存的分配和释放"></a>手动进行直接内存的分配和释放</h4><p>在代码中实现手动进行直接内存的分配和释放。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectMemoryTest_4</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1GB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> getUnsafe();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分配内存</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> unsafe.allocateMemory(_1GB);</span><br><span class="line">        unsafe.setMemory(base, _1GB, (<span class="type">byte</span>) <span class="number">0</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放内存</span></span><br><span class="line">        unsafe.freeMemory(base);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) f.get(<span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span> unsafe;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="如何将-GC-和直接内存的分配和释放关联"><a href="#如何将-GC-和直接内存的分配和释放关联" class="headerlink" title="如何将 GC 和直接内存的分配和释放关联"></a>如何将 GC 和直接内存的分配和释放关联</h4><p>本质上，直接内存的自动释放是利用了虚引用的机制，间接调用了 unsafe 的分配和释放直接内存的方法。</p>
<p>DirectByteBuffer 就是使用 unsafe.allocateMemory(size) 分配直接内存。DirectByteBuffer 对象以及一个 Deallocator 对象（Runnable 类型）一起用于创建了一个虚引用类型的 Cleaner 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DirectByteBuffer(<span class="type">int</span> cap) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        base = unsafe.allocateMemory(size);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">    cleaner = Cleaner.create(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">Deallocator</span>(base, size, cap));</span><br><span class="line">    att = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据虚引用的机制，如果 DirectByteBuffer 对象被回收，虚引用对象会被加入到 Cleanner 的引用队列，ReferenceHandler 线程会处理引用队列中的 Cleaner 对象，进而调用 Deallocator 对象的 run 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (address == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Paranoia</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.freeMemory(address);</span><br><span class="line">    address = <span class="number">0</span>;</span><br><span class="line">    Bits.unreserveMemory(size, capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.moralok.com/2023/11/03/testing-and-analysis-of-StringTable/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Moralok">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Moralok">
      <meta itemprop="description" content="假如生命只剩一天">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Moralok">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/03/testing-and-analysis-of-StringTable/" class="post-title-link" itemprop="url">字符串常量池的测试和分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-03 15:57:47" itemprop="dateCreated datePublished" datetime="2023-11-03T15:57:47+08:00">2023-11-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-01-25 19:49:56" itemprop="dateModified" datetime="2024-01-25T19:49:56+08:00">2024-01-25</time>
    </span>

  
    <span id="/2023/11/03/testing-and-analysis-of-StringTable/" class="post-meta-item leancloud_visitors" data-flag-title="字符串常量池的测试和分析" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>如果你准备过 Java 的面试，应该看到过一个问题：“<code>String s1 = new String(&quot;abc&quot;);</code> 这个语句创建了几个字符串对象”。这个问题曾经困扰我，当时的我不能理解这个问题想要考察的是什么？<br>答案中或许提及了字符串常量池，但是如果细究起来，会发现答案并不完善，有些令人困惑，甚至问题本身就有一定的误导作用。它很容易让初学者以为创建一个字符串对象和创建一个其他类型的对象在过程上是有一些区别的。<br>其实关键的地方在于 “abc” 而不是 <code>new String(&quot;abc&quot;)</code>。</p>
<h2 id="字符串常量池的作用"><a href="#字符串常量池的作用" class="headerlink" title="字符串常量池的作用"></a>字符串常量池的作用</h2><h3 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h3><p>字面量(literal)是用于表达源代码中的一个固定值的表示法(notion)，比如代码中的整数、浮点数、字符串。简而言之，字符串字面量就是双引号包裹的字符串，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>在 Java 中，字符串对象就是一个 String 类型的对象，因此在程序运行时，String 类型的变量 s1 指向的一定是一个 String 对象。<strong>字面量 “a” 在某一个时刻，没有经过 new 关键字，变成了一个 String 对象</strong>。</p>
<p>接下来我们来思考一个问题，程序中每一个字符串字面量都要对应着生成一个单独的 String 对象吗？考虑到 Java 中 String 对象是不可变的，显然相同的字符串字面量完全可以共用一个 String 对象从而避免重复创建对象。JVM 也是这样设计的，这些可以共用的 String 对象组成了一个字符串常量池。</p>
<ol>
<li>第一次遇到某一个字符串字面量时，会在字符串常量池中创建一个 String 对象，以后遇到相同的字符串字面量，就复用该对象，不再重复创建。</li>
<li>每一次 new 都会创建一个新的 String 对象。</li>
</ol>
<p>ps: 以上的“遇到某一个字符串字面量”就是很纯粹地指代程序的源代码中出现用双引号括起来的字符串字面量。</p>
<h3 id="进入字符串常量池的两种情况"><a href="#进入字符串常量池的两种情况" class="headerlink" title="进入字符串常量池的两种情况"></a>进入字符串常量池的两种情况</h3><p>因此，<strong>如果字符串常量池中没有值为 “abc” 的 String 对象</strong>，<code>new String(&quot;abc&quot;)</code> 语句将涉及两个 String 对象的创建，第一个是因为括号里的 “abc” 而在字符串常量池中生成的，第二个才是 new 关键字在堆中创建的；否则只会涉及一个 String 对象的创建。<br>为什么上面改用<strong>如果字符串常量池中没有值为 “abc” 的 String 对象</strong>呢？这是因为，字符串常量池里保留的 String 对象有两种产生来源：</p>
<ol>
<li>因为第一次遇到字符串字面量而生成的字符串对象。</li>
<li>使用 <code>java.lang.String#intern</code> 主动地尝试将字符串对象放入字符串常量池。</li>
</ol>
<h2 id="常量池的分类"><a href="#常量池的分类" class="headerlink" title="常量池的分类"></a>常量池的分类</h2><ol>
<li>Class 文件中的常量池(Constant Pool)</li>
<li>运行时常量池(Runtime Constant Pool)</li>
<li>字符串常量池</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableTest_1</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>javap -v .\StringTableTest_1.class</code> 进行反编译，摘取重要部分：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">1 = Methodref          <span class="comment">#6.#24         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">2 = String             <span class="comment">#25            // a</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">3 = String             <span class="comment">#26            // b</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">4 = String             <span class="comment">#27            // ab</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">25 = Utf8               a</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">26 = Utf8               b</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">27 = Utf8               ab</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0: ldc           #2                  // String a</span><br><span class="line">2: astore_1</span><br><span class="line">3: ldc           #3                  // String b</span><br><span class="line">5: astore_2</span><br><span class="line">6: ldc           #4                  // String ab</span><br><span class="line">8: astore_3</span><br><span class="line">9: return</span><br></pre></td></tr></table></figure>
<ul>
<li>Class 文件中的常量池 Constant pool 会记录代码中出现的字面量（文本文件）。</li>
<li>运行时常量池是方法区的一部分，Class 文件中的常量池的内容，在类加载后，就进入了运行时常量池中（内存中的数据）。</li>
<li>字符串常量池，记录 interned string 的一个全局表，JDK 6 前在方法区，后移到堆中。</li>
</ul>
<h2 id="字符串常量池的位置和形式"><a href="#字符串常量池的位置和形式" class="headerlink" title="字符串常量池的位置和形式"></a>字符串常量池的位置和形式</h2><p>在《深入理解Java虚拟机》提到：字符串常量池的位置从 JDK 7 开始，从永久代中移到了堆中。在这句话中，字符串常量池像是一个特定的内存区域，存储了 interned string 的实例。</p>
<img src="/2023/11/03/testing-and-analysis-of-StringTable/Pasted%20image%2020231103113047.png" class="" title="字符串常量池的位置">

<h3 id="验证字符串常量池的位置"><a href="#验证字符串常量池的位置" class="headerlink" title="验证字符串常量池的位置"></a>验证字符串常量池的位置</h3><p>书中使用了以下方式来验证字符串常量池的位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableTest_8</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// JDK 1.8 设置 -Xmx10m -XX:-UseGCOverheadLimit    </span></span><br><span class="line">    <span class="comment">// JDK 1.6 设置 -XX:MaxPerSize=10m</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">260000</span>; j++) &#123;  </span><br><span class="line">                list.add(String.valueOf(j).intern());  </span><br><span class="line">                i++;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">            System.out.println(i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 JDK 8 中异常如下：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure>
<p>在 JDK 6 中异常如下：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: PermGen space</span><br></pre></td></tr></table></figure>

<p>同时书中也提到了，在字符串常量池的位置改变后，它只用保存第一次出现时字符串对象的引用。JDK 8 中的 intern 方法可以印证该说法，方法注释中提到：如果字符串常量池中已存在相等(equals)的字符串，那就返回已存在的对象（这样原先准备加入的对象就可以释放）；否则，将字符串对象加入字符串常量池中，直接返回对该对象的引用（不用像 JDK 6 时，复制一个对象加入常量池，返回该复制对象的引用）。</p>
<h3 id="关于-intern-的实验"><a href="#关于-intern-的实验" class="headerlink" title="关于 intern 的实验"></a>关于 intern 的实验</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableTest_5</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="comment">// &quot;a&quot;、&quot;b&quot; 作为字符串字面量，会解析得到字符串对象放入字符串常量池      </span></span><br><span class="line">        <span class="comment">// 但是 new String(&quot;a&quot;) 创建出来的字符串对象，不会进入字符串常量池        </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);  </span><br><span class="line">        <span class="comment">// intern 方法尝试将 s1 放入 StringTable，无则放入，返回该对象引用，有则返回已存在对象的引用  </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.intern();  </span><br><span class="line">  </span><br><span class="line">        <span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;  </span><br><span class="line">  </span><br><span class="line">		System.out.println(s2 == x);  </span><br><span class="line">		System.out.println(s1 == x); </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableTest_6</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="comment">// 将 &quot;ab&quot; 的赋值语句提前到最开始，&quot;ab&quot; 生成的字符串对象进入字符串常量池       </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);  </span><br><span class="line">        <span class="comment">// intern 方法尝试将 s1 放入 StringTable，无则放入，返回该对象引用，有则返回已存在对象的引用  </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.intern();  </span><br><span class="line">  </span><br><span class="line">        System.out.println(s2 == x);  </span><br><span class="line">        System.out.println(s1 == x);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实验结果证实了上述说法。</p>
<h3 id="字符串常量池到底是什么？"><a href="#字符串常量池到底是什么？" class="headerlink" title="字符串常量池到底是什么？"></a>字符串常量池到底是什么？</h3><p>但是 <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/logirl.cc">xinxi</a> 提及：字符串常量池，也称为 StringTable，本质上是一个惰性维护的哈希表，是一个纯运行时的结构，只存储对 <code>java.lang.String</code> 实例的引用，而不存储 String 对象的内容。当我们提到一个字符串进入字符串常量池其实是说在这个 StringTable 中保存了对它的引用，反之，如果说没有在其中就是说 StringTable 中没有对它的引用。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/zyplanke">zyplanke</a> 分析 StringTable 在内存中的形式时，也表达了类似的观点。</p>
<img src="/2023/11/03/testing-and-analysis-of-StringTable/Pasted%20image%2020231103194544.png" class="" title="StringTable 的内存形式">

<p>尽管这个疑问似乎不妨碍我们理解很多东西，但是深究之后，真的让人困惑，网上也没有搜集到更多的信息。字符串常量池和 StringTable 是否等价？字符串常量池更准确的说法是否是“一个保存引用的 StringTable 加上分布在堆（JDK 6 以前的永久代）中的字符串实例”？<br>已经好几次打开 jvm 的源码，却看不懂它到底什么意思啊！！！！！难道是时候开始学 C++ 了吗。</p>
<h2 id="进入字符串常量池的时机"><a href="#进入字符串常量池的时机" class="headerlink" title="进入字符串常量池的时机"></a>进入字符串常量池的时机</h2><p>前面提到了第一次遇到的字符串字面量会在某一个时刻，生成对应的字符串对象进入字符串常量池，同时也提到了，字符串常量池（StringTable）的维护是懒惰的，那么这些究竟是什么时候发生的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableTest_12</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> 0: new           #2                  // class java/lang/String</span><br><span class="line"> 3: dup</span><br><span class="line"> 4: ldc           #3                  // String ab</span><br><span class="line"> 6: invokespecial #4                  // Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br><span class="line"> 9: pop</span><br><span class="line">10: return</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/people/rednaxelafx">RednaxelaFX</a> 的文章提到：</p>
<blockquote>
<p>在类加载阶段，JVM 会在堆中创建对应这些 class 文件常量池中的字符串对象实例，并在字符串常量池中驻留其引用。具体在 resolve 阶段执行。这些常量全局共享。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/people/logirl.cc">xinxi</a> 的文章中补充到：</p>
<blockquote>
<p>这里说的比较笼统，没错，是 resolve 阶段，但是并不是大家想的那样，立即就创建对象并且在字符串常量池中驻留了引用。 <strong>JVM规范里明确指定resolve阶段可以是lazy的。</strong><br>……<br>就 HotSpot VM 的实现来说，加载类的时候，那些字符串字面量会进入到当前类的运行时常量池，不会进入全局的字符串常量池（即在 StringTable 中并没有相应的引用，在堆中也没有对应的对象产生）。</p>
</blockquote>
<p>《深入理解Java虚拟机》中提到：</p>
<blockquote>
<p>《Java虚拟机规范》之中并未规定解析阶段发生的具体时间，只要求了在执行ane-warray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invoke-special、invokestatic、invokevirtual、ldc、ldc_w、ldc2_w、multianewarray、new、putfield和putstatic这17个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。所以虚拟机实现可以根据需要来自行判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。</p>
</blockquote>
<p>综上可知，字符串字面量的解析是属于类加载的解析阶段，但是《Java虚拟机规范》并未规定解析发生的具体时间，只要求在执行一些字节码指令前进行，其中包括了 ldc 指令。虚拟机的具体实现，比如 Hotspot 就在执行 <code>ldc #indexNumber</code> 前触发解析，根据字符串常量池中是否已存在字符串对象决定是否创建对象，并将对象推送到栈顶。<br>这也证实了前文中提到的字符串字面量生成字符串对象和 new 关键字无关。</p>
<h3 id="验证延迟实例化"><a href="#验证延迟实例化" class="headerlink" title="验证延迟实例化"></a>验证延迟实例化</h3><p>使用 IDEA memory 功能，观察字符串对象的个数逐个变化。</p>
<ol>
<li>直到第一次运行到字符串字面量时，才会创建对应的字符串对象。</li>
<li>相同的字符串常量，不会重复创建字符串对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableTest_4</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        System.out.println();  </span><br><span class="line">         </span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;4&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;5&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;6&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;7&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;8&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;9&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;0&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;4&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;5&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;6&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;7&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;8&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;9&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;0&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2023/11/03/testing-and-analysis-of-StringTable/Pasted%20image%2020231102225445.png" class="" title="字符串字面量延迟实例化">

<h2 id="字符串常量池的垃圾回收和性能优化"><a href="#字符串常量池的垃圾回收和性能优化" class="headerlink" title="字符串常量池的垃圾回收和性能优化"></a>字符串常量池的垃圾回收和性能优化</h2><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>前文提到字符串常量池在 JDK 7 开始移到堆中，是因为考虑在方法区中的垃圾回收是比较困难的，同时随着字节码技术的发展，CGLib 等会大量动态生成类的技术的运用使得方法区的内存紧张，将字符串常量池移到堆中，可以有效提高其垃圾回收效率。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableTest_9</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// -Xmx10m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails -verbose:gc  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="comment">// 0-&gt;100-&gt;10000，观察统计信息中数量的变化以及垃圾回收记录</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;  </span><br><span class="line">                String.valueOf(j).intern();  </span><br><span class="line">                i++;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">            System.out.println(i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 2048K-&gt;488K(2560K)] 2048K-&gt;856K(9728K), 0.0007745 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">StringTable statistics:</span><br><span class="line">Number of buckets       :     60013 =    480104 bytes, avg   8.000</span><br><span class="line">Number of entries       :      7277 =    174648 bytes, avg  24.000</span><br><span class="line">Number of literals      :      7277 =    421560 bytes, avg  57.930</span><br><span class="line">Total footprint         :           =   1076312 bytes</span><br><span class="line">Average bucket size     :     0.121</span><br><span class="line">Variance of bucket size :     0.125</span><br><span class="line">Std. dev. of bucket size:     0.354</span><br><span class="line">Maximum bucket size     :         3</span><br></pre></td></tr></table></figure>

<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><h4 id="调整-buckets-size"><a href="#调整-buckets-size" class="headerlink" title="调整 buckets size"></a>调整 buckets size</h4><p>当 size 过小，哈希碰撞增加，链表变长，效率会变低，需要增大 buckets size。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableTest_10</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// -XX:StringTableSize=200000 -XX:+PrintStringTableStatistics  </span></span><br><span class="line">    <span class="comment">// 默认-&gt;200000-&gt;1009(最小值)，观察耗时  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/main/resources/linux.words&quot;</span>), StandardCharsets.UTF_8))) &#123;  </span><br><span class="line">            <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">            <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();  </span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;  </span><br><span class="line">                line = br.readLine();  </span><br><span class="line">                <span class="keyword">if</span> (line == <span class="literal">null</span>) &#123;  </span><br><span class="line">                    <span class="keyword">break</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">                line.intern();  </span><br><span class="line">            &#125;  </span><br><span class="line">            System.out.println(<span class="string">&quot;cost: &quot;</span> + (System.nanoTime() - start) / <span class="number">1000000</span>) ;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="主动运用-intern-的场景"><a href="#主动运用-intern-的场景" class="headerlink" title="主动运用 intern 的场景"></a>主动运用 intern 的场景</h4><p>当你需要大量缓存重复的字符串时，使用 intern 可以大大减少内存占用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableTest_11</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// -Xms500m -Xmx500m -XX:StringTableSize=200000 -XX:+PrintStringTableStatistics  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">        List&lt;String&gt; words = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">        System.in.read();  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;  </span><br><span class="line">            <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/main/resources/linux.words&quot;</span>), StandardCharsets.UTF_8))) &#123;  </span><br><span class="line">                <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">                <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();  </span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;  </span><br><span class="line">                    line = br.readLine();  </span><br><span class="line">                    <span class="keyword">if</span> (line == <span class="literal">null</span>) &#123;  </span><br><span class="line">                        <span class="keyword">break</span>;  </span><br><span class="line">                    &#125;    </span><br><span class="line">                    <span class="comment">// words.add(line);  </span></span><br><span class="line">                    words.add(line.intern());  </span><br><span class="line">                &#125;  </span><br><span class="line">                System.out.println(<span class="string">&quot;cost: &quot;</span> + (System.nanoTime() - start) / <span class="number">1000000</span>) ;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.in.read();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 VisualVM 观察字符串和 char[] 内存占用情况，可以发现提升显著。</p>
<img src="/2023/11/03/testing-and-analysis-of-StringTable/Pasted%20image%2020231103131707.png" class="" title="intern 减少内存占用">

<h2 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h2><h3 id="变量的拼接"><a href="#变量的拼接" class="headerlink" title="变量的拼接"></a>变量的拼接</h3><p>字符串变量的拼接，底层是使用 StringBuilder 实现：<code>new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString()</code>，而 toString 方法使用拼接得到的 char 数组创建一个新的 String 对象，因此 s3 和 s4 是不相同的两个对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableTest_2</span> &#123;  </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> 0: ldc           #2                  // String a</span><br><span class="line"> 2: astore_1</span><br><span class="line"> 3: ldc           #3                  // String b</span><br><span class="line"> 5: astore_2</span><br><span class="line"> 6: ldc           #4                  // String ab</span><br><span class="line"> 8: astore_3</span><br><span class="line"> 9: new           #5                  // class java/lang/StringBuilder</span><br><span class="line">12: dup</span><br><span class="line">13: invokespecial #6                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">16: aload_1</span><br><span class="line">17: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">20: aload_2</span><br><span class="line">21: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">24: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">27: astore        4</span><br><span class="line">29: return</span><br></pre></td></tr></table></figure>

<h3 id="常量的拼接"><a href="#常量的拼接" class="headerlink" title="常量的拼接"></a>常量的拼接</h3><p>字符串常量的拼接是在编译期间，因为已知结果而被优化为一个字符串常量。又因为 “ab” 字符串在 StringTable 中是已存在的，所以不会重新创建新对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableTest_3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> 0: ldc           #2                  // String a</span><br><span class="line"> 2: astore_1</span><br><span class="line"> 3: ldc           #3                  // String b</span><br><span class="line"> 5: astore_2</span><br><span class="line"> 6: ldc           #4                  // String ab</span><br><span class="line"> 8: astore_3</span><br><span class="line"> 9: new           #5                  // class java/lang/StringBuilder</span><br><span class="line">12: dup</span><br><span class="line">13: invokespecial #6                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">16: aload_1</span><br><span class="line">17: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">20: aload_2</span><br><span class="line">21: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">24: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">27: astore        4</span><br><span class="line">29: ldc           #4                  // String ab</span><br><span class="line">31: astore        5</span><br><span class="line">33: return</span><br></pre></td></tr></table></figure>

<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/55994121/answer/147296098">Java 中new String(“字面量”) 中 “字面量” 是何时进入字符串常量池的? - xinxi的回答 - 知乎</a></li>
<li><a target="_blank" rel="noopener" href="https://www.iteye.com/topic/774673">请别再拿“String s &#x3D; new String(“xyz”);创建了多少个String实例”来面试了吧</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zyplanke/article/details/108699727">JVM中字符串常量池StringTable在内存中形式分析</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.moralok.com/2023/11/01/testing-and-analysis-of-jvm-gc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Moralok">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Moralok">
      <meta itemprop="description" content="假如生命只剩一天">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Moralok">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/01/testing-and-analysis-of-jvm-gc/" class="post-title-link" itemprop="url">JVM GC 的测试和分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-01 11:42:50" itemprop="dateCreated datePublished" datetime="2023-11-01T11:42:50+08:00">2023-11-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-01-25 19:49:56" itemprop="dateModified" datetime="2024-01-25T19:49:56+08:00">2024-01-25</time>
    </span>

  
    <span id="/2023/11/01/testing-and-analysis-of-jvm-gc/" class="post-meta-item leancloud_visitors" data-flag-title="JVM GC 的测试和分析" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="堆的组成"><a href="#堆的组成" class="headerlink" title="堆的组成"></a>堆的组成</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JvmGcTest_1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_512KB</span> <span class="operator">=</span> <span class="number">512</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_6MB</span> <span class="operator">=</span> <span class="number">6</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_7MB</span> <span class="operator">=</span> <span class="number">7</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_8MB</span> <span class="operator">=</span> <span class="number">8</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</span></span><br><span class="line">    <span class="comment">// -XX:+UseSerialGC 避免幸存区比例动态调整</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 2010K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">  eden space 8192K,  24% used [0x00000000fec00000, 0x00000000fedf68c8, 0x00000000ff400000)</span><br><span class="line">  from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)</span><br><span class="line"> tenured generation   total 10240K, used 0K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">   the space 10240K,   0% used [0x00000000ff600000, 0x00000000ff600000, 0x00000000ff600200, 0x0000000100000000)</span><br><span class="line"> Metaspace       used 3288K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 348K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>根据打印的信息，组成如下：</p>
<ul>
<li><code>Heap</code>: 堆。<ul>
<li><code>def new generation</code>: 新生代。</li>
<li><code>tenured generation</code>: 老年代。</li>
<li><code>Metaspace</code>: 元空间，实际上并不属于堆， <code>-XX:+PrintGCDetails</code> 将它的信息一起输出。</li>
</ul>
</li>
</ul>
<h4 id="堆空间的比例"><a href="#堆空间的比例" class="headerlink" title="堆空间的比例"></a>堆空间的比例</h4><p>新生代中的空间占比 <code>eden:from:to</code> 在默认情况下是 <code>8:1:1</code>，与观察到的数据 <code>8192K:1024K:1024K</code> 一致。<br>新生代的空间 <code>eden + from + to</code> 为 10240K，符合 <code>-Xmn10M</code> 设置的大小。<br><code>total</code> 显示为 9216K，即 <code>eden + from</code> 的大小，是因为 <code>to</code> 的空间不计算在内。新生代可用的空间只有 <code>eden + from</code>，<code>to</code> 空间只是在使用标记-复制算法进行垃圾回收时使用。<br>老年代的空间为 10240K。<br>目前仅 <code>eden</code> 中已用 2010K，约占 <code>eden</code> 空间的 24%。</p>
<h4 id="从内存地址分析堆空间"><a href="#从内存地址分析堆空间" class="headerlink" title="从内存地址分析堆空间"></a>从内存地址分析堆空间</h4><p>内存地址为 16 位的 16 进制的数字，64 位机器。<br><code>[0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</code> 分别表示地址空间的开始、已用、结束的地址指针。<br>新生代 <code>[0x00000000fec00000, 0x00000000ff600000)</code>，老年代 <code>[0x00000000ff600000, 0x0000000100000000)</code>，计算可得空间大小均为 10MB。<br><code>eden</code> 中已用的空间地址为 <code>[0x00000000fec00000, 0x00000000fedf68c8)</code>，空间大小为 2058440 byte，约等于 2010K。</p>
<p>显而易见，新生代和老生代是一片完全连续的地址空间。</p>
<h3 id="堆的垃圾回收"><a href="#堆的垃圾回收" class="headerlink" title="堆的垃圾回收"></a>堆的垃圾回收</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_7MB]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: 2013K-&gt;721K(9216K), 0.0105099 secs] 2013K-&gt;721K(19456K), 0.0105455 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span><br><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 8135K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">  eden space 8192K,  90% used [0x00000000fec00000, 0x00000000ff33d8c0, 0x00000000ff400000)</span><br><span class="line">  from space 1024K,  70% used [0x00000000ff500000, 0x00000000ff5b45f0, 0x00000000ff600000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)</span><br><span class="line"> tenured generation   total 10240K, used 0K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">   the space 10240K,   0% used [0x00000000ff600000, 0x00000000ff600000, 0x00000000ff600200, 0x0000000100000000)</span><br><span class="line"> Metaspace       used 3354K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 360K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p><code>Allocation Failure</code>，正常情况下，新对象总是分配在 Eden，分配空间失败，<code>eden</code> 的剩余空间不足以存放 7M 大小的对象，新生代发生 <code>minor GC</code>。<br><code>[DefNew: 2013K-&gt;721K(9216K), 0.0105099 secs]</code>，新生代在垃圾回收前后空间的占用变化和耗时。<br><code>2013K-&gt;721K(19456K), 0.0105455 secs</code>，整个堆在垃圾回收前后空间的占用变化和耗时。</p>
<h4 id="GC-类型"><a href="#GC-类型" class="headerlink" title="GC 类型"></a>GC 类型</h4><ul>
<li>GC: minor GC。</li>
<li>Fulle GC: full GC。</li>
</ul>
<h4 id="from-和-to-的角色变换"><a href="#from-和-to-的角色变换" class="headerlink" title="from 和 to 的角色变换"></a>from 和 to 的角色变换</h4><p><code>from</code> 的已用空间的地址为 <code>[0x00000000ff500000, 0x00000000ff5b45f0)</code>，空间大小为 738800 byte，约 721K，与 GC 后的新生代空间占用大小一致。在垃圾回收后，<code>eden</code> 区域存活的对象全部转移到了原 <code>to</code> 空间，<code>from</code> 和 <code>to</code> 空间的角色相互转换（从地址空间的信息可以看到此时 <code>to</code> 的地址指针比 <code>from</code> 的地址指针小）。<br><code>eden</code> 的已用空间的地址为 <code>[0x00000000fec00000, 0x00000000ff33d8c0)</code>，空间大小为 7592128 byte，约 7.24M，比 7M 大不少。此时 <code>eden</code> 区域除了 <code>byte[]</code> 对象外，还存储了其他对象，比如为了创建 <code>List&lt;byte[]&gt;</code> 对象而新加载的类对象。</p>
<h3 id="eden-空间足够时不发生-GC"><a href="#eden-空间足够时不发生-GC" class="headerlink" title="eden 空间足够时不发生 GC"></a>eden 空间足够时不发生 GC</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_7MB]);</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_512KB]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: 2013K-&gt;721K(9216K), 0.0011172 secs] 2013K-&gt;721K(19456K), 0.0011443 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 8647K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">  eden space 8192K,  96% used [0x00000000fec00000, 0x00000000ff3bd8d0, 0x00000000ff400000)</span><br><span class="line">  from space 1024K,  70% used [0x00000000ff500000, 0x00000000ff5b45f0, 0x00000000ff600000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)</span><br><span class="line"> tenured generation   total 10240K, used 0K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">   the space 10240K,   0% used [0x00000000ff600000, 0x00000000ff600000, 0x00000000ff600200, 0x0000000100000000)</span><br><span class="line"> Metaspace       used 3354K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 360K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>由于 <code>eden</code> 区域还能放下 512K 的对象，所以仍然只会发生一次垃圾回收。<br><code>eden</code> 区域的已用空间比例上升到 96%，已用空间的地址为 <code>[0x00000000fec00000, 0x00000000ff3bd8d0)</code>，空间大小为 8116432 byte，约 7.74M，比上一次增加了 524304 byte，即 <code>512 * 1024 + 16</code>。显然第二次添加时，不再因为创建 <code>List&lt;byte[]&gt;</code> 而创建额外的对象，只有创建对象所需的 512K 和 16 字节的对象头。<strong>这一刻数值的精确让人欣喜hhh</strong>。</p>
<h3 id="新生代空间不足，部分对象提前晋升到老年代"><a href="#新生代空间不足，部分对象提前晋升到老年代" class="headerlink" title="新生代空间不足，部分对象提前晋升到老年代"></a>新生代空间不足，部分对象提前晋升到老年代</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_7MB]);</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_512KB]);</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_512KB]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: 2013K-&gt;721K(9216K), 0.0013580 secs] 2013K-&gt;721K(19456K), 0.0013932 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [DefNew: 8565K-&gt;512K(9216K), 0.0046378 secs] 8565K-&gt;8396K(19456K), 0.0046540 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 1350K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">  eden space 8192K,  10% used [0x00000000fec00000, 0x00000000fecd1a20, 0x00000000ff400000)</span><br><span class="line">  from space 1024K,  50% used [0x00000000ff400000, 0x00000000ff480048, 0x00000000ff500000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)</span><br><span class="line"> tenured generation   total 10240K, used 7884K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">   the space 10240K,  77% used [0x00000000ff600000, 0x00000000ffdb33a0, 0x00000000ffdb3400, 0x0000000100000000)</span><br><span class="line"> Metaspace       used 3354K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 360K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>在第三次添加时，由于 <code>eden</code> 空间不足，因此又发生了第二次垃圾回收。<br><code>[DefNew: 8565K-&gt;512K(9216K), 0.0046378 secs]</code>，新生代的空间占用下降到了 512K，应该是在 from 中留下了第二次添加时的 512K。<br>在第二次添加完成后，<code>eden</code> <code>[0x00000000fec00000, 0x00000000ff3bd8d0)</code> 和 <code>from</code> <code>[0x00000000ff500000, 0x00000000ff5b45f0)</code> 占用的空间为 <code>8116432 + 738800 = 8855232</code> 约 8647.7K，略大于 8565K。很奇怪，第二次垃圾回收前，新生代的空间占用为什么有小幅度下降。<br><code>8565K-&gt;8396K(19456K), 0.0046540 secs</code>，堆的占用空间并未发生明显下降。部分对象因为新生代空间不足，提前晋升到了老年代中。8396K - 512 K 剩余 7884K，全部晋升到老年代，符合 77% 的统计数据。<br><code>eden</code> 中加入了第三次添加时的对象，大于 512K 不少。<br>此时 <code>eden</code>、<code>from</code>、<code>tenured</code> 中均有不好确认成分的空间占用，比如 from 中多了 56 字节。</p>
<h3 id="新生代空间不足，大对象直接在老年代创建"><a href="#新生代空间不足，大对象直接在老年代创建" class="headerlink" title="新生代空间不足，大对象直接在老年代创建"></a>新生代空间不足，大对象直接在老年代创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_8MB]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line"> def <span class="keyword">new</span> <span class="title class_">generation</span>   total 9216K, used 2177K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  eden space 8192K,  <span class="number">26</span>% used [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000fee20730</span>, <span class="number">0x00000000ff400000</span>)</span><br><span class="line">  from space 1024K,   <span class="number">0</span>% used [<span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff500000</span>)</span><br><span class="line">  to   space 1024K,   <span class="number">0</span>% used [<span class="number">0x00000000ff500000</span>, <span class="number">0x00000000ff500000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line"> tenured generation   total 10240K, used 8192K [<span class="number">0x00000000ff600000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">   the space 10240K,  <span class="number">80</span>% used [<span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ffe00010</span>, <span class="number">0x00000000ffe00200</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line"> Metaspace       used 3353K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 360K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>在 Eden 空间肯定不足而老年代空间足够的情况下，大对象会直接在老年代中创建，此时不会发生 GC。</p>
<h3 id="内存不足-OOM"><a href="#内存不足-OOM" class="headerlink" title="内存不足 OOM"></a>内存不足 OOM</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_8MB]);</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_8MB]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">waiting...</span><br><span class="line">[GC (Allocation Failure) [DefNew: 4711K-&gt;928K(9216K), 0.0017245 secs][Tenured: 8192K-&gt;9117K(10240K), 0.0021690 secs] 12903K-&gt;9117K(19456K), [Metaspace: 4267K-&gt;4267K(1056768K)], 0.0039336 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (Allocation Failure) [Tenured: 9117K-&gt;9063K(10240K), 0.0014352 secs] 9117K-&gt;9063K(19456K), [Metaspace: 4267K-&gt;4267K(1056768K)], 0.0014614 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">Exception in thread &quot;Thread-0&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at com.moralok.jvm.gc.JvmGcTest.lambda$main$0(JvmGcTest.java:27)</span><br><span class="line">	at com.moralok.jvm.gc.JvmGcTest$$Lambda$1/2003749087.run(Unknown Source)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:750)</span><br><span class="line"></span><br><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 1502K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">  eden space 8192K,  18% used [0x00000000fec00000, 0x00000000fed77a00, 0x00000000ff400000)</span><br><span class="line">  from space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)</span><br><span class="line"> tenured generation   total 10240K, used 9063K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">   the space 10240K,  88% used [0x00000000ff600000, 0x00000000ffed9c50, 0x00000000ffed9e00, 0x0000000100000000)</span><br><span class="line"> Metaspace       used 4787K, capacity 4884K, committed 4992K, reserved 1056768K</span><br><span class="line">  class space    used 522K, capacity 558K, committed 640K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>当新生代和老年代的空间均不足时，在尝试 GC 和 Full GC 后仍不能成功分配对象，就会发生 <code>OutOfMemoryError</code>。</p>
<h4 id="线程中发生内存不足，不会影响其他线程"><a href="#线程中发生内存不足，不会影响其他线程" class="headerlink" title="线程中发生内存不足，不会影响其他线程"></a>线程中发生内存不足，不会影响其他线程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_8MB]);</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_8MB]);</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: 2013K-&gt;721K(9216K), 0.0012274 secs][Tenured: 8192K-&gt;8912K(10240K), 0.0113036 secs] 10205K-&gt;8912K(19456K), [Metaspace: 3345K-&gt;3345K(1056768K)], 0.0125751 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span><br><span class="line">[Full GC (Allocation Failure) [Tenured: 8912K-&gt;8895K(10240K), 0.0011880 secs] 8912K-&gt;8895K(19456K), [Metaspace: 3345K-&gt;3345K(1056768K)], 0.0012009 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 246K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">  eden space 8192K,   3% used [0x00000000fec00000, 0x00000000fec3d890, 0x00000000ff400000)</span><br><span class="line">  from space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)</span><br><span class="line"> tenured generation   total 10240K, used 8895K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">   the space 10240K,  86% used [0x00000000ff600000, 0x00000000ffeafce0, 0x00000000ffeafe00, 0x0000000100000000)</span><br><span class="line"> Metaspace       used 3380K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 363K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at com.moralok.jvm.gc.JvmGcTest.main(JvmGcTest.java:21)</span><br></pre></td></tr></table></figure>

<p>当 <code>Thread-0</code> 发生 <code>OutOfMemoryError</code> 后，<code>main</code> 线程仍然正常运行。</p>
<h3 id="大对象的划分指标"><a href="#大对象的划分指标" class="headerlink" title="大对象的划分指标"></a>大对象的划分指标</h3><p>当创建的大对象 + 对象头的容量小于等于 <code>eden</code>，如果 GC 后的存活对象可以放入 <code>to</code>，那么还是会先在 <code>eden</code> 中创建大对象。<br>在本案例中，又会马上发生一次 GC，大对象提前晋升到老年代中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_8MB - <span class="number">16</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: 2013K-&gt;693K(9216K), 0.0015517 secs] 2013K-&gt;693K(19456K), 0.0015828 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [DefNew: 8885K-&gt;0K(9216K), 0.0048110 secs] 8885K-&gt;8885K(19456K), 0.0048264 secs] [Times: user=0.00 sys=0.02, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 410K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">  eden space 8192K,   5% used [0x00000000fec00000, 0x00000000fec66958, 0x00000000ff400000)</span><br><span class="line">  from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)</span><br><span class="line"> tenured generation   total 10240K, used 8885K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">   the space 10240K,  86% used [0x00000000ff600000, 0x00000000ffead580, 0x00000000ffead600, 0x0000000100000000)</span><br><span class="line"> Metaspace       used 3321K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 354K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>尽管最终大部分对象提前晋升到老年代，但是可以看到第二次 GC 前的新生代空间占用，可见数组分配时，所需空间刚好为 Eden 空间大小时，还是会在 eden 创建对象。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>正常情况下，新对象都是在 eden 中创建。</li>
<li>空间足够的意思并非空间占用相加的值仍小于总额，而是有连续的一片内存可供分配。因此紧凑才能利用率高。</li>
<li>正常情况下，GC 前 to 区域总是为空，GC 后 eden 区域总是为空。</li>
<li>正常情况下，GC 后 eden 和 from 的存活对象要么去了 to，要么去老年代。</li>
<li>只要 GC 后腾空 eden，创建在 eden 中的新对象的空间占用可以等于 eden 的大小。</li>
</ul>
<p>尽管总体上有迹可循，但是 GC 的具体情况，仍然需要具体分析，有很多分支情况未一一确认。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Moralok</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">121k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">6:44</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  


  <script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"3EC6DlIt15eVYStwSVsDsQ2P-MdYXbMMI","app_key":"KKBQicvLunsmAfgH3DJJXvng","server_url":null,"security":false}</script>
  <script src="/js/third-party/statistics/lean-analytics.js"></script>



</body>
</html>
