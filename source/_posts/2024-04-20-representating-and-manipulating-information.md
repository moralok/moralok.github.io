---
title: 信息的表示和处理
date: 2024-03-12 07:48:32
tags:
---

《深入理解计算机系统》读书笔记。

<!-- more -->

现代计算机存储和处理的信息以**二值信号**表示。二值信号能够**很容易地被表示、存储和传输**。当把位（bit）组合在一起，再加上某种解释（interpretation），即赋予不同的可能位模式以含义，我们就**能够表示任何有限集合的元素**。

> “很容易地被表示、存储和传输” => 高低电压。

通过研究数字的实际表示，我们能够了解**可以表示的值的范围**和**不同算术运算的属性**。为了使编写的程序能在全部数值范围内正确工作，而且具有跨越不同机器、操作系统和编译器组合的可移植性，了解这种属性是非常重要的。大量计算机的安全漏洞都是由于计算机算术运算的微妙细节引发的。在早期，当人们碰巧触发了程序漏洞，只会给人们带来一些不便，但是现在，有众多的黑客企图利用他们能找到的任何漏洞，不经过授权就进入他人的系统。这就要求**程序员有更多的责任和义务，去了解他们的程序如何工作，以及如何被迫产生不良的行为**。

> 研究的目的。
不仅仅需要正向地去了解如何让程序正确地工作，也要反向地去了解如何迫使程序产生不良的行为，这可以更好地帮助理解工作原理。

从编码的基本定义开始，然后得出一些属性，例如可表示的数字的范围、它们的位级表示以及算术运算的属性。**从这样一个抽象的观点来分析是很重要的**，因为程序员需要对计算机运算与更为人熟悉的整数和实数运算之间的关系有清晰的理解。

> 不仅仅需要了解当前的设计是怎么样的，还要了解为什么这样设计。表示数字的方式、表示数字的位的数量、字长都可以更加“多样化”。


## 信息存储

大多数计算机使用8位的块，或者字节（byte），作为**最小的可寻址的内存单位**，而不是访问内存中单独的位。机器级程序将内存视为一个非常大的字节数组，称为**虚拟内存**（virtual memory）。内存的每个字节都由一个唯一的数字来标识，称为它的**地址**（address），所有可能地址的集合就称为**虚拟地址空间**（virtual address space）。

编译器和运行时系统将存储器空间划分为更可管理的单元，来存放不同的程序对象（program object），即程序数据、指令和控制信息。每个程序对象可以简单地视为一个字节块，而程序本身就是一个字节序列。

### 十六进制表示法

一个字节由8位组成。二进制表示法太冗长，而十进制表示法与位模式地互相转化很麻烦，替代的方法是，以16为基数，或者叫做**十六进制**（hexadecimal，简写为 hex）数，来表示位模式。

|十进制|0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|
|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|
|十六进制|0|1|2|3|4|5|6|7|8|9|A|B|C|D|E|F|
|二进制|0000|0001|0010|0011|0100|0101|0110|0111|1000|1001|1010|1011|1100|1101|1110|1111|

### 字数据大小

每台计算机都有一个**字长**（word size），指明指针数据的标称大小（nominal size）。因为虚拟地址是以这样的一个字来编码的，所以**字长决定的最重要的系统参数就是虚拟地址空间的最大大小**。对于一个字长为w位的机器而言，虚拟地址的范围为0~2^w-1，程序最多访问2^w个字节。32位字长限制虚拟地址空间为4GB，64位字长限制虚拟地址空间为16EB。
大多数64位机器也可以运行为32位机器编译的程序，这是一种向后兼容。“32位机器”和“64位机器”区别在于该程序是如何编译的，而不是其运行的机器类型。

基本C语言数据类型的典型大小（以字节为单位），分配的字节数受程序是如何编译的影响而变化。

|有符号|无符号|32位|64位|
|--|--|--|--|
|[signed] char|unsigned char|1|1|
|short|unsigned short|2|2|
|int|unsigned int|4|4|
|long|unsigned long|4|8|
|int32_t|uint32_t|4|4|
|int64_t|uint64_t|8|8|
|char *||4|8|
|float||4|4|
|double||8|8|

**程序员应该力图使他们的程序在不同的机器和编译器上可移植**。可移植性的一个方面就是使程序对不同数据类型的确切大小不敏感。

### 寻址和字节顺序

对于跨越多字节的程序对象，我们必须建立两个规则：**这个对象的地址是什么，以及在内存中如何排列这些字节**。
在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用的字节中最小的地址。
排列表示一个对象的字节有两个通用的规则。最低有效字节在最前面的方式，称为**小端法**（little endian）；最高有效字节在最前面的方式，称为**大端法**（big endian）。大多数 Intel 兼容机都只用小端模式；IBM 和 Oracle 的大多数机器按大端模式操作，个人计算机使用小端法；许多比较新的微处理器使用双端法（bi-endian），比如移动电话上的 ARM 微处理器，但是最常见的 Android 和 iOS 只能运行于小端模式。

**选择何种字节顺序没有技术上的理由**。只要选择了一种规则并且始终如一地坚持，对于哪种字节排序的选择都是任意的。

对于大多数应用程序员来说，其机器所使用的字节顺序是完全不可见的。**不过有时候，字节顺序会成为问题**。一、在不同类型的机器之间通过网络传送二进制数据时，网络应用程序的代码编写必须遵守已建立的关于字节顺序的规则。二、当检查机器级程序，阅读表示整数数据的字节序列时字节顺序也很重要。三、当编写规避正常的类型系统的程序时，比如使用强制类型转换来访问和打印不同程序对象的字节表示。

### 表示字符串

C语言中字符串被编码为一个以null（其值为 0）字符结尾的字符数组。每个字符都由某个标准编码来表示，最常见的是 ASCII 字符码。在使用 ASCII 码作为字符码的任何系统上都将得到相同的结果，与字节顺序和字大小规则无关。因而，**文本数据比二进制数据具有更强的平台独立性**。

可以通过执行命令 man ascii 来得到一张 ASCII 字符码的表。

文字编码的 Unicode 标准：
ASCII 字符集适合于编码英语文档，但是在表达一些特殊字符方面并没有太多办法，它完全不适合编码希腊语、俄语和中文等语言的文档。基本编码，称为 Unicode 的“统一字符集”，使用32位来表示字符，每个字符要占用4个字节。不过有一些替代编码，常见的字符只需要1个或2个字节，而不太常用的字符需要多一些的字节数。特别地，UTF-8 表示将每个字符编码为一个字节序列，兼容标准 ASCII。

### 表示代码

不同的机器类型使用不同的且不兼容的指令和编码方式。即使是完全一样的进程，运行在不同的操作系统上也会有不同的编码规则，因此二进制代码是不兼容的。二进制代码很少能在不同机器和操作系统组合之间移植。

计算机系统的一个基本概念就是，**从机器的角度来看，程序仅仅只是字节序列**。机器没有关于原始源程序的任何信息，除了可能有些用来帮助调试的辅助表以外。

### 布尔代数简介

二进制值是计算机编码、存储和操作信息的核心，所以围绕数值 0 和 1 的研究已经演化出了丰富的数据知识体系，称为布尔代数（Boolean algebra）。

最简单的布尔代数是在二元集合{0, 1}基础上的定义。二进制值 1 和 0 表示逻辑值 TRUE 或者 FALSE，而运算符~、&、|和^分别表示逻辑运算 NOT、AND、OR 和 EXCLUSIVE-OR（在命题逻辑中分别为）。
布尔运算可以扩展到位向量的运算。

布尔运算 & 对 | 具有分配律；| 对 & 具有分配律。
布尔环 a^a=0，(a^b)^a=b。

**位向量一个很有用的应用就是表示有限集合**。掩码表示的就是设置为有效信号的集合。

### C语言中的布尔运算

C语言的一个很有用的特性就是它支持按位布尔运算。确定一个位级表达式的结果最好的方法，就是将十六进制的参数扩展成二进制表示并执行二进制运算，然后再转换回十六进制。

### C语言中的移位运算

C语言还提供了一组移位运算，向左(`<<`)或者向右(`>>`)移动位模式。移位量应该是一个0~w-1之间的值。移位运算是从左至右可结合的。
右移运算 `x>>k` 的行为有点微妙。一般而言，机器支持两种形式的右移：逻辑右移和算术右移。逻辑右移在左端补k个0，算术右移是在左端补k个最高有效位的值。这种做法看上去可能有点奇特，但是它对有符号整数数据的运算非常有用。

C语言标准并没有明确定义对于有符号数应该使用哪种类型的位移，这意味着可能会遇到可移植性问题。实际上，几乎所有的编译器/机器都对有符号数使用算术位移，对于无符号数使用逻辑右移。
与C相比，Java对于如何右移有明确的定义。`>>` 表示算术右移，`>>>` 表示逻辑右移。

对于一个由 w 位组成的数据类型，C语言标准很小心地规避了说明当移动k≥w位时应该如何做。在许多机器上，实际上位移量是通过 k mod w 得到的。

**加减法的优先级比位移运算高**。