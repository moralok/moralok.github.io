<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker 常用命令</title>
    <url>/2020/08/19/docker-frequently-used-commands/</url>
    <content><![CDATA[<p>根据个人使用经验从 <code>Docker</code> 官方命令行参考中选取常用的命令作为备忘清单。</p>
<span id="more"></span>

<h2 id="容器相关"><a href="#容器相关" class="headerlink" title="容器相关"></a>容器相关</h2><table>
<thead>
<tr>
<th>命令</th>
<th>补充</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>docker run -d --name=CONTAINER -p 1080:80 IMAGE:TAG</code></td>
<td><code>-e</code> <code>-v</code> <code>--network</code> <code>--restart</code> <code>-it</code></td>
<td>创建容器</td>
</tr>
<tr>
<td><code>docker ps | grep CONTAINER</code></td>
<td><code>-a</code> <code>-q</code></td>
<td>列出容器</td>
</tr>
<tr>
<td><code>docker stop CONTAINER</code></td>
<td></td>
<td>停止容器</td>
</tr>
<tr>
<td><code>docker rm CONTAINER</code></td>
<td></td>
<td>删除容器</td>
</tr>
<tr>
<td><code>docker start CONTAINER</code></td>
<td></td>
<td>启动已停止容器</td>
</tr>
<tr>
<td><code>docker restart CONTAINER</code></td>
<td></td>
<td>重启容器</td>
</tr>
<tr>
<td><code>docker logs -f CONTAINER</code></td>
<td><code>-n</code> <code>-t</code> <code>--since</code> <code>--until</code></td>
<td>获取容器日志</td>
</tr>
<tr>
<td><code>docker exec CONTAINER ls</code></td>
<td><code>-d</code> <code>-e</code> <code>-w</code></td>
<td>在容器内执行命令</td>
</tr>
<tr>
<td><code>docker exec -it CONTAINER /bin/bash</code></td>
<td></td>
<td>进入容器</td>
</tr>
<tr>
<td><code>docker inspect CONTAINER</code></td>
<td><code>-f</code></td>
<td>查看容器信息</td>
</tr>
<tr>
<td><code>docker top CONTAINER</code></td>
<td></td>
<td>显示容器中的运行进程</td>
</tr>
<tr>
<td><code>docker cp CONTAINER:/app/source /app/target</code></td>
<td>双向 目录或文件</td>
<td>在宿主机和容器间拷贝文件</td>
</tr>
<tr>
<td><code>docker attach CONTAINER</code></td>
<td>使用 <code>CTRL-p CTRL-q</code> 退出</td>
<td>附着到容器</td>
</tr>
<tr>
<td><code>docker port CONTAINER</code></td>
<td><code>7890/tcp</code></td>
<td>列出容器的端口映射</td>
</tr>
<tr>
<td><code>docker rename CONTAINER NEW_NAME</code></td>
<td></td>
<td>重命名容器</td>
</tr>
</tbody></table>
<h2 id="镜像相关"><a href="#镜像相关" class="headerlink" title="镜像相关"></a>镜像相关</h2><table>
<thead>
<tr>
<th>命令</th>
<th>补充</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>docker images</code></td>
<td><code>-a</code></td>
<td>列出镜像</td>
</tr>
<tr>
<td><code>docker pull IMAGE:TAG</code></td>
<td></td>
<td>拉取镜像</td>
</tr>
<tr>
<td><code>docker rmi IMAGE:TAG</code></td>
<td></td>
<td>删除镜像</td>
</tr>
<tr>
<td><code>docker build -t IMAGE:TAG .</code></td>
<td></td>
<td>构建镜像</td>
</tr>
<tr>
<td><code>docker search IMAGE</code></td>
<td>去官网方便</td>
<td>搜索镜像</td>
</tr>
</tbody></table>
<h2 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h2><table>
<thead>
<tr>
<th>命令</th>
<th>补充</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>docker network ls</code></td>
<td></td>
<td>列出网络</td>
</tr>
<tr>
<td><code>docker network create NETWORK</code></td>
<td></td>
<td>创建网络</td>
</tr>
<tr>
<td><code>docker network rm NETWORK</code></td>
<td></td>
<td>删除网络</td>
</tr>
<tr>
<td><code>docker network inspect NETWORK</code></td>
<td></td>
<td>查看网络信息</td>
</tr>
<tr>
<td><code>docker network connect NETWORK CONTAINER</code></td>
<td></td>
<td>将容器连接到网络</td>
</tr>
<tr>
<td><code>docker network disconnect NETWORK CONTAINER</code></td>
<td></td>
<td>将容器从网络断开</td>
</tr>
</tbody></table>
<h2 id="卷相关"><a href="#卷相关" class="headerlink" title="卷相关"></a>卷相关</h2><table>
<thead>
<tr>
<th>命令</th>
<th>补充</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>docker volume ls</code></td>
<td></td>
<td>列出卷</td>
</tr>
<tr>
<td><code>docker volume create VOLUME</code></td>
<td></td>
<td>创建卷</td>
</tr>
<tr>
<td><code>docker volume rm VOLUME</code></td>
<td></td>
<td>删除卷</td>
</tr>
<tr>
<td><code>docker volume inspect VOLUME</code></td>
<td></td>
<td>查看卷信息</td>
</tr>
</tbody></table>
<h2 id="Docker-相关"><a href="#Docker-相关" class="headerlink" title="Docker 相关"></a>Docker 相关</h2><table>
<thead>
<tr>
<th>命令</th>
<th>补充</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>docker stats</code></td>
<td><code>-a</code></td>
<td>显示容器资源使用统计</td>
</tr>
<tr>
<td><code>docker info</code></td>
<td><code>-f</code></td>
<td>显示 Docker 信息</td>
</tr>
<tr>
<td><code>docker version</code></td>
<td></td>
<td>显示 Docker 版本</td>
</tr>
</tbody></table>
<h2 id="systemd-相关"><a href="#systemd-相关" class="headerlink" title="systemd 相关"></a>systemd 相关</h2><table>
<thead>
<tr>
<th>命令</th>
<th>补充</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>systemctl start docker</code></td>
<td></td>
<td>启动 Docker 服务</td>
</tr>
<tr>
<td><code>systemctl stop docker</code></td>
<td></td>
<td>停止 Docker 服务</td>
</tr>
<tr>
<td><code>systemctl restart docker</code></td>
<td></td>
<td>重启 Docker 服务</td>
</tr>
<tr>
<td><code>systemctl status docker</code></td>
<td></td>
<td>查看 Docker 服务状态</td>
</tr>
<tr>
<td><code>systemctl enable docker</code></td>
<td></td>
<td>设置 Docker 服务开启自启动</td>
</tr>
</tbody></table>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://docs.docker.com/engine/reference/run/">Docker 命令行参考</a><br><a href="https://www.cnblogs.com/doujianli/p/10048707.html">深入探究docker attach的退出方式</a></p>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 常用命令</title>
    <url>/2020/09/04/MySQL-frequently-used-commands/</url>
    <content><![CDATA[<p>根据个人使用经验记录常用的 <code>MySQL</code> 命令作为备忘清单。</p>
<span id="more"></span>

<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>mysql –h localhost –u root -P 3306 –p</code></td>
<td>连接数据库</td>
</tr>
</tbody></table>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>SHOW DATABASES;</code></td>
<td>列出数据库</td>
</tr>
<tr>
<td><code>CREATE DATABASE IF NOT EXISTS `db_name` DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;</code></td>
<td>创建数据库</td>
</tr>
<tr>
<td><code>DROP DATABASE `db_name`;</code></td>
<td>删除数据库</td>
</tr>
<tr>
<td><code>SHOW CREATE DATABASE `db_name`;</code></td>
<td>查看数据库的创建信息</td>
</tr>
<tr>
<td><code>USE `db_name`;</code></td>
<td>选择数据库</td>
</tr>
</tbody></table>
<h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>SHOW TABLES;</code></td>
<td>列出表</td>
</tr>
<tr>
<td><code>CREATE TABLE `table_name` (</code> </br> <code>`id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;主键 id&#39;,</code> </br> <code>`uid` varchar(20) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;uid&#39;,</code> </br> <code>`status` tinyint(1) NOT NULL DEFAULT &#39;1&#39; COMMENT &#39;状态: 0 无效 1 有效&#39;,</code> </br> <code>`gmt_create` bigint(13) unsigned NOT NULL COMMENT &#39;创建时间&#39;,</code> </br> <code>PRIMARY KEY (`id`),</code> </br> <code>UNIQUE KEY `unq_idx_uid` (`uid`)</code> </br> <code>) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4 ROW_FORMAT=DYNAMIC COMMENT=&#39;表的描述&#39;;</code></td>
<td>创建表</td>
</tr>
<tr>
<td><code>DROP TABLE `table_name`;</code></td>
<td>删除表</td>
</tr>
<tr>
<td><code>SHOW CREATE TABLE `table_name`;</code></td>
<td>查看表的创建信息</td>
</tr>
<tr>
<td><code>DESC `table_name`;</code></td>
<td>查看表的字段</td>
</tr>
<tr>
<td><code>ALTER TABLE `table_name` RENAME `new_table_name`;</code></td>
<td>查看表的字段</td>
</tr>
<tr>
<td><code>ALTER TABLE `table_name` MODIFY `field_name` field_type;</code></td>
<td>修改字段类型</td>
</tr>
<tr>
<td><code>ALTER TABLE `table_name` ADD `field_name` field_type AFTER `another_field_name`;</code></td>
<td>添加字段</td>
</tr>
<tr>
<td><code>ALTER TABLE `table_name` DROP `field_name`;</code></td>
<td>删除字段</td>
</tr>
<tr>
<td><code>ALTER TABLE `table_name` CHANGE `field_name` `new_field_name` new_field_type;</code></td>
<td>修改字段名称</td>
</tr>
</tbody></table>
<h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>INSERT INTO `table_name` (field_name1, field_name2) VALUES (value1, value2);</code></td>
<td>新增</td>
</tr>
<tr>
<td><code>SELECT * FROM `table_name` WHERE `field_name` = value;</code></td>
<td>查询</td>
</tr>
<tr>
<td><code>UPDATE `table_name` SET `field_name1` = value1 WHERE `field_name2` = value2;</code></td>
<td>更新</td>
</tr>
<tr>
<td><code>DELETE FROM `table_name` WHERE `field_name` = value;</code></td>
<td>删除</td>
</tr>
<tr>
<td><code>TRUNCATE `table_name`;</code></td>
<td>清空</td>
</tr>
</tbody></table>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>BEGIN;</code> </br> <code>START TRANSACTION;</code></td>
<td>开启事务</td>
</tr>
<tr>
<td><code>START TRANSACTION WITH CONSISTENT SNAPSHOT;</code></td>
<td>开启事务并立即创建 read view</td>
</tr>
<tr>
<td><code>ROLLBACK;</code></td>
<td>回滚事务</td>
</tr>
<tr>
<td><code>COMMIT;</code></td>
<td>提交事务</td>
</tr>
<tr>
<td><code>COMMIT WORK AND CHAIN;</code></td>
<td>提交事务并开启下一个事务（减少一次命令交互）</td>
</tr>
<tr>
<td><code>SELECT @@autocommit;</code></td>
<td>查看 autocommit，默认 1</td>
</tr>
<tr>
<td><code>SET @@autocommit = 0;</code></td>
<td>设置为手动提交</td>
</tr>
<tr>
<td><code> SHOW VARIABLES LIKE &#39;transaction_isolation&#39;;</code> </br> <code>SHOW VARIABLES LIKE &#39;tx_isolation&#39;;</code></td>
<td>查看隔离级别</td>
</tr>
<tr>
<td><code>SET transaction_isolation = &#39;READ-UNCOMMITTED&#39;|&#39;READ-COMMITTED&#39;|&#39;REPEATABLE-READ&#39;|&#39;SERIALIZABLE&#39;;</code> </br> <code>SET SESSION transaction isolation level READ UNCOMMITTED|READ COMMITTED|REPEATABLE-READ|SERIALIZABLE;</code></td>
<td>设置隔离级别</td>
</tr>
<tr>
<td><code>SELECT * FROM information_schema.innodb_trx WHERE TIME_TO_SEC(timediff(now(), trx_started)) &gt; 60;</code></td>
<td>查找持续 60s 以上的事务</td>
</tr>
</tbody></table>
<h2 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h2><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>CREATE USER &#39;username&#39;@&#39;ip&#39; IDENTIFIED BY &#39;password&#39;;</code></td>
<td>创建用户</td>
</tr>
<tr>
<td><code>GRANT ALL ON db_name.* TO &#39;username&#39;@&#39;ip&#39;;</code></td>
<td>授权</td>
</tr>
<tr>
<td><code>FLUSH PRIVILEGES;</code></td>
<td>刷新权限</td>
</tr>
<tr>
<td><code>REVOKE ALL ON db_name.* FROM &#39;username&#39;@&#39;ip&#39;;</code></td>
<td>取消授权</td>
</tr>
<tr>
<td><code>DROP USER &#39;username&#39;@&#39;ip&#39;;</code></td>
<td>删除用户</td>
</tr>
</tbody></table>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>全局变量、会话变量、用户变量、局部变量。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>SHOW [GLOBAL|SESSION] VARIABLES;</code></td>
<td>查看全部变量</td>
</tr>
<tr>
<td><code>SHOW [GLOBAL|SESSION] VARIABLES [LIKE 匹配的模式];</code> </br> <code>SELECT @@[GLOBAL|SESSION].variable_name</code></td>
<td>查看单个变量</td>
</tr>
<tr>
<td><code>SET [GLOBAL|SESSION] variable_name = value;</code> </br> <code>SET @@[GLOBAL|SESSION].variable_name = value</code></td>
<td>设置单个变量</td>
</tr>
</tbody></table>
<blockquote>
<p><code>SESSION</code> 可以省略。</p>
</blockquote>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Ubuntu 上安装 Clash</title>
    <url>/2023/05/27/how-to-install-clash-on-ubuntu/</url>
    <content><![CDATA[<h2 id="安装-Clash"><a href="#安装-Clash" class="headerlink" title="安装 Clash"></a>安装 Clash</h2><p>从 <a href="https://github.com/Dreamacro/clash/releases">GitHub</a> 下载预构建的二进制文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:/mnt/hgfs/share$ wget https://github.com/Dreamacro/clash/releases/download/v1.16.0/clash-linux-amd64-v1.16.0.gz</span><br></pre></td></tr></table></figure>

<p>使用 gzip 解压压缩包 clash-linux-amd64-v1.16.0.gz 得到 clash-linux-amd64-v1.16.0。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:/mnt/hgfs/share$ gzip -d clash-linux-amd64-v1.16.0.gz </span><br><span class="line">gzip: clash-linux-amd64-v1.16.0: Value too large for defined data type</span><br></pre></td></tr></table></figure>
<p>忽略提示。</p>
<p>移动二进制文件到目录 <code>/usr/local/bin</code> 并且重命名为 clash。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:/mnt/hgfs/share$ sudo mv clash-linux-amd64-v1.16.0 /usr/local/bin/clash</span><br><span class="line">[sudo] password for wrmao:</span><br></pre></td></tr></table></figure>

<p>现在可以通过 <code>clash -v</code> 查看 Clash 的版本信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:~$ clash -v</span><br><span class="line">Clash v1.16.0 linux amd64 with go1.20.4 Fri May 19 13:57:32 UTC 2023</span><br></pre></td></tr></table></figure>

<h2 id="使用-Clash"><a href="#使用-Clash" class="headerlink" title="使用 Clash"></a>使用 Clash</h2><p>使用命令 <code>clash</code> 启动，可以看到日志。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:~$ clash</span><br><span class="line">INFO[0000] Can&#x27;t find config, create a initial config file </span><br><span class="line">INFO[0000] Can&#x27;t find MMDB, start download              </span><br><span class="line">INFO[0003] Mixed(http+socks) proxy listening at: 127.0.0.1:7890</span><br></pre></td></tr></table></figure>

<p>在第一次启动 Clash 时，Clash 会在 <code>~/.config</code> 下创建目录 clash，并在其中创建 3 个文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:~/.config/clash$ ls</span><br><span class="line">cache.db  config.yaml  Country.mmdb</span><br></pre></td></tr></table></figure>
<p>其中 config.yaml 是 Clash 的配置文件，Country.mmdb 是全球 IP 库，可以实现各个国家的 IP 信息解析和地理定位。<br>config.yaml 的内容直接从已有的配置文件复制过来。</p>
<p>可以浏览器访问 <a href="http://clash.razord.top/#/proxies">http://clash.razord.top/#/proxies</a> 选择代理服务器。</p>
<h2 id="设置-Clash-为后台服务"><a href="#设置-Clash-为后台服务" class="headerlink" title="设置 Clash 为后台服务"></a>设置 Clash 为后台服务</h2><p>参考官方文档 <a href="https://dreamacro.github.io/clash/introduction/service.html">Clash as a service</a>。</p>
<p>拷贝配置文件到 <code>/etc/clash</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:~/.config/clash$ sudo cp config.yaml /etc/clash/</span><br><span class="line">:~/.config/clash$ sudo cp Country.mmdb /etc/clash/</span><br></pre></td></tr></table></figure>

<p>在 <code>/etc/systemd/system/clash.service</code> 创建 systemd 配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Clash daemon, A rule-based proxy in Go.</span><br><span class="line">After=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">Restart=always </span><br><span class="line">ExecStart=/usr/local/bin/clash -d /etc/clash</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<p>之后重载 systemd：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure>

<p>设置系统开机时启动 clashd：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable clash</span><br></pre></td></tr></table></figure>

<p>马上启动 clashd：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start clash</span><br></pre></td></tr></table></figure>

<p>检查 Clash 的健康状态和日志：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl status clash</span><br><span class="line">journalctl -xe</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>clash</tag>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Windows 10 上安装 OpenVPN 服务器</title>
    <url>/2023/06/07/how-to-setup-OpenVPN-server-on-windows-10/</url>
    <content><![CDATA[<h2 id="安装-OpenVPN-server"><a href="#安装-OpenVPN-server" class="headerlink" title="安装 OpenVPN server"></a>安装 OpenVPN server</h2><p>从 <a href="https://openvpn.net/community-downloads/">OpenVPN 社区</a> 下载 Windows 64-bit MSI installer。本次安装的版本为 OpenVPN 2.6.4。</p>
<blockquote>
<p>注意事项：在选择安装类型时选择 Customize 而不要选择 Install Now。额外勾选 OpenVPN -&gt; OpenVPN Service -&gt; Entire feature will be installed on local hard drive 和 OpenSSL Utilities -&gt; EasyRSA 3 Certificate Management Scripts -&gt; Entire feature will be installed on local hard drive。</p>
</blockquote>
<p>安装完毕后，会弹出一条消息提示未找到可读的连接配置文件，暂时忽略。<br>此时在 控制面板\网络和 Internet\网络连接 中可以看到创建了两个新的网络适配器 OpenVPN TAP-Windows6 和 OpenVPN Wintun。</p>
<h2 id="配置-OpenVPN-server"><a href="#配置-OpenVPN-server" class="headerlink" title="配置 OpenVPN server"></a>配置 OpenVPN server</h2><p>打开 Windows 10 终端程序。<br>进入 OpenVPN 默认安装目录中的 easy-rsa 目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd &#x27;C:\Program Files\OpenVPN\easy-rsa&#x27;</span><br></pre></td></tr></table></figure>
<p>执行命令进入 Easy-RSA 3 Shell</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.\EasyRSA-Start.bat</span><br></pre></td></tr></table></figure>
<p>初始化公钥基础设施目录 pki</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./easyrsa init-pki</span><br></pre></td></tr></table></figure>
<p>构建证书颁发机构（CA）密钥，CA 根证书文件将在后续用于对其他证书和密钥进行签名。该命令要求输入 Common Name，输入主机名即可。创建的 ca.crt 保存在目录 <code>C：\Program Files\OpenVPN\easy-rsa\pki</code> 中，ca.key 保存在目录 <code>C：\Program Files\OpenVPN\easy-rsa\pki\private</code> 中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./easyrsa build-ca nopass</span><br></pre></td></tr></table></figure>
<p>构建服务器证书和密钥。创建的 server.crt 保存在目录 <code>C：\Program Files\OpenVPN\easy-rsa\pki\issued</code> 中，server.key 保存在目录 <code>C：\Program Files\OpenVPN\easy-rsa\pki\private</code> 中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./easyrsa build-server-full server nopass</span><br></pre></td></tr></table></figure>
<p>构建客户端证书和密钥。创建的 client.crt 保存在目录 <code>C：\Program Files\OpenVPN\easy-rsa\pki\issued</code> 中，client.key 保存在目录 <code>C：\Program Files\OpenVPN\easy-rsa\pki\private</code> 中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./easyrsa build-client-full client nopass</span><br></pre></td></tr></table></figure>
<p>生成 Diffie-Hellman 参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./easyrsa gen-dh</span><br></pre></td></tr></table></figure>
<p>从目录 <code>C：\Program Files\OpenVPN\sample-config</code> 复制服务端配置文件模板 server.ovpn 到目录 <code>C：\Program Files\OpenVPN\config</code> 中，修改以下配置：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">port 1194</span><br><span class="line">dh dh.pem</span><br><span class="line">duplicate-cn</span><br><span class="line"><span class="comment">;tls-auth ta.key 0</span></span><br></pre></td></tr></table></figure>
<p>端口号按需修改，默认为1194，需要保证 OpenVPN 的网络流量可以通过防火墙，设置 Windows 10 Defender 允许 OpenVPN 通过即可。dh2048.pem 修改为生成的文件名 dh.pem。取消注释 duplicate-cn，让多个客户端使用同一个客户端证书。注释掉 tls-auth ta.key 0。复制 ca.crt，dh.pem，server.crt 和 server.key 到目录 C：\Program Files\OpenVPN\config 中。</p>
<h2 id="启动与连接"><a href="#启动与连接" class="headerlink" title="启动与连接"></a>启动与连接</h2><p>启动 OpenVPN，点击连接，系统提示分配 IP 10.8.0.1。按配置，每次 OpenVPN server 都将为自己分配 10.8.0.1。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.eyyyye.com/article/39#menu_3">openvpn安装配置说明(windows系统)</a><br><a href="https://zhuanlan.zhihu.com/p/525197398">如何在Windows 10上安装和配置OpenVPN</a></p>
]]></content>
      <tags>
        <tag>openvpn</tag>
      </tags>
  </entry>
  <entry>
    <title>在 iOS 和 macOS 上安装 OpenVPN 客户端</title>
    <url>/2023/06/07/how-to-setup-OpenVPN-connect-client-on-iOS-and-macOS/</url>
    <content><![CDATA[<h2 id="安装-OpenVPN-Connect"><a href="#安装-OpenVPN-Connect" class="headerlink" title="安装 OpenVPN Connect"></a>安装 OpenVPN Connect</h2><p>macOS 访问<a href="https://openvpn.net/client-connect-vpn-for-mac-os/">官网下载</a>。<br>iOS 访问 <a href="https://itunes.apple.com/us/app/openvpn-connect/id590379981?mt=8">AppStore</a>，需要登录外区 Apple ID。</p>
<h2 id="配置-OpenVPN-Connect"><a href="#配置-OpenVPN-Connect" class="headerlink" title="配置 OpenVPN Connect"></a>配置 OpenVPN Connect</h2><p>客户端提供了两种方式导入配置文件，一是通过 URL，建议 URL 仅限在私有网络内访问，二是通过其他方式例如邮件，下载为本地文件再导入。</p>
<p>配置文件的组织方式又分为两种形式，一种是将 CA 根证书 ca.crt，客户端证书 client.crt，客户端密钥 client.key 的内容复制粘贴到 client.ovpn 中，形成一个联合配置文件；另一种是使用 openssl 将 CA 根证书 ca.crt，客户端证书 client.crt，客户端密钥 client.key 转换为 PKCS#12 文件，先后导入 client.ovpn12 和 client.ovpn。</p>
<h3 id="单一-client-ovpn"><a href="#单一-client-ovpn" class="headerlink" title="单一 client.ovpn"></a>单一 client.ovpn</h3><p>从目录 <code>C：\Program Files\OpenVPN\sample-config</code> 复制客户端配置文件模板 client.ovpn，修改以下配置：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">remote your-server 1194</span><br><span class="line"></span><br><span class="line"><span class="comment">;ca ca.crt</span></span><br><span class="line"><span class="comment">;cert client.crt</span></span><br><span class="line"><span class="comment">;key client.key</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;tls-auth ta.key 1</span></span><br><span class="line"></span><br><span class="line">&lt;ca&gt;</span><br><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line">paste contents of ca.crt</span><br><span class="line">-----END CERTIFICATE-----</span><br><span class="line">&lt;/ca&gt;</span><br><span class="line">&lt;cert&gt;</span><br><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line">paste contents of client.crt</span><br><span class="line">-----END CERTIFICATE-----</span><br><span class="line">&lt;/cert&gt;</span><br><span class="line">&lt;key&gt;</span><br><span class="line">-----BEGIN PRIVATE KEY-----</span><br><span class="line">paste contents of client.key</span><br><span class="line">-----END PRIVATE KEY-----</span><br><span class="line">&lt;/key&gt;</span><br></pre></td></tr></table></figure>
<p>将 <code>remote your-server 1194</code> 中的地址和端口替换成你的 OpenVPN server 的地址和端口。将 <code>ca ca.crt</code>， <code>cert client.crt</code>， <code>key client.key</code>， <code>tls-auth ta.key 1</code> 注释掉，将各自文件中的内容以上述类 XML 的形式粘贴到 client.ovpn 中。</p>
<p>将修改好的客户端配置文件导入到客户端中即可。</p>
<h3 id="client-ovpn-client-opvn12"><a href="#client-ovpn-client-opvn12" class="headerlink" title="client.ovpn + client.opvn12"></a>client.ovpn + client.opvn12</h3><p>使用 openssl 命令将客户端的证书和私钥文件转换为 PKCS#12 形式的文件。该命令会提示 <code>Enter Export Password</code>，可以为空，但为了安全建议设置密码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl pkcs12 -export -in cert -inkey key -certfile ca -name MyClient -out client.ovpn12</span><br></pre></td></tr></table></figure>
<p>由于在 iOS 中导入 PKCS#12 文件到 Keychain 中时只导入了客户端证书和密钥，CA 根证书并没有导入，client.ovpn 文件中必须要保留 CA 根证书的配置。<br>既可以用传统的引用文件的方式：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">ca ca.crt</span><br></pre></td></tr></table></figure>
<p>也可以用类 XML 的形式粘贴 ca.crt 内容到 client.ovpn 中：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">&lt;ca&gt;</span><br><span class="line">paste contents of ca.crt here</span><br><span class="line">&lt;/ca&gt;</span><br></pre></td></tr></table></figure>
<p>先导入 client.ovpn12（需要输入转换时的密码），再导入 client.ovpn。</p>
<blockquote>
<p>但是我失败了……导入 client.ovpn12 时密码一直错误，搜索到类似的案例，但是没有找到解决方案。不确定是不是 openssl 版本引起的。</p>
</blockquote>
<h2 id="路由器-NAT"><a href="#路由器-NAT" class="headerlink" title="路由器 NAT"></a>路由器 NAT</h2><p>在路由器管理后台的 NAT 设置功能里，配置好对外端口号和 Windows 10 主机上 OpenVPN 端口号的映射关系。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://openvpn.net/vpn-server-resources/faq-regarding-openvpn-connect-ios/">iOS 使用 OpenVPN 的 FAQ</a><br><a href="https://openvpn.net/faq/how-do-i-use-a-client-certificate-and-private-key-from-the-ios-keychain/">如何通过 iOS Keychain 使用客户端证书和密钥</a><br><a href="https://help.endian.com/hc/en-us/articles/360008350974-How-to-configure-iOS-OpenVPN-client-with-certificate-authentication">如何配置 iOS OpenVPN 客户端的证书认证</a></p>
]]></content>
      <tags>
        <tag>openvpn</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 OpenVPN 访问家庭内网</title>
    <url>/2023/06/07/how-to-use-OpenVPN-to-access-home-network/</url>
    <content><![CDATA[<h2 id="网络概况"><a href="#网络概况" class="headerlink" title="网络概况"></a>网络概况</h2><p>宽带是电信宽带，分配了动态的公网 IP。<br>光猫使用桥接模式，通过路由器拨号上网（PPPoE），路由器局域网为 192.168.3.0&#x2F;24。<br>一台 Windows 10 主机，在路由器局域网上的 IP 192.168.3.120。。<br>Windows 10 主机上运行 Vmware 虚拟机，网络采用 NAT 模式。子网为 192.168.46.0&#x2F;24。运行了 Linux 主机，IP 192.168.46.128。Windows 10 主机在子网中的 IP 为 192.168.3.1。</p>
<table>
<thead>
<tr>
<th>子网</th>
<th>Windows 10 主机</th>
<th>Linux 主机</th>
<th>客户端</th>
</tr>
</thead>
<tbody><tr>
<td>路由器 192.168.3.0&#x2F;24</td>
<td>192.168.3.120</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>Vmware NAT 192.168.46.0&#x2F;24</td>
<td>192.168.46.1</td>
<td>192.168.46.128</td>
<td>-</td>
</tr>
<tr>
<td>VPN 10.8.0.0&#x2F;24</td>
<td>10.8.0.1</td>
<td>-</td>
<td>10.8.0.6</td>
</tr>
</tbody></table>
<h2 id="目标和考虑因素"><a href="#目标和考虑因素" class="headerlink" title="目标和考虑因素"></a>目标和考虑因素</h2><ol>
<li>能从公网访问家庭内网，包括 Windows 10 主机和虚拟机上的 Linux 主机。</li>
<li>不想通过路由器的 NAT 功能直接将路由器局域网上的设备映射到公网。一是为了安全，二是为了避免运营商审查。</li>
<li>已经尝试过使用 ZeroTier，将所需设备组建在一个局域网当中，可以作为备选方案。同时不想每次新增设备都安装 ZeroTier。</li>
<li>想利用公网 IP 以及上行带宽尝尝鲜。</li>
<li>想要能直连虚拟机上的 Linux 主机，而不是通过 Vmware 的 NAT 映射。不想每次新增服务都要设置 NAT，修改 Windows Defender 的规则。</li>
</ol>
<h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><h3 id="在-Windows-10-上安装-OpenVPN-服务器"><a href="#在-Windows-10-上安装-OpenVPN-服务器" class="headerlink" title="在 Windows 10 上安装 OpenVPN 服务器"></a>在 Windows 10 上安装 OpenVPN 服务器</h3><p>见<a href="/2023/06/07/how-to-setup-OpenVPN-server-on-windows-10/" title="在 Windows 10 上安装 OpenVPN 服务器">在 Windows 10 上安装 OpenVPN 服务器</a>。</p>
<h3 id="在-iOS-和-macOS-上安装-OpenVPN-客户端"><a href="#在-iOS-和-macOS-上安装-OpenVPN-客户端" class="headerlink" title="在 iOS 和 macOS 上安装 OpenVPN 客户端"></a>在 iOS 和 macOS 上安装 OpenVPN 客户端</h3><p>见<a href="/2023/06/07/how-to-setup-OpenVPN-connect-client-on-iOS-and-macOS/" title="在 iOS 和 macOS 上安装 OpenVPN 客户端">在 iOS 和 macOS 上安装 OpenVPN 客户端</a>。</p>
<h3 id="客户端访问服务端其他的私有子网"><a href="#客户端访问服务端其他的私有子网" class="headerlink" title="客户端访问服务端其他的私有子网"></a>客户端访问服务端其他的私有子网</h3><p>如果在所需的每一个设备上都安装 OpenVPN，将它们连接在 VPN 的子网 10.8.0.0&#x2F;24 中，也是可以满足需求的，但是这和每个设备都安装 ZeroTier 差不多。</p>
<h4 id="server-ovpn-新增配置"><a href="#server-ovpn-新增配置" class="headerlink" title="server.ovpn 新增配置"></a>server.ovpn 新增配置</h4><p>在 <code>server.ovpn</code> 配置文件中新增一行配置，这个配置的意思是将该路由配置统一推送给客户端，让它们可以访问服务端的其他私有子网。相当于将服务端的其他私有子网的情况告知客户端，这样客户端就知道发往 192.168.46.128 的 Packet 是发向哪里的。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">push &quot;route 192.168.46.0 255.255.255.0&quot;</span><br></pre></td></tr></table></figure>

<h4 id="打开-Windows-10-主机的路由转发功能"><a href="#打开-Windows-10-主机的路由转发功能" class="headerlink" title="打开 Windows 10 主机的路由转发功能"></a>打开 Windows 10 主机的路由转发功能</h4><ol>
<li><code>Win + R</code> 输入 regedit 打开注册表。</li>
<li>找到 <code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters</code>，修改 <code>IPEnableRouter</code> 为 1。</li>
<li>重启</li>
</ol>
<h4 id="为虚拟机上的-Linux-主机新增路由"><a href="#为虚拟机上的-Linux-主机新增路由" class="headerlink" title="为虚拟机上的 Linux 主机新增路由"></a>为虚拟机上的 Linux 主机新增路由</h4><p>在终端中输入命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">route add -net 10.8.0.0/24 gw 192.168.46.1</span><br></pre></td></tr></table></figure>
<p>这是为了让 OpenVPN 服务端的其他私有子网上的设备知道来自 10.8.0.0&#x2F;24 的 IP Packet 应该路由回 OpenVPN 服务端。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.51cto.com/richie/389636">透过openvpn来访问内网资源</a><br><a href="https://limbo.moe/posts/2018/openvpn-routes">OpenVPN 路由详解</a><br><a href="https://qastack.cn/superuser/865302/yet-another-routing-issue-in-openvpn-cannot-access-local-machines-while-on-vpn">OpenVPN中的另一个路由问题 - 在VPN上无法访问本地计算机</a><br><a href="https://www.nixops.me/articles/openvpn-add-local-routing-table.html">openvpn添加本地路由表</a><br><a href="https://blog.csdn.net/qq_43615820/article/details/113660623">windows开启路由转发</a><br><a href="https://www.cnblogs.com/snake-hand/p/3143041.html">linux route命令的使用详解</a><br><a href="https://blog.csdn.net/bcbobo21cn/article/details/52548923">Windows命令行route命令使用图解</a></p>
]]></content>
      <tags>
        <tag>openvpn</tag>
      </tags>
  </entry>
  <entry>
    <title>如何为终端、docker 和容器设置代理</title>
    <url>/2023/06/13/how-to-configure-proxy-for-terminal-docker-and-container/</url>
    <content><![CDATA[<p>在 <a href="/2023/05/27/how-to-install-clash-on-ubuntu/" title="在 Ubuntu 上安装 Clash">Ubuntu 上安装 Clash</a> 后，Clash 通过监听本地的 7890 端口，提供代理服务。但是不同程序设置代理的方式不尽相同，并不是启动了 Clash 以及在某一处设置后，整个系统发出的 HTTP 请求都能经过代理。本文将介绍如何为终端、docker 和容器添加代理。</p>
<h2 id="为终端设置代理"><a href="#为终端设置代理" class="headerlink" title="为终端设置代理"></a>为终端设置代理</h2><p>有时候，我们需要在终端通过执行命令的方式访问网络和下载资源，比如使用 <code>wget</code> 和 <code>curl</code>。</p>
<h3 id="设置-Shell-环境变量"><a href="#设置-Shell-环境变量" class="headerlink" title="设置 Shell 环境变量"></a>设置 Shell 环境变量</h3><p>这一类软件都是可以通过为 Shell 设置环境变量的方式来设置代理，涉及到的环境变量有 <code>http_proxy</code>、<code>https_proxy</code> 和 <code>no_proxy</code>。<br>仅为当前会话设置，执行命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export http_proxy=http://proxyAddress:port</span><br><span class="line">export https_proxy=http://proxyAddress:port</span><br><span class="line">export no_proxy=localhost,127.0.0.1</span><br></pre></td></tr></table></figure>
<p>永久设置代理，在设置 Shell 环境变量的脚本中（不同 Shell 的配置文件不同，比如 <code>~/.bashrc</code> 或 <code>~/.zshrc</code>）添加：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export http_proxy=http://proxyAddress:port</span><br><span class="line">export https_proxy=http://proxyAddress:port</span><br><span class="line">export no_proxy=localhost,127.0.0.1</span><br></pre></td></tr></table></figure>
<p>重新启动一个会话或者执行命令 <code>source ~/.bashrc</code> 使其在当前会话立即生效。</p>
<h3 id="修改-wget-配置文件"><a href="#修改-wget-配置文件" class="headerlink" title="修改 wget 配置文件"></a>修改 wget 配置文件</h3><p>在搜索过程中发现还可以在 <code>wget</code> 的配置文件 <code>~/.wgetrc</code> 中添加:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">use_proxy = on</span><br><span class="line"></span><br><span class="line">http_proxy = http://proxyAddress:port</span><br><span class="line">https_proxy = http://proxyAddress:port</span><br></pre></td></tr></table></figure>

<h2 id="为-docker-设置代理"><a href="#为-docker-设置代理" class="headerlink" title="为 docker 设置代理"></a>为 docker 设置代理</h2><p>如果你以为为终端设置代理后 docker 就会使用代理，那你就错了。在从官方的镜像仓库 pull 镜像反复出错后并收到类似 <code>Error response from daemon: Get &quot;https://registry-1.docker.io/v2/&quot;: read tcp 192.168.3.140:59460-&gt;44.205.64.79:443: read: connection reset by peer</code> 这样的报错信息后，我才开始怀疑我并没有真正给 docker 设置好代理。<br>在执行 <code>docker pull</code> 命令时，实际上命令是由守护进程 <code>docker daemon</code> 执行的。</p>
<h3 id="通过-systemd-设置"><a href="#通过-systemd-设置" class="headerlink" title="通过 systemd 设置"></a>通过 systemd 设置</h3><p>如果你的 <code>docker daemon</code> 是通过 <code>systemd</code> 管理的，那么你可以通过设置 <code>docker.service</code> 服务的环境变量来设置代理。<br>执行命令查看 <code>docker.service</code> 信息，得知配置文件位置 <code>/lib/systemd/system/docker.service</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">systemctl status docker.service</span> </span><br><span class="line">● docker.service - Docker Application Container Engine</span><br><span class="line">     Loaded: loaded (/lib/systemd/system/docker.service; enabled; vendor preset: enabled)</span><br><span class="line">     Active: active (running) since Tue 2023-06-13 00:52:54 CST; 22h ago</span><br><span class="line">TriggeredBy: ● docker.socket</span><br><span class="line">       Docs: https://docs.docker.com</span><br><span class="line">   Main PID: 387690 (dockerd)</span><br><span class="line">      Tasks: 139</span><br><span class="line">     Memory: 89.6M</span><br><span class="line">        CPU: 1min 26.512s</span><br><span class="line">     CGroup: /system.slice/docker.service</span><br></pre></td></tr></table></figure>
<p>在 <code>docker.service</code> 的 <code>[Service]</code> 模块添加：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Environment=HTTP_PROXY=http://proxyAddress:port</span><br><span class="line">Environment=HTTPS_PROXY=http://proxyAddress:port</span><br><span class="line">Environment=NO_PROXY=localhost,127.0.0.1</span><br></pre></td></tr></table></figure>
<p>重新加载配置文件并重启服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker.service</span><br></pre></td></tr></table></figure>

<h3 id="修改-dockerd-配置文件"><a href="#修改-dockerd-配置文件" class="headerlink" title="修改 dockerd 配置文件"></a>修改 dockerd 配置文件</h3><p>还可以修改 <code>dockerd</code> 配置文件，添加：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export http_proxy=&quot;http://proxyAddress:port&quot;</span><br></pre></td></tr></table></figure>
<p>然后重启 <code>docker daemon</code> 即可。</p>
<blockquote>
<p>国内的镜像仓库在绝大多数时候都可以满足条件，但是存在个别镜像同步不及时的情况，如果使用 latest 标签拉取到的镜像并非近期的镜像，因此有时候需要直接从官方镜像仓库拉取镜像。</p>
</blockquote>
<h2 id="为-docker-容器设置代理"><a href="#为-docker-容器设置代理" class="headerlink" title="为 docker 容器设置代理"></a>为 docker 容器设置代理</h2><p>为 <code>docker daemon</code> 进程设置代理和为 docker 容器设置代理是有区别的。比如使用 docker 启动媒体服务器 jellyfin 后，jellyfin 的刮削功能就需要代理才能正常使用，这时候不要因为在很多地方设置过代理就以为容器内部已经在使用代理了。</p>
<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>创建或修改 <code>~/.docker/config.json</code>，添加：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;proxies&quot;</span><span class="punctuation">:</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;default&quot;</span><span class="punctuation">:</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;httpProxy&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://proxyAddress:port&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;httpsProxy&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://proxyAddress:port&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;noProxy&quot;</span><span class="punctuation">:</span> <span class="string">&quot;localhost,127.0.0.1&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>此后创建的新容器，会自动设置环境变量来使用代理。</p>
<h3 id="为指定容器添加环境变量"><a href="#为指定容器添加环境变量" class="headerlink" title="为指定容器添加环境变量"></a>为指定容器添加环境变量</h3><p>在启动容器时使用 <code>-e</code> 手动注入环境变量 <code>http_proxy</code>。这意味着进入容器使用 <code>export</code> 设置环境变量的方式也是可行的。</p>
<blockquote>
<p>注意：如果代理是使用宿主机的代理，当网络为 <code>bridge</code> 模式，proxyAddress 需要填写宿主机的 IP；如果使用 <code>host</code> 模式，proxyAddress 可以填写 127.0.0.1。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不要因为在很多地方设置过代理，就想当然地以为当前的访问也是经过代理的。每个软件设置代理的方式不尽相同，但是大体上可以归结为：</p>
<ol>
<li>使用系统的环境变量</li>
<li>修改软件的配置文件</li>
<li>执行时注入参数</li>
</ol>
<p>举一反三，像 <code>apt</code> 和 <code>git</code> 这类软件也是有其设置代理的方法。当你的代理稳定但是相应的访问失败时，大胆假设你的代理没有设置成功。要理清楚，当前的访问是谁发起的，才能正确地使用关键词搜索到正确的设置方式。</p>
<blockquote>
<p>原本我在 docker 相关的使用中，有关代理的设置方式是通过修改配置文件，实现永久、全局的代理配置。但是在后续的使用中，发现代理在一些场景（比如使用 cloudflare tunnel）中会引起不易排查的问题，决定采用临时、局部的配置方式。</p>
</blockquote>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://zhuanlan.zhihu.com/p/46973701">Linux 让终端走代理的几种方法</a><br><a href="https://blog.51cto.com/u_14814563/5415887">Linux ❀ wget设置代理</a><br><a href="https://cloud-atlas.readthedocs.io/zh_CN/latest/docker/network/docker_proxy.html#docker-server-proxy">配置Docker使用代理</a><br><a href="https://note.qidong.name/2020/05/docker-proxy/">Docker的三种网络代理配置</a><br><a href="https://neucrack.com/p/286">docker 设置代理，以及国内加速镜像设置</a></p>
]]></content>
      <tags>
        <tag>docker</tag>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu server 20.04 安装后没有分配全部磁盘空间</title>
    <url>/2023/06/24/Ubuntu-server-20-04-not-all-disk-space-was-allocated-after-installation/</url>
    <content><![CDATA[<p>最近在本地测试 Kubesphere 和 Minikube，使用 Ubuntu server 20.04 搭建了多个虚拟机，磁盘空间紧张。注意到安装后，磁盘空间仅占据分配的一半左右。<br>如果 Ubuntu server 20.04 安装时使用默认的 lvm 选项，就会出现这种情况。</p>
<p>分配了 40GB 磁盘空间，可用仅 19GB。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">df</span> -h</span></span><br><span class="line">Filesystem                         Size  Used Avail Use% Mounted on</span><br><span class="line">udev                               3.9G     0  3.9G   0% /dev</span><br><span class="line">tmpfs                              792M  7.5M  785M   1% /run</span><br><span class="line">/dev/mapper/ubuntu--vg-ubuntu--lv   19G   17G  995M  95% /</span><br><span class="line">tmpfs                              3.9G     0  3.9G   0% /dev/shm</span><br><span class="line">tmpfs                              5.0M     0  5.0M   0% /run/lock</span><br><span class="line">tmpfs                              3.9G     0  3.9G   0% /sys/fs/cgroup</span><br><span class="line">/dev/sda2                          2.0G  108M  1.7G   6% /boot</span><br><span class="line">/dev/loop0                          64M   64M     0 100% /snap/core20/1828</span><br><span class="line">/dev/loop2                          50M   50M     0 100% /snap/snapd/18357</span><br><span class="line">/dev/loop1                          92M   92M     0 100% /snap/lxd/24061</span><br><span class="line">tmpfs                              792M     0  792M   0% /run/user/1000</span><br><span class="line">/dev/loop3                          54M   54M     0 100% /snap/snapd/19457</span><br></pre></td></tr></table></figure>

<p>查看发现 Free  PE &#x2F; Size 还有 19GB。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo vgdisplay</span></span><br><span class="line">  --- Volume group ---</span><br><span class="line">  VG Name               ubuntu-vg</span><br><span class="line">  System ID             </span><br><span class="line">  Format                lvm2</span><br><span class="line">  Metadata Areas        1</span><br><span class="line">  Metadata Sequence No  2</span><br><span class="line">  VG Access             read/write</span><br><span class="line">  VG Status             resizable</span><br><span class="line">  MAX LV                0</span><br><span class="line">  Cur LV                1</span><br><span class="line">  Open LV               1</span><br><span class="line">  Max PV                0</span><br><span class="line">  Cur PV                1</span><br><span class="line">  Act PV                1</span><br><span class="line">  VG Size               &lt;38.00 GiB</span><br><span class="line">  PE Size               4.00 MiB</span><br><span class="line">  Total PE              9727</span><br><span class="line">  Alloc PE / Size       4863 / &lt;19.00 GiB</span><br><span class="line">  Free  PE / Size       4864 / 19.00 GiB</span><br><span class="line">  VG UUID               NuEjzH-CKXm-W6lA-gqzj-4bds-IR1Y-dTZ8IP</span><br></pre></td></tr></table></figure>

<p>重新分配空间。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo lvextend -l +100%FREE /dev/mapper/ubuntu--vg-ubuntu--lv</span></span><br><span class="line">Size of logical volume ubuntu-vg/ubuntu-lv changed from &lt;19.00 GiB (4863 extents) to &lt;38.00 GiB (9727 extents).</span><br><span class="line">Logical volume ubuntu-vg/ubuntu-lv successfully resized.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo resize2fs /dev/mapper/ubuntu--vg-ubuntu--lv</span></span><br><span class="line">resize2fs 1.45.5 (07-Jan-2020)</span><br><span class="line">Filesystem at /dev/mapper/ubuntu--vg-ubuntu--lv is mounted on /; on-line resizing required</span><br><span class="line">old_desc_blocks = 3, new_desc_blocks = 5</span><br><span class="line">The filesystem on /dev/mapper/ubuntu--vg-ubuntu--lv is now 9960448 (4k) blocks long.</span><br></pre></td></tr></table></figure>

<p>再次查看。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">df -h</span><br><span class="line">Filesystem                         Size  Used Avail Use% Mounted on</span><br><span class="line">udev                               3.9G     0  3.9G   0% /dev</span><br><span class="line">tmpfs                              792M  7.5M  785M   1% /run</span><br><span class="line">/dev/mapper/ubuntu--vg-ubuntu--lv   38G   17G   19G  47% /</span><br><span class="line">tmpfs                              3.9G     0  3.9G   0% /dev/shm</span><br><span class="line">tmpfs                              5.0M     0  5.0M   0% /run/lock</span><br><span class="line">tmpfs                              3.9G     0  3.9G   0% /sys/fs/cgroup</span><br><span class="line">/dev/sda2                          2.0G  108M  1.7G   6% /boot</span><br><span class="line">/dev/loop0                          64M   64M     0 100% /snap/core20/1828</span><br><span class="line">/dev/loop2                          50M   50M     0 100% /snap/snapd/18357</span><br><span class="line">/dev/loop1                          92M   92M     0 100% /snap/lxd/24061</span><br><span class="line">tmpfs                              792M     0  792M   0% /run/user/1000</span><br><span class="line">/dev/loop3                          54M   54M     0 100% /snap/snapd/19457</span><br><span class="line">/dev/loop4                          64M   64M     0 100% /snap/core20/1950</span><br></pre></td></tr></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/weixin_43302340/article/details/120341241">ubuntu20.04 server 安装后磁盘空间只有一半的处理</a><br><a href="https://askubuntu.com/questions/1269493/ubuntu-server-20-04-1-lts-not-all-disk-space-was-allocated-during-installation">Ubuntu Server 20.04.1 LTS, not all disk space was allocated during installation?</a></p>
]]></content>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在 Ubuntu 20.04 上安装 Minikube</title>
    <url>/2023/06/23/how-to-install-Minikube-on-Ubuntu-20-04/</url>
    <content><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="安装-Ubuntu-20-04"><a href="#安装-Ubuntu-20-04" class="headerlink" title="安装 Ubuntu 20.04"></a>安装 Ubuntu 20.04</h3><p>使用 Vmware Workstation 通过 <code>ubuntu-20.04.6-live-server-amd64.iso</code> 安装。需要满足条件如下：</p>
<ul>
<li>2 个或更多 CPU（2 CPU）。</li>
<li>2GB 可用内存（4GB）。</li>
<li>20GB 可用磁盘空间（30GB）。</li>
<li>网络连接</li>
<li>容器或虚拟机管理器（Docker）。</li>
</ul>
<h3 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h3><p>参考官方文档：<a href="https://docs.docker.com/engine/install/ubuntu/">Install Docker Engine on Ubuntu</a>。</p>
<h3 id="安装-Minikube"><a href="#安装-Minikube" class="headerlink" title="安装 Minikube"></a>安装 Minikube</h3><p>参考官方文档：<a href="https://minikube.sigs.k8s.io/docs/start/">minikube start</a>。</p>
<h3 id="安装-kubectl-并启动-kubectl-自动补全功能"><a href="#安装-kubectl-并启动-kubectl-自动补全功能" class="headerlink" title="安装 kubectl 并启动 kubectl 自动补全功能"></a>安装 kubectl 并启动 kubectl 自动补全功能</h3><p>参考官方文档：<a href="https://kubernetes.io/zh-cn/docs/tasks/tools/install-kubectl-linux/">在 Linux 系统中安装并设置 kubectl</a>。</p>
<h3 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h3><p>创建集群：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube start</span><br></pre></td></tr></table></figure>

<h4 id="创建集群时的权限问题"><a href="#创建集群时的权限问题" class="headerlink" title="创建集群时的权限问题"></a>创建集群时的权限问题</h4><h5 id="不加-sudo"><a href="#不加-sudo" class="headerlink" title="不加 sudo"></a>不加 sudo</h5><p>不加 <code>sudo</code> 的时候，创建集群失败，提示无法选择默认 driver。可能是 docker 处于不健康状态或者用户权限不足。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ minikube start</span><br><span class="line">* minikube v1.30.1 on Ubuntu 20.04</span><br><span class="line">* Unable to pick a default driver. Here is what was considered, in preference order:</span><br><span class="line">  - docker: Not healthy: &quot;docker version --format &#123;&#123;.Server.Os&#125;&#125;-&#123;&#123;.Server.Version&#125;&#125;:&#123;&#123;.Server.Platform.Name&#125;&#125;&quot; exit status 1: permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get &quot;http://%2Fvar%2Frun%2Fdocker.sock/v1.24/version&quot;: dial unix /var/run/docker.sock: connect: permission denied</span><br><span class="line">  - docker: Suggestion: Add your user to the &#x27;docker&#x27; group: &#x27;sudo usermod -aG docker $USER &amp;&amp; newgrp docker&#x27; &lt;https://docs.docker.com/engine/install/linux-postinstall/&gt;</span><br><span class="line">* Alternatively you could install one of these drivers:</span><br><span class="line">  - kvm2: Not installed: exec: &quot;virsh&quot;: executable file not found in $PATH</span><br><span class="line">  - podman: Not installed: exec: &quot;podman&quot;: executable file not found in $PATH</span><br><span class="line">  - qemu2: Not installed: exec: &quot;qemu-system-x86_64&quot;: executable file not found in $PATH</span><br><span class="line">  - virtualbox: Not installed: unable to find VBoxManage in $PATH</span><br><span class="line"></span><br><span class="line">X Exiting due to DRV_NOT_HEALTHY: Found driver(s) but none were healthy. See above for suggestions how to fix installed drivers.</span><br></pre></td></tr></table></figure>

<h5 id="使用-sudo"><a href="#使用-sudo" class="headerlink" title="使用 sudo"></a>使用 sudo</h5><p>使用 <code>sudo</code> 的时候，会提示不建议通过 <code>root</code> 权限使用 <code>docker</code>，如果还是想要继续，可以使用选项 <code>--force</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo minikube start</span></span><br><span class="line">* minikube v1.30.1 on Ubuntu 20.04</span><br><span class="line">* Automatically selected the docker driver. Other choices: none, ssh</span><br><span class="line">* The &quot;docker&quot; driver should not be used with root privileges. If you wish to continue as root, use --force.</span><br><span class="line">* If you are running minikube within a VM, consider using --driver=none:</span><br><span class="line">*   https://minikube.sigs.k8s.io/docs/reference/drivers/none/</span><br><span class="line"></span><br><span class="line">X Exiting due to DRV_AS_ROOT: The &quot;docker&quot; driver should not be used with root privileges.</span><br></pre></td></tr></table></figure>

<h5 id="使用选项-–force"><a href="#使用选项-–force" class="headerlink" title="使用选项 –force"></a>使用选项 –force</h5><p>考虑到仅用于测试，尝试通过 <code>sudo minikube start --force</code> 启动集群，成功启动集群但是提示使用该选项可能会引发未知行为。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo minikube start --force</span></span><br><span class="line">* minikube v1.30.1 on Ubuntu 20.04</span><br><span class="line">! minikube skips various validations when --force is supplied; this may lead to unexpected behavior</span><br><span class="line">* Automatically selected the docker driver. Other choices: ssh, none</span><br><span class="line">* The &quot;docker&quot; driver should not be used with root privileges. If you wish to continue as root, use --force.</span><br><span class="line">* If you are running minikube within a VM, consider using --driver=none:</span><br><span class="line">*   https://minikube.sigs.k8s.io/docs/reference/drivers/none/</span><br><span class="line">* Using Docker driver with root privileges</span><br><span class="line">* Starting control plane node minikube in cluster minikube</span><br><span class="line">* Pulling base image ...</span><br><span class="line">* Downloading Kubernetes v1.26.3 preload ...</span><br><span class="line">    &gt; preloaded-images-k8s-v18-v1...:  397.02 MiB / 397.02 MiB  100.00% 25.89 M</span><br><span class="line">    &gt; index.docker.io/kicbase/sta...:  373.53 MiB / 373.53 MiB  100.00% 7.17 Mi</span><br><span class="line">! minikube was unable to download gcr.io/k8s-minikube/kicbase:v0.0.39, but successfully downloaded docker.io/kicbase/stable:v0.0.39 as a fallback image</span><br><span class="line">* Creating docker container (CPUs=2, Memory=2200MB) ...</span><br><span class="line">* Preparing Kubernetes v1.26.3 on Docker 23.0.2 ...</span><br><span class="line">  - Generating certificates and keys ...</span><br><span class="line">  - Booting up control plane ...</span><br><span class="line">  - Configuring RBAC rules ...</span><br><span class="line">* Configuring bridge CNI (Container Networking Interface) ...</span><br><span class="line">  - Using image gcr.io/k8s-minikube/storage-provisioner:v5</span><br><span class="line">* Verifying Kubernetes components...</span><br><span class="line">* Enabled addons: default-storageclass, storage-provisioner</span><br><span class="line">* Done! kubectl is now configured to use &quot;minikube&quot; cluster and &quot;default&quot; namespace by default</span><br></pre></td></tr></table></figure>

<p>成功启动集群后，使用 <code>kubectl get pod</code> 测试，提示连接被拒绝。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pod</span></span><br><span class="line">E0622 21:55:27.400754   18561 memcache.go:265] couldn&#x27;t get current server API group list: Get &quot;http://localhost:8080/api?timeout=32s&quot;: dial tcp 127.0.0.1:8080: connect: connection refused</span><br><span class="line">E0622 21:55:27.401000   18561 memcache.go:265] couldn&#x27;t get current server API group list: Get &quot;http://localhost:8080/api?timeout=32s&quot;: dial tcp 127.0.0.1:8080: connect: connection refused</span><br><span class="line">E0622 21:55:27.410464   18561 memcache.go:265] couldn&#x27;t get current server API group list: Get &quot;http://localhost:8080/api?timeout=32s&quot;: dial tcp 127.0.0.1:8080: connect: connection refused</span><br><span class="line">E0622 21:55:27.410951   18561 memcache.go:265] couldn&#x27;t get current server API group list: Get &quot;http://localhost:8080/api?timeout=32s&quot;: dial tcp 127.0.0.1:8080: connect: connection refused</span><br><span class="line">E0622 21:55:27.412076   18561 memcache.go:265] couldn&#x27;t get current server API group list: Get &quot;http://localhost:8080/api?timeout=32s&quot;: dial tcp 127.0.0.1:8080: connect: connection refused</span><br><span class="line">The connection to the server localhost:8080 was refused - did you specify the right host or port?</span><br></pre></td></tr></table></figure>

<p>使用 <code>minikube dashboard</code> 启动控制台，在访问时同样提示连接被拒绝：<code>dial tcp 127.0.0.1:8080: connect: connection refused</code>。</p>
<p>考虑到可能还有别的问题，决定采用官方建议将用户添加到 <code>docker</code> 用户组。</p>
<h5 id="将用户添加到-docker-用户组"><a href="#将用户添加到-docker-用户组" class="headerlink" title="将用户添加到 docker 用户组"></a>将用户添加到 docker 用户组</h5><p>使用 <code>sudo usermod -aG docker $USER &amp;&amp; newgrp docker</code> 将当前用户添加到 <code>docker</code> 用户组并切换当前用户组到 <code>docker</code> 用户组后，正常启动集群。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">minikube start</span></span><br><span class="line">* minikube v1.30.1 on Ubuntu 20.04</span><br><span class="line">* Automatically selected the docker driver. Other choices: ssh, none</span><br><span class="line">* Using Docker driver with root privileges</span><br><span class="line">* Starting control plane node minikube in cluster minikube</span><br><span class="line">* Pulling base image ...</span><br><span class="line">* Downloading Kubernetes v1.26.3 preload ...</span><br><span class="line">    &gt; preloaded-images-k8s-v18-v1...:  393.36 MiB / 397.02 MiB  99.08% 19.35 Mi! minikube was unable to download gcr.io/k8s-minikube/kicbase:v0.0.39, but successfully downloaded docker.io/kicbase/stable:v0.0.39 as a fallback image</span><br><span class="line">    &gt; preloaded-images-k8s-v18-v1...:  397.02 MiB / 397.02 MiB  100.00% 21.44 M</span><br><span class="line">* Creating docker container (CPUs=2, Memory=2200MB) ...</span><br><span class="line">* Preparing Kubernetes v1.26.3 on Docker 23.0.2 ...</span><br><span class="line">  - Generating certificates and keys ...</span><br><span class="line">  - Booting up control plane ...</span><br><span class="line">  - Configuring RBAC rules ...</span><br><span class="line">* Configuring bridge CNI (Container Networking Interface) ...</span><br><span class="line">  - Using image gcr.io/k8s-minikube/storage-provisioner:v5</span><br><span class="line">* Verifying Kubernetes components...</span><br><span class="line">* Enabled addons: storage-provisioner, default-storageclass</span><br><span class="line">* Done! kubectl is now configured to use &quot;minikube&quot; cluster and &quot;default&quot; namespace by default</span><br></pre></td></tr></table></figure>

<h4 id="创建集群时下载镜像失败"><a href="#创建集群时下载镜像失败" class="headerlink" title="创建集群时下载镜像失败"></a>创建集群时下载镜像失败</h4><p>在解决问题的过程中，发现有人存在下载镜像失败的情况。从启动日志可以看到，由于 minikube 下载 <code>gcr.io/k8s-minikube/kicbase:v0.0.39</code> 镜像失败，自动下载 <code>docker.io/kicbase/stable:v0.0.39</code> 镜像作为备选。如果从 <code>docker.io</code> 下载镜像也很困难，还可以通过指定镜像仓库启动集群。可以通过查看帮助内关于仓库的信息，获取官方建议中国大陆用户使用的镜像仓库地址。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">minikube start --<span class="built_in">help</span> | grep repo</span></span><br><span class="line">    --image-repository=&#x27;&#x27;:</span><br><span class="line">	Alternative image repository to pull docker images from. This can be used when you have limited access to gcr.io. Set it to &quot;auto&quot; to let minikube decide one for you. For Chinese mainland users, you may use local gcr.io mirrors such as registry.cn-hangzhou.aliyuncs.com/google_containers</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">minikube start --image-repository=<span class="string">&#x27;registry.cn-hangzhou.aliyuncs.com/google_containers&#x27;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="如何通过宿主机进行访问-minikube-控制台"><a href="#如何通过宿主机进行访问-minikube-控制台" class="headerlink" title="如何通过宿主机进行访问 minikube 控制台"></a>如何通过宿主机进行访问 minikube 控制台</h4><p>启动控制台：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">minikube dashboard</span></span><br><span class="line">* Enabling dashboard ...</span><br><span class="line">  - Using image docker.io/kubernetesui/dashboard:v2.7.0</span><br><span class="line">  - Using image docker.io/kubernetesui/metrics-scraper:v1.0.8</span><br><span class="line">* Some dashboard features require the metrics-server addon. To enable all features please run:</span><br><span class="line"></span><br><span class="line">	minikube addons enable metrics-server	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* Verifying dashboard health ...</span><br><span class="line">* Launching proxy ...</span><br><span class="line">* Verifying proxy health ...</span><br><span class="line">* Opening http://127.0.0.1:35967/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/ in your default browser...</span><br><span class="line">  http://127.0.0.1:35967/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果虚拟机安装的 Ubuntu 是 Desktop 版本，那么你可以在 Ubuntu 里直接通过浏览器访问。但是如果你安装的 Ubuntu 是 server 版本，除了使用 <code>curl</code> 访问 url 外，你也许想要在宿主机的浏览器访问：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl proxy --port=your-port --address=&#x27;your-virtual-machine-ip&#x27; --accept-hosts=&#x27;^.*&#x27; &amp;</span><br></pre></td></tr></table></figure>

<h4 id="使用过程中下载镜像失败"><a href="#使用过程中下载镜像失败" class="headerlink" title="使用过程中下载镜像失败"></a>使用过程中下载镜像失败</h4><h5 id="从其他镜像仓库下载代替"><a href="#从其他镜像仓库下载代替" class="headerlink" title="从其他镜像仓库下载代替"></a>从其他镜像仓库下载代替</h5><p>一般是在需要从 <code>gcr.io</code> 镜像仓库下载时发生，比如官方教程中需要执行以下命令，会发现 <code>deployment</code> 和 <code>pod</code> 迟迟不能达到目标状态。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl create deployment hello-node --image=registry.k8s.io/e2e-test-images/agnhost:2.39 -- /agnhost netexec --http-port=8080</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get deployments</span></span><br><span class="line">NAME         READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">hello-node   0/1     1            0           19s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods</span></span><br><span class="line">NAME                          READY   STATUS             RESTARTS   AGE</span><br><span class="line">hello-node-7b87cd5f68-zwd4g   0/1     ImagePullBackOff   0          38s</span><br></pre></td></tr></table></figure>
<p>仅作为测试用途，可以从 Docker 官方仓库搜索镜像，找到排名靠前，版本相同或相近的可靠镜像代替。</p>
<h5 id="配置代理"><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h5><p>对于这类网络连接不通的情况，配置代理是通用的解决方案。开始使用后发现从其他镜像仓库下载代替的方法有点麻烦，于是决定设置代理。<br>刚开始我以为给 Ubuntu 上的 <code>dockerd</code> 配置代理帮助加速 <code>docker pull</code> 即可，后来发现仍然下载失败。即使我通过 <code>docker pull</code> 先下载镜像到本地，配置 <code>imagePullPolicy</code> 为 <code>Never</code> 或者 <code>IfNotPresent</code>，minikube 还是不能识别到本地已有的镜像。猜测 minikube 的机制和我想象的是不同的，需要直接为 minikube 容器配置代理。搜索到以下命令满足需求：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube start --docker-env http_proxy=http://proxyAddress:port --docker-env https_proxy=http://proxyAddress:port --docker-env no_proxy=localhost,127.0.0.1,your-virtual-machine-ip/24</span><br></pre></td></tr></table></figure>

<h4 id="需要使用自定义镜像"><a href="#需要使用自定义镜像" class="headerlink" title="需要使用自定义镜像"></a>需要使用自定义镜像</h4><p>测试过程中遇到需要使用自定义镜像的场景。在上一个问题中，我们已经发现 Minikube 不能直接使用本地已有的镜像，但是有两种方法可以解决该问题。</p>
<h5 id="minikube-image-load"><a href="#minikube-image-load" class="headerlink" title="minikube image load"></a>minikube image load</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube image load &lt;IMAGE_NAME&gt;</span><br></pre></td></tr></table></figure>

<h5 id="minikube-image-build"><a href="#minikube-image-build" class="headerlink" title="minikube image build"></a>minikube image build</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minikube image build -t &lt;IMAGE_NAME&gt; .</span><br></pre></td></tr></table></figure>


<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://docs.docker.com/engine/install/ubuntu/">Install Docker Engine on Ubuntu</a><br><a href="https://minikube.sigs.k8s.io/docs/start/">minikube start</a><br><a href="https://zhuanlan.zhihu.com/p/429690423">k8s的迷你版——minikube+docker的安装</a><br><a href="https://stackoverflow.com/questions/68984450/minikube-why-the-docker-driver-should-not-be-used-with-root-privileges">minikube - Why The “docker” driver should not be used with root privileges</a><br><a href="https://www.cnblogs.com/pack27/p/12202687.html">安装Minikube无法访问k8s.gcr.io的简单解决办法</a><br><a href="https://www.cnblogs.com/liyuanhong/p/13799404.html">让其他电脑访问minikube dashboard</a><br><a href="https://blog.csdn.net/qq_43762191/article/details/122709763">【问题解决】This container is having trouble accessing https://k8s.gcr.io | 如何解决从k8s.gcr.io拉取镜像失败问题？</a><br><a href="https://www.cnblogs.com/Leo_wl/p/15775077.html">K8S(kubernetes)镜像源</a><br><a href="https://www.cnblogs.com/goerzh/p/12827588.html">minikube 设置代理</a><br><a href="https://zhuanlan.zhihu.com/p/486384757">两种在Minikube中运行本地Docker镜像的简单方式</a></p>
]]></content>
      <tags>
        <tag>minikube</tag>
      </tags>
  </entry>
  <entry>
    <title>Tmux 常用命令和快捷键</title>
    <url>/2023/06/29/tmux-frequently-used-commands/</url>
    <content><![CDATA[<p>本文记录了 <code>Tmux</code> 常用命令和快捷键作为备忘笔记（好容易忘啊 Orz）。</p>
<span id="more"></span>

<h2 id="Tmux-是什么"><a href="#Tmux-是什么" class="headerlink" title="Tmux 是什么"></a>Tmux 是什么</h2><p><code>Tmux</code> 是一个终端复用器（<code>Terminal Multiplexer</code>），它可以将终端的会话和窗口解绑分离，达到窗口关闭，会话不终止，并且还能使用窗口再次绑定目标会话的效果，从而避免因为网络中断或者窗口关闭导致会话中运行的进程终止。</p>
<p><code>Ubuntu server 20.04</code> 默认已安装 <code>Tmux</code>。如果没有，可以通过以下命令安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install tmux</span></span><br></pre></td></tr></table></figure>

<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h3><h4 id="新建会话"><a href="#新建会话" class="headerlink" title="新建会话"></a>新建会话</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux new -s &lt;session-name&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="分离会话"><a href="#分离会话" class="headerlink" title="分离会话"></a>分离会话</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux detach</span></span><br></pre></td></tr></table></figure>

<h4 id="查看会话列表"><a href="#查看会话列表" class="headerlink" title="查看会话列表"></a>查看会话列表</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux <span class="built_in">ls</span></span></span><br></pre></td></tr></table></figure>

<h4 id="接入会话"><a href="#接入会话" class="headerlink" title="接入会话"></a>接入会话</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux attach -t &lt;session-name&gt;</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux attach -t &lt;session-id&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="杀死会话"><a href="#杀死会话" class="headerlink" title="杀死会话"></a>杀死会话</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux kill-session -t &lt;session-name&gt;</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux kill-session -t &lt;session-id&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="切换会话"><a href="#切换会话" class="headerlink" title="切换会话"></a>切换会话</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux switch -t &lt;session-name&gt;</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux switch -t &lt;session-id&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="重命名会话"><a href="#重命名会话" class="headerlink" title="重命名会话"></a>重命名会话</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux rename-session -t &lt;old&gt; &lt;new&gt;</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux rename-session &lt;new&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="会话快捷键"><a href="#会话快捷键" class="headerlink" title="会话快捷键"></a>会话快捷键</h4><ul>
<li><strong><code>Ctrl+b d</code>：分离当前会话，猜测 detach</strong></li>
<li><strong><code>Ctrl+b s</code>：查看会话列表并选择，session</strong></li>
<li><strong><code>Ctrl+b $</code>：重命名当前会话名称</strong></li>
<li><strong><code>Ctrl+d</code>：关闭当前会话</strong></li>
</ul>
<h3 id="窗口管理"><a href="#窗口管理" class="headerlink" title="窗口管理"></a>窗口管理</h3><h4 id="新建窗口"><a href="#新建窗口" class="headerlink" title="新建窗口"></a>新建窗口</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux new-window -n &lt;window-name&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="关闭窗口"><a href="#关闭窗口" class="headerlink" title="关闭窗口"></a>关闭窗口</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux kill-window -t &lt;window-name&gt;</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux kill-window</span></span><br></pre></td></tr></table></figure>

<h4 id="切换窗口"><a href="#切换窗口" class="headerlink" title="切换窗口"></a>切换窗口</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux select-window -t &lt;window-name&gt;</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux select-window -t &lt;window-id&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="重命名窗口"><a href="#重命名窗口" class="headerlink" title="重命名窗口"></a>重命名窗口</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux rename-window -t &lt;old&gt; &lt;new&gt;</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux rename-window &lt;new&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="窗口快捷键"><a href="#窗口快捷键" class="headerlink" title="窗口快捷键"></a>窗口快捷键</h4><ul>
<li><strong><code>Ctrl+b c</code>：创建一个新窗口，状态栏会显示窗口信息</strong></li>
<li><code>Ctrl+b p</code>：切换到上一个窗口，prev</li>
<li><code>Ctrl+b n</code>：切换到下一个窗口，next</li>
<li><code>Ctrl+b &lt;number&gt;</code>：切换到指定编号的窗口</li>
<li><strong><code>Ctrl+b w</code>：查看窗口列表并选择，window</strong></li>
<li><strong><code>Ctrl+b ,</code>：重命名当前窗口</strong></li>
<li><strong><code>Ctrl+b &amp;</code>：关闭当前窗口</strong></li>
</ul>
<h3 id="窗格管理"><a href="#窗格管理" class="headerlink" title="窗格管理"></a>窗格管理</h3><h4 id="划分窗格"><a href="#划分窗格" class="headerlink" title="划分窗格"></a>划分窗格</h4><p>猜测 vertical，horizontal。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux split-window [-v]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux split-window -h</span></span><br></pre></td></tr></table></figure>
<h4 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h4><p>猜测 upper，down，left，right。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux select-pane -U</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux select-pane -D</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux select-pane -L</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux select-pane -R</span></span><br></pre></td></tr></table></figure>
<h4 id="交换窗格"><a href="#交换窗格" class="headerlink" title="交换窗格"></a>交换窗格</h4><p>当前窗格和上一个或下一个窗格交换位置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux swap-pane -U</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux swap-pane -D</span></span><br></pre></td></tr></table></figure>

<h4 id="窗格快捷键"><a href="#窗格快捷键" class="headerlink" title="窗格快捷键"></a>窗格快捷键</h4><ul>
<li><strong><code>Ctrl+b &quot;</code>：上下划分窗格</strong></li>
<li><strong><code>Ctrl+b %</code>：左右划分窗格</strong></li>
<li><strong><code>Ctrl+b &lt;arrow key&gt;</code>：使用方向键切换窗格</strong></li>
<li><code>Ctrl+b ;</code>：光标切换到上一个窗格</li>
<li><code>Ctrl+b o</code>：光标切换到下一个窗格</li>
<li><code>Ctrl+b &#123;</code>：当前窗格和上一个窗格交换位置</li>
<li><code>Ctrl+b &#125;</code>：当前窗格和下一个窗格交换位置</li>
<li><strong><code>Ctrl+b x</code>：关闭当前窗格</strong></li>
<li><code>Ctrl+b !</code>：将当前窗格拆分为一个独立窗口</li>
<li><code>Ctrl+b z</code>：当前窗格全屏显示，再使用一次会变回原来大小，状态栏会有大写的 Z 标识</li>
<li><code>Ctrl+b q</code>：显示窗格编号</li>
</ul>
<h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><h4 id="进入翻页模式"><a href="#进入翻页模式" class="headerlink" title="进入翻页模式"></a>进入翻页模式</h4><ul>
<li><strong><code>Ctrl+b [</code>：进入翻页模式</strong></li>
<li><code>q</code>：退出翻页模式</li>
</ul>
<h4 id="列出所有快捷键，及其对应的-Tmux-命令"><a href="#列出所有快捷键，及其对应的-Tmux-命令" class="headerlink" title="列出所有快捷键，及其对应的 Tmux 命令"></a>列出所有快捷键，及其对应的 Tmux 命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux list-keys</span></span><br></pre></td></tr></table></figure>

<h4 id="列出所有-Tmux-命令及其参数"><a href="#列出所有-Tmux-命令及其参数" class="headerlink" title="列出所有 Tmux 命令及其参数"></a>列出所有 Tmux 命令及其参数</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux list-commands</span></span><br></pre></td></tr></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html">Tmux 使用教程</a><br><a href="https://blog.csdn.net/weixin_51311218/article/details/122172339">Tmux 学习</a></p>
]]></content>
      <tags>
        <tag>tmux</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用 SSH 连接 Github 和服务器</title>
    <url>/2023/06/28/how-to-use-ssh-to-connect-github-and-server/</url>
    <content><![CDATA[<p>本文介绍了如何使用 <code>SSH</code> 连接 <code>Github</code> 和免密登录服务器作为备忘笔记，主要在新建虚拟机或重装云服务器系统时使用。</p>
<span id="more"></span>

<h2 id="使用-SSH-连接-Github"><a href="#使用-SSH-连接-Github" class="headerlink" title="使用 SSH 连接 Github"></a>使用 SSH 连接 Github</h2><h3 id="检查现有-SSH-密钥"><a href="#检查现有-SSH-密钥" class="headerlink" title="检查现有 SSH 密钥"></a>检查现有 SSH 密钥</h3><p>打开终端，输入 <code>ls -al ~/.ssh</code> 以查看是否存在现有的 <code>SSH</code> 密钥。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -al ~/.ssh</span></span><br><span class="line">total 16</span><br><span class="line">drwx------ 2 moralok moralok 4096 Jun 28 20:19 .</span><br><span class="line">drwxr-xr-x 6 moralok moralok 4096 Jun 28 20:13 ..</span><br><span class="line">-rw------- 1 moralok moralok  106 Jun 28 20:07 authorized_keys</span><br><span class="line">-rw-r--r-- 1 moralok moralok  444 Jun 28 20:19 known_hosts</span><br></pre></td></tr></table></figure>

<p>检查目录列表以查看是否已经有 <code>SSH</code> 公钥。 默认情况下，<code>GitHub</code> 的一个支持的公钥的文件名是以下之一。</p>
<ul>
<li><code>id_rsa.pub</code></li>
<li><code>id_ecdsa.pub</code></li>
<li><code>id_ed25519.pub</code></li>
</ul>
<h3 id="生成-SSH-密钥"><a href="#生成-SSH-密钥" class="headerlink" title="生成 SSH 密钥"></a>生成 SSH 密钥</h3><p>如果没有密钥，就需要生成新的 <code>SSH</code> 密钥；如果已有，跳到上传已有密钥环节。<br>打开终端，粘贴下面的文本（替换为你的 <code>GitHub</code> 电子邮件地址），这将以提供的电子邮件地址为标签创建新 <code>SSH</code> 密钥。<br>一直 <code>yes</code> 确定选择默认即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh-keygen -t ed25519 -C <span class="string">&quot;your_email@example.com&quot;</span></span></span><br><span class="line">Generating public/private ed25519 key pair.</span><br><span class="line">Enter file in which to save the key (/home/your-user/.ssh/id_ed25519):</span><br></pre></td></tr></table></figure>

<h3 id="上传-SSH-密钥"><a href="#上传-SSH-密钥" class="headerlink" title="上传 SSH 密钥"></a>上传 SSH 密钥</h3><p>将 <code>SSH</code> 公钥复制到剪贴板，在 <code>Github</code> 上的 <code>Settings -&gt; Access -&gt; SSH and GPG keys -&gt; New SSH key</code>，粘贴即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> ~/.ssh/id_ed25519.pub</span></span><br></pre></td></tr></table></figure>

<h3 id="配置-Git"><a href="#配置-Git" class="headerlink" title="配置 Git"></a>配置 Git</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.name <span class="string">&quot;your_username&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.email <span class="string">&quot;your_email@example.com&quot;</span></span></span><br></pre></td></tr></table></figure>


<h2 id="使用-SSH-免密登录服务器"><a href="#使用-SSH-免密登录服务器" class="headerlink" title="使用 SSH 免密登录服务器"></a>使用 SSH 免密登录服务器</h2><p>使用现成的密钥，将 <code>~/.ssh/id_ed25519.pub</code> 的内容追加到服务端的 <code>~/.ssh/authorized_keys</code> 中，使用 <code>ssh user@host</code> 成功免密登录。这样一来，远程连接服务器或者使用 <code>VScode Remote Explorer</code> 时，不用每次输入密码了。</p>
<h3 id="VScode-Remote-Explorer-无法连接"><a href="#VScode-Remote-Explorer-无法连接" class="headerlink" title="VScode Remote Explorer 无法连接"></a>VScode Remote Explorer 无法连接</h3><p>在更新 <code>VMware Workstation 17 Pro</code> 后，发现虚拟机的 <code>IP</code> 从 <code>192.168.46.135</code> 重置 为 <code>192.168.46.128</code>，即使更新配置文件 <code>C:\Users\moralok\.ssh\config</code> 中的 <code>IP</code> <code>VScode Remote Explorer</code> 仍然无法连接，但是通过 <code>Xshell</code> 使用账号密码可以登录。查看报错信息发现 <code>known_hosts</code> 中 <code>192.168.46.128</code> 对应的 <code>ECDSA key</code> 有问题，应该记录的是之前占用该 <code>IP</code> 的虚拟机的 <code>ECDSA key</code>，删除该行后重新连接成功。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[18:09:59.973] &gt; @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">&gt; @    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @</span><br><span class="line">&gt; @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">&gt; IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!</span><br><span class="line">&gt; Someone could be eavesdropping on you right now (man-in-the-middle attack)!     </span><br><span class="line">&gt; It is also possible that a host key has just been changed.</span><br><span class="line">&gt; The fingerprint for the ECDSA key sent by the remote host is</span><br><span class="line">&gt; SHA256:Q8ckiM7lmz2HBjsNPHFaVjhJfuTcfbgThP1NLv52H1Y.</span><br><span class="line">&gt; Please contact your system administrator.</span><br><span class="line">&gt; Add correct host key in C:\\Users\\moralok/.ssh/known_hosts to get rid of this message.</span><br><span class="line">&gt; Offending ECDSA key in C:\\Users\\moralok/.ssh/known_hosts:1</span><br><span class="line">&gt; ECDSA host key for 192.168.46.128 has changed and you have requested strict checking.</span><br><span class="line">&gt; Host key verification failed.</span><br><span class="line">&gt; 过程试图写入的管道不存在。</span><br><span class="line">&gt; </span><br></pre></td></tr></table></figure>


<h2 id="SSH-的原理"><a href="#SSH-的原理" class="headerlink" title="SSH 的原理"></a>SSH 的原理</h2><h3 id="关于-SSH"><a href="#关于-SSH" class="headerlink" title="关于 SSH"></a>关于 SSH</h3><p>使用 <code>SSH</code> 协议可以连接远程服务器和服务并向它们验证，而无需在每次访问时都提供用户名和密码，<code>Github</code> 还可以使用 <code>SSH</code> 密钥对提交进行签名。</p>
<h3 id="公钥和私钥"><a href="#公钥和私钥" class="headerlink" title="公钥和私钥"></a>公钥和私钥</h3><p><code>SSH</code> 的使用（非对称加密）需要生成公钥 <code>public key</code> 和私钥 <code>private key</code>。常用的算法有 <code>rsa</code>、<code>ecdsa</code> 和 <code>ed25519</code>，相对应的公钥默认文件名即 <code>id_XXX.pub</code>。<code>ed25519</code> 的安全性介于 <code>rsa 2048</code> 和 <code>rsa 4096</code> 之间，但性能却提升数十倍。<br>在生成密钥时，会要求你 <code>Enter passphrase (empty for no passphrase):</code>，可以输入一个口令保护私钥的使用。不为空的情况下，正常使用是需要输入这个口令的，很多人认为麻烦，因此留空。<br>公钥的权限必须是 <code>644</code>，私钥的权限必须是 <code>600</code>，否则 <code>SSH</code> 认为其不可靠。<br>私钥是要安全保管在客户端不能泄露的，公钥则要提供给远程服务器或服务。服务端的 <code>~/.ssh/authorized_keys</code> 里面存储着可以登录的客户端的公钥。我们将公钥粘贴到 <code>Github</code> 的过程就是对应于此。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh-keygen -t rsa -b 4096 -f my_id -C <span class="string">&quot;email@example.com&quot;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>-t</code> 表示算法，如 <code>rsa</code>。</li>
<li><code>-b</code> 表示 <code>rsa</code> 密钥长度，默认 <code>2048 bit</code>，<code>ed25519</code> 不需要指定。</li>
<li><code>-f</code> 表示文件名。</li>
<li><code>-C</code> 表示在公钥文件中添加注释，可修改</li>
</ul>
<h3 id="SSH-公钥登录过程"><a href="#SSH-公钥登录过程" class="headerlink" title="SSH 公钥登录过程"></a>SSH 公钥登录过程</h3><ol>
<li><code>Client</code> 将自己的公钥存放到服务端，追加到 <code>authorized_keys</code> 文件。</li>
<li><code>Server</code> 收到 <code>Client</code> 的连接请求后，会在 <code>authorized_keys</code> 文件中匹配到 <code>Client</code> 传过来的公钥，并生成随机数 <code>R</code>，用公钥对随机数加密得到 <code>pubKey(R)</code>。</li>
<li><code>Client</code> 收到后通过私钥解密得到随机数 <code>R</code>，然后对随机数 <code>R</code> 和本次会话的 <code>sessionKey</code> 使用 <code>MD5</code> 生成摘要 <code>Digest1</code>，发送给服务端。</li>
<li><code>Server</code> 会对随机数 <code>R</code> 和会话的 <code>sessionKey</code> 同样使用 <code>MD5</code> 生成摘要 <code>Digest2</code>，对比相同即完成认证过程。</li>
</ol>
<h3 id="避免中间人攻击"><a href="#避免中间人攻击" class="headerlink" title="避免中间人攻击"></a>避免中间人攻击</h3><p><code>SSH</code> 通过口令确认避免中间人攻击，如果用户第一次登录 <code>Server</code>，系统会提示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh -T git@github.com</span></span><br><span class="line">The authenticity of host &#x27;github.com (20.205.243.166)&#x27; can&#x27;t be established.</span><br><span class="line">ECDSA key fingerprint is SHA256:p2QAMXNIC1TJYWeIOttrVc98/R1BUFWu3/LiyKgUfQM.</span><br><span class="line">Are you sure you want to continue connecting (yes/no/[fingerprint])? yes</span><br><span class="line">Warning: Permanently added &#x27;github.com,20.205.243.166&#x27; (ECDSA) to the list of known hosts.</span><br><span class="line">Hi $&#123;username&#125;! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>

<p><code>Server</code> 需要在其网站上公示其公钥的指纹，<code>Github</code> 的公钥指纹<a href="https://docs.github.com/zh/authentication/keeping-your-account-and-data-secure/githubs-ssh-key-fingerprints">在这里</a>。<br>确认匹配后，客户端会在 <code>~/.ssh/known_hosts</code> 中记录，下次登录不再警告。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://docs.github.com/zh/authentication/connecting-to-github-with-ssh/about-ssh">使用 SSH 进行连接 Github</a><br><a href="https://blog.csdn.net/u012408797/article/details/116196831">Git 多台电脑共用SSH Key</a><br><a href="https://blog.csdn.net/neo949332116/article/details/102926051">SSH协议登录过程详解</a><br><a href="https://docs.github.com/zh/authentication/keeping-your-account-and-data-secure/githubs-ssh-key-fingerprints">GitHub 的 SSH 密钥指纹</a><br><a href="https://zhuanlan.zhihu.com/p/110413836">使用 Ed25519 算法生成你的 SSH 密钥</a></p>
]]></content>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 应用 context 刷新流程</title>
    <url>/2023/08/04/Spring-application-context-refresh-process/</url>
    <content><![CDATA[<h3 id="context-刷新流程简单图解"><a href="#context-刷新流程简单图解" class="headerlink" title="context 刷新流程简单图解"></a>context 刷新流程简单图解</h3><h4 id="刷新流程"><a href="#刷新流程" class="headerlink" title="刷新流程"></a>刷新流程</h4><img src="/2023/08/04/Spring-application-context-refresh-process/Pasted%20image%2020231122005901.png" class="" title="Spring context 刷新流程">

<h4 id="刷新流程中的组件"><a href="#刷新流程中的组件" class="headerlink" title="刷新流程中的组件"></a>刷新流程中的组件</h4><img src="/2023/08/04/Spring-application-context-refresh-process/Pasted%20image%2020231122021817.png" class="" title="Spring context 刷新流程中的组件">

<h3 id="上下文刷新-AbstractApplicationContext-refresh"><a href="#上下文刷新-AbstractApplicationContext-refresh" class="headerlink" title="上下文刷新 AbstractApplicationContext#refresh"></a>上下文刷新 AbstractApplicationContext#refresh</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">    <span class="comment">// 刷新和销毁的同步监视器。</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// 1. 准备 context 以供刷新。</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line">        <span class="comment">// 2. 告诉 context 子类刷新内部 beanFactory 并返回。</span></span><br><span class="line">        <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line">        <span class="comment">// 3. 准备 beanFactory 以供在此 context 中使用。</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 4. 允许 context 子类对 bean 工厂进行后处理。</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line">            <span class="comment">// 5. 调用在 context 中注册为 bean 的工厂后处理器。</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">            <span class="comment">// 6. 注册拦截 Bean 创建的 Bean 后处理器。</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line">            <span class="comment">// 7. 初始化 context 的消息源。</span></span><br><span class="line">            initMessageSource();</span><br><span class="line">            <span class="comment">// 8. 为 context 初始化事件多播器。</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line">            <span class="comment">// 9. 在特定 context 子类中初始化其他特殊 bean。</span></span><br><span class="line">            onRefresh();</span><br><span class="line">            <span class="comment">// 10. 检查监听器 beans 并注册。</span></span><br><span class="line">            registerListeners();</span><br><span class="line">            <span class="comment">// 11. 实例化所有剩余的（非惰性初始化）单例。</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">            <span class="comment">// 12. 最后一步：发布相应的事件。</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="comment">// 销毁已经创建的单例，以防止资源未正常释放。</span></span><br><span class="line">            destroyBeans();</span><br><span class="line">            <span class="comment">// 重置 &#x27;active&#x27; flag.</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            resetCommonCaches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="准备-context-以供刷新-prepareRefresh"><a href="#准备-context-以供刷新-prepareRefresh" class="headerlink" title="准备 context 以供刷新 prepareRefresh"></a>准备 context 以供刷新 prepareRefresh</h3><p>准备此 context 以供刷新，设置其启动日期和活动标志以及执行属性源的初始化。</p>
<blockquote>
<p>编写管理资源的容器时，可以参考。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareRefresh</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">    <span class="built_in">this</span>.closed.set(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">this</span>.active.set(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Refreshing &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化 PropertySource，默认什么都不做。</span></span><br><span class="line">    initPropertySources();</span><br><span class="line">    <span class="comment">// 校验所有被标记为 required 的 properties 都可以被解析。</span></span><br><span class="line">    getEnvironment().validateRequiredProperties();</span><br><span class="line">    <span class="comment">// 允许收集早期的 ApplicationEvents，当事件多播器可用就发送。</span></span><br><span class="line">    <span class="built_in">this</span>.earlyApplicationEvents = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;ApplicationEvent&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="obtainFreshBeanFactory"><a href="#obtainFreshBeanFactory" class="headerlink" title="obtainFreshBeanFactory"></a>obtainFreshBeanFactory</h3><p>告诉子类刷新内部 bean 工厂并返回，返回的实例类型为 <strong>DefaultListableBeanFactory</strong>。在这里完成了配置文件的读取，初步注册了 bean 定义。</p>
<blockquote>
<p>我大概这辈子都不会想理清楚这里面关于 XML 文件的解析过程，但是我知道可以在这里观察到 beanFactory 因为配置文件注册了哪些 bean。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title function_">obtainFreshBeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 刷新 beanFactory</span></span><br><span class="line">    <span class="comment">// 使用 XmlBeanDefinitionReader 加载配置文件中的 bean 定义</span></span><br><span class="line">    refreshBeanFactory();</span><br><span class="line">    <span class="comment">// 返回 beanFactory</span></span><br><span class="line">    <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> getBeanFactory();</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Bean factory for &quot;</span> + getDisplayName() + <span class="string">&quot;: &quot;</span> + beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="准备-beanFactory"><a href="#准备-beanFactory" class="headerlink" title="准备 beanFactory"></a>准备 beanFactory</h3><p>配置 BeanFactory 以供在此 context 中使用，例如 context 的类加载器和一些后处理器，手动注册一些单例。</p>
<ol>
<li>为 beanFactory 配置 context 相关的资源，如类加载器</li>
<li>添加 Bean 后处理器<ul>
<li>ApplicationContextAwareProcessor，context 回调，注入特定类型时可触发自定义逻辑</li>
<li>ApplicationListenerDetector，检测 ApplicationListener</li>
</ul>
</li>
<li>手动注册单例</li>
</ol>
<blockquote>
<p>ignoreDependencyInterface 和 registerResolvableDependency 在理解之后比单纯地记忆它们有趣许多。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="comment">// 告诉内部 beanFactory 使用 context 的类加载器等等。</span></span><br><span class="line">    beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">    beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> <span class="title class_">StandardBeanExpressionResolver</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line">    beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> <span class="title class_">ResourceEditorRegistrar</span>(<span class="built_in">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为内部 beanFactory 配置 context 回调。</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationContextAwareProcessor</span>(<span class="built_in">this</span>));</span><br><span class="line">    <span class="comment">// 如果一个 bean 的依赖实现了以下接口，忽略该依赖的检查和自动装配。</span></span><br><span class="line">    <span class="comment">// 例如在 populateBean 时，如果 bena 的依赖存在 set 方法，就会去解析，调用 getBean</span></span><br><span class="line">    <span class="comment">// 被设置 ignoreDependencyInterface 的依赖，仍然可以通过后置处理器进行依赖注入，例如以下的类型会使用上面那个后置处理器的回调方法注入。</span></span><br><span class="line">    <span class="comment">// 因此 @Autowire 这些通过后置处理器实现依赖注入的注解，也不会受影响</span></span><br><span class="line">    <span class="comment">// 这样设计的一个可能是往往注入这些类型时，希望触发某些事件。</span></span><br><span class="line">    beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BeanFactory 之类的接口没有在普通工厂中注册为可解析类型，直接为它们指定 bean。</span></span><br><span class="line">    beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">    beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="built_in">this</span>);</span><br><span class="line">    beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="built_in">this</span>);</span><br><span class="line">    beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提前注册后处理器以检测内部 beans 是否是一个 ApplicationListener。</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationListenerDetector</span>(<span class="built_in">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测是否有 LoadTimeWeaver，如果存在就准备编织。</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">LoadTimeWeaverAwareProcessor</span>(beanFactory));</span><br><span class="line">        <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">        beanFactory.setTempClassLoader(<span class="keyword">new</span> <span class="title class_">ContextTypeMatchClassLoader</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手动注册默认的环境 beans。</span></span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在创建 Bean 开始前注册的单例，都属于手动注册的单例 manualSingletonNames</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerSingleton</span><span class="params">(String beanName, Object singletonObject)</span> <span class="keyword">throws</span> IllegalStateException &#123;</span><br><span class="line">    <span class="built_in">super</span>.registerSingleton(beanName, singletonObject);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">        <span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">this</span>.beanDefinitionMap.containsKey(beanName)) &#123;</span><br><span class="line">                Set&lt;String&gt; updatedSingletons = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;String&gt;(<span class="built_in">this</span>.manualSingletonNames.size() + <span class="number">1</span>);</span><br><span class="line">                updatedSingletons.addAll(<span class="built_in">this</span>.manualSingletonNames);</span><br><span class="line">                updatedSingletons.add(beanName);</span><br><span class="line">                <span class="built_in">this</span>.manualSingletonNames = updatedSingletons;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Still in startup registration phase</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.beanDefinitionMap.containsKey(beanName)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.manualSingletonNames.add(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    clearByTypeCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="postProcessBeanFactory"><a href="#postProcessBeanFactory" class="headerlink" title="postProcessBeanFactory"></a>postProcessBeanFactory</h3><p>在标准初始化后修改内部 beanFactory，默认什么都不做。</p>
<h3 id="invokeBeanFactoryPostProcessors"><a href="#invokeBeanFactoryPostProcessors" class="headerlink" title="invokeBeanFactoryPostProcessors"></a>invokeBeanFactoryPostProcessors</h3><p>实例化并调用所有在 context 中注册的 beanFactory 后处理器，需遵循顺序规则。具体的处理被委托给 PostProcessorRegistrationDelegate。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>invokeBeanFactoryPostProcessors 方法堪比裹脚布。</p>
<p><strong>关于调用顺序的规则</strong>：</p>
<ol>
<li>BeanFactoryPostProcessor 分为 context 添加的和 beanFactory 注册的，前者优于后者</li>
<li>BeanFactoryPostProcessor 又可分为常规的和 BeanDefinitionRegistryPostProcessor，后者优于前者</li>
<li>PriorityOrdered 优于 Ordered 优于剩余的</li>
</ol>
<p>可能新增 beanDefinition 的情况：</p>
<ol>
<li>BeanDefinitionRegistryPostProcessor 可能在 beanFactory 中引入新的 beanDefinition</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeBeanFactoryPostProcessors</span><span class="params">(</span></span><br><span class="line"><span class="params">		ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储已处理过的后处理器</span></span><br><span class="line">    Set&lt;String&gt; processedBeans = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一阶段：BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">        <span class="comment">// 如果 beanFactory 同时是 BeanDefinitionRegistry 类型</span></span><br><span class="line">        <span class="type">BeanDefinitionRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">        <span class="comment">// 存储常规的 BeanFactoryPostProcessor</span></span><br><span class="line">        List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;BeanFactoryPostProcessor&gt;();</span><br><span class="line">        <span class="comment">// 存储 BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">        List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;BeanDefinitionRegistryPostProcessor&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 0 轮，先对 context 注册的 BeanFactoryPostProcessor 进行分类</span></span><br><span class="line">        <span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line">            <span class="keyword">if</span> (postProcessor <span class="keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">                <span class="type">BeanDefinitionRegistryPostProcessor</span> <span class="variable">registryProcessor</span> <span class="operator">=</span></span><br><span class="line">                        (BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line">                <span class="comment">// 分类的同时，直接调用 BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">                registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">                registryProcessors.add(registryProcessor);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                regularPostProcessors.add(postProcessor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 BeanDefinitionRegistryPostProcessors 按是否实现 PriorityOrdered，Ordered，以及剩余的进行分类</span></span><br><span class="line">        List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;BeanDefinitionRegistryPostProcessor&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 1 轮，先处理 beanFactory 中实现了 PriorityOrdered 的 BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">        String[] postProcessorNames =</span><br><span class="line">                beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">                <span class="comment">// getBean 并添加到当前的后处理器集合</span></span><br><span class="line">                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                processedBeans.add(ppName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 排序后添加</span></span><br><span class="line">        sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">        registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">        currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 2 轮，Ordered</span></span><br><span class="line">        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                processedBeans.add(ppName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">        registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">        currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 3 轮， 调用剩余的 BeanDefinitionRegistryPostProcessors 直到没有新的出现。</span></span><br><span class="line">        <span class="comment">// 后出现的 PriorityOrdered 不比前面的 Ordered 更早被处理</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">reiterate</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (reiterate) &#123;</span><br><span class="line">            reiterate = <span class="literal">false</span>;</span><br><span class="line">            postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">                    currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                    processedBeans.add(ppName);</span><br><span class="line">                    reiterate = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">            registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">            invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">            currentRegistryProcessors.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用目前出现的 BeanFactoryPostProcessors</span></span><br><span class="line">        <span class="comment">// 仍遵循 PriorityOrdered、Ordered、Regular（registry）、Regular（context 添加的） 的顺序</span></span><br><span class="line">        invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class="line">        invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，直接调用 context 注册的 beanFactoryPostProcessors</span></span><br><span class="line">        invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二阶段：BeanFactoryPostProcessor</span></span><br><span class="line">    String[] postProcessorNames =</span><br><span class="line">            beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 BeanFactoryPostProcessor 按是否实现 PriorityOrdered，Ordered，以及剩余的进行分类</span></span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;BeanFactoryPostProcessor&gt;();</span><br><span class="line">    List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">        <span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line">            <span class="comment">// 第一阶段已处理，跳过</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">            priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">            orderedPostProcessorNames.add(ppName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第 1 轮，BeanFactoryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">    invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第 2 轮，BeanFactoryPostProcessors that implement Ordered.</span></span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;BeanFactoryPostProcessor&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">        orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">    &#125;</span><br><span class="line">    sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">    invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第 3 轮，剩余的 BeanFactoryPostProcessors.</span></span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;BeanFactoryPostProcessor&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">        nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">    &#125;</span><br><span class="line">    invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理缓存的 merged bean definitions 因为 post-processors 可能已经修改了原来的 metadata</span></span><br><span class="line">    beanFactory.clearMetadataCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="registerBeanPostProcessors"><a href="#registerBeanPostProcessors" class="headerlink" title="registerBeanPostProcessors"></a>registerBeanPostProcessors</h3><p>注册拦截 <code>bean</code> 创建的 <code>bean</code> 后处理器。具体的处理被委托给 PostProcessorRegistrationDelegate。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>registerBeanPostProcessors 相比之下是一条清新的裹脚布。这里特别区分 3 种类型的 Bean 后处理器：</p>
<ul>
<li>MergedBeanDefinitionPostProcessor</li>
<li>InstantiationAwareBeanPostProcessor 感知实例化</li>
<li>DestructionAwareBeanPostProcessor 感知销毁</li>
</ul>
<p>ApplicationListenerDetector 既是 MergedBeanDefinitionPostProcessor，又是 DestructionAwareBeanPostProcessor，在初始化后将 listener 加入，在销毁前将 listener 移除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerBeanPostProcessors</span><span class="params">(</span></span><br><span class="line"><span class="params">		ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取 BeanPostProcessor 的名称</span></span><br><span class="line">    String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册 BeanPostProcessorChecker，在 BeanPostProcessor 实例化期间创建 bean 时，记录一条消息。</span></span><br><span class="line">    <span class="comment">// 即，当一个 bean 不能被所有 BeanPostProcessors 处理时，记录。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">beanProcessorTargetCount</span> <span class="operator">=</span> beanFactory.getBeanPostProcessorCount() + <span class="number">1</span> + postProcessorNames.length;</span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">BeanPostProcessorChecker</span>(beanFactory, beanProcessorTargetCount));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 BeanPostProcessors 按 implement PriorityOrdered，Ordered，和剩余的进行分类。</span></span><br><span class="line">    List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;BeanPostProcessor&gt;();</span><br><span class="line">    List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;BeanPostProcessor&gt;();</span><br><span class="line">    List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">        <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">            <span class="type">BeanPostProcessor</span> <span class="variable">pp</span> <span class="operator">=</span> beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">            priorityOrderedPostProcessors.add(pp);</span><br><span class="line">            <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">                internalPostProcessors.add(pp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">            orderedPostProcessorNames.add(ppName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第 1 轮，注册 BeanPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">    registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第 2 轮，注册 BeanPostProcessors that implement Ordered.</span></span><br><span class="line">    List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;BeanPostProcessor&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">        <span class="type">BeanPostProcessor</span> <span class="variable">pp</span> <span class="operator">=</span> beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">        orderedPostProcessors.add(pp);</span><br><span class="line">        <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">            internalPostProcessors.add(pp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">    registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第 3 轮，注册剩余的 regular BeanPostProcessors.</span></span><br><span class="line">    List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;BeanPostProcessor&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">        <span class="type">BeanPostProcessor</span> <span class="variable">pp</span> <span class="operator">=</span> beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">        nonOrderedPostProcessors.add(pp);</span><br><span class="line">        <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">            internalPostProcessors.add(pp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后（第 4 轮）, 排序并注册 internal BeanPostProcessors.</span></span><br><span class="line">    sortPostProcessors(internalPostProcessors, beanFactory);</span><br><span class="line">    registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-register post-processor for detecting inner beans as ApplicationListeners,</span></span><br><span class="line">    <span class="comment">// moving it to the end of the processor chain (for picking up proxies etc).</span></span><br><span class="line">    <span class="comment">// 重新注册用于检测 ApplicationListeners 的 Bean 后处理器，将其移动到处理器链的最后（用于获取代理）。</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationListenerDetector</span>(applicationContext));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加 BeanPostProcessor 时</p>
<ol>
<li>先移除</li>
<li>再添加</li>
<li>判断类型并记录标记<ul>
<li>感知实例化的后处理器</li>
<li>感知销毁的后处理器</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBeanPostProcessor</span><span class="params">(BeanPostProcessor beanPostProcessor)</span> &#123;</span><br><span class="line">    Assert.notNull(beanPostProcessor, <span class="string">&quot;BeanPostProcessor must not be null&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.beanPostProcessors.remove(beanPostProcessor);</span><br><span class="line">    <span class="built_in">this</span>.beanPostProcessors.add(beanPostProcessor);</span><br><span class="line">    <span class="keyword">if</span> (beanPostProcessor <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">        <span class="built_in">this</span>.hasInstantiationAwareBeanPostProcessors = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (beanPostProcessor <span class="keyword">instanceof</span> DestructionAwareBeanPostProcessor) &#123;</span><br><span class="line">        <span class="built_in">this</span>.hasDestructionAwareBeanPostProcessors = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="initMessageSource"><a href="#initMessageSource" class="headerlink" title="initMessageSource"></a>initMessageSource</h3><p>初始化消息源。 如果在此 context 中未定义，则使用父级的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initMessageSource</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> getBeanFactory();</span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);</span><br><span class="line">        <span class="comment">// 设置 parent MessageSource.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.parent != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.messageSource <span class="keyword">instanceof</span> HierarchicalMessageSource) &#123;</span><br><span class="line">            <span class="type">HierarchicalMessageSource</span> <span class="variable">hms</span> <span class="operator">=</span> (HierarchicalMessageSource) <span class="built_in">this</span>.messageSource;</span><br><span class="line">            <span class="keyword">if</span> (hms.getParentMessageSource() == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 只有当 parent MessageSource 尚未注册才将 parent context 设置为 parent MessageSource</span></span><br><span class="line">                hms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Using MessageSource [&quot;</span> + <span class="built_in">this</span>.messageSource + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 使用代理 messageSource，以此接收 getMessage 调用。</span></span><br><span class="line">        <span class="type">DelegatingMessageSource</span> <span class="variable">dms</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DelegatingMessageSource</span>();</span><br><span class="line">        dms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">        <span class="built_in">this</span>.messageSource = dms;</span><br><span class="line">        beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, <span class="built_in">this</span>.messageSource);</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Unable to locate MessageSource with name &#x27;&quot;</span> + MESSAGE_SOURCE_BEAN_NAME +</span><br><span class="line">                    <span class="string">&quot;&#x27;: using default [&quot;</span> + <span class="built_in">this</span>.messageSource + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="initApplicationEventMulticaster"><a href="#initApplicationEventMulticaster" class="headerlink" title="initApplicationEventMulticaster"></a>initApplicationEventMulticaster</h3><p>初始化 <code>ApplicationEventMulticaster</code>。 如果上下文中未定义，则使用 <code>SimpleApplicationEventMulticaster</code>。可以看得出代码的结构和 initMessageSource 是类似的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initApplicationEventMulticaster</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> getBeanFactory();</span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.applicationEventMulticaster =</span><br><span class="line">                beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Using ApplicationEventMulticaster [&quot;</span> + <span class="built_in">this</span>.applicationEventMulticaster + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.applicationEventMulticaster = <span class="keyword">new</span> <span class="title class_">SimpleApplicationEventMulticaster</span>(beanFactory);</span><br><span class="line">        beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="built_in">this</span>.applicationEventMulticaster);</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Unable to locate ApplicationEventMulticaster with name &#x27;&quot;</span> +</span><br><span class="line">                    APPLICATION_EVENT_MULTICASTER_BEAN_NAME +</span><br><span class="line">                    <span class="string">&quot;&#x27;: using default [&quot;</span> + <span class="built_in">this</span>.applicationEventMulticaster + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="onRefresh"><a href="#onRefresh" class="headerlink" title="onRefresh"></a>onRefresh</h3><p>可以重写模板方法来添加特定 context 的刷新工作。默认情况下什么都不做。</p>
<h3 id="registerListeners"><a href="#registerListeners" class="headerlink" title="registerListeners"></a>registerListeners</h3><p>获取侦听器 <code>bean</code> 并注册。无需初始化即可添加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerListeners</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 注册静态指定的 ApplicationListener，和 beanFactoryPostProcessor 类似，context 可以提前添加好。</span></span><br><span class="line">    <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</span><br><span class="line">        getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">    <span class="comment">// uninitialized to let post-processors apply to them!</span></span><br><span class="line">    <span class="comment">// 这段注释看到不止一次，但是不太理解，感觉和代码联系不起来？</span></span><br><span class="line">    String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (String listenerBeanName : listenerBeanNames) &#123;</span><br><span class="line">        getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在我们终于有了多播器，发布早期的应用事件。</span></span><br><span class="line">    Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class="built_in">this</span>.earlyApplicationEvents;</span><br><span class="line">    <span class="built_in">this</span>.earlyApplicationEvents = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (earlyEventsToProcess != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;</span><br><span class="line">            getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加 ApplicationListener。</p>
<blockquote>
<p>后处理器 ApplicationListenerDetector 在 processor chain 的最后，最终会将创建的代理添加为监听器。什么情况下会出现代码中预防的情况呢？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addApplicationListener</span><span class="params">(ApplicationListener&lt;?&gt; listener)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.retrievalMutex) &#123;</span><br><span class="line">        <span class="comment">// 如果已经注册，需要显式地删除代理，以避免同一监听器的双重调用。</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">singletonTarget</span> <span class="operator">=</span> AopProxyUtils.getSingletonTarget(listener);</span><br><span class="line">        <span class="keyword">if</span> (singletonTarget <span class="keyword">instanceof</span> ApplicationListener) &#123;</span><br><span class="line">            <span class="built_in">this</span>.defaultRetriever.applicationListeners.remove(singletonTarget);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.defaultRetriever.applicationListeners.add(listener);</span><br><span class="line">        <span class="built_in">this</span>.retrieverCache.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="finishBeanFactoryInitialization"><a href="#finishBeanFactoryInitialization" class="headerlink" title="finishBeanFactoryInitialization"></a>finishBeanFactoryInitialization</h3><p>实例化所有剩余的（非惰性初始化）单例。以 context 视角，是完成内部 beanFactory 的初始化。</p>
<p>几乎可以只关注最后的 <code>beanFactory.preInstantiateSingletons()</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="comment">// 为 context 初始化转换服务</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">            beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">        beanFactory.setConversionService(</span><br><span class="line">                beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果之前没有任何 bean 后处理器（例如 PropertyPlaceholderConfigurer）注册，则注册默认的嵌入值解析器，主要用于解析注释属性值。</span></span><br><span class="line">    <span class="comment">// 接口 ConfigurableEnvironment 继承自 ConfigurablePropertyResolver</span></span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">        beanFactory.addEmbeddedValueResolver(<span class="keyword">new</span> <span class="title class_">StringValueResolver</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">resolveStringValue</span><span class="params">(String strVal)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> getEnvironment().resolvePlaceholders(strVal);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尽早初始化 LoadTimeWeaverAware，以便尽早注册其转换器。</span></span><br><span class="line">    String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">        getBean(weaverAwareName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停止使用临时类加载器进行类型匹配。</span></span><br><span class="line">    beanFactory.setTempClassLoader(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 允许缓存所有 bean 定义的元数据，而不期望进一步更改。</span></span><br><span class="line">    beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化所有剩余的（非惰性初始化）单例。</span></span><br><span class="line">    beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>确保所有非惰性初始化单例都已实例化，同时还要考虑 <code>FactoryBeans</code>。 如果需要，通常在工厂设置结束时调用。</p>
<a href="/2023/08/10/how-does-Spring-load-beans/" title="Spring Bean 加载过程">加载 Bean 的流程分析在此</a>。

<blockquote>
<p>先对集合进行 Copy 再迭代是很常见的处理方式，可以有效保证迭代时不受原集合影响，也不会影响到原集合。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">        <span class="built_in">this</span>.logger.debug(<span class="string">&quot;Pre-instantiating singletons in &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝一份 beanDefinitionNames</span></span><br><span class="line">    List&lt;String&gt; beanNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(<span class="built_in">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发所有非惰性初始化单例的实例化</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line">        <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">                <span class="comment">// FactoryBean</span></span><br><span class="line">                <span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">                <span class="type">boolean</span> isEagerInit;</span><br><span class="line">                <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">                    isEagerInit = AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Boolean&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> Boolean <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, getAccessControlContext());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                            ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">                    <span class="comment">// 是否立即初始化</span></span><br><span class="line">                    getBean(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 常规 Bean（重要）</span></span><br><span class="line">                getBean(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发所有适用 bean 的初始化后回调</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">singletonInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">SmartInitializingSingleton</span> <span class="variable">smartSingleton</span> <span class="operator">=</span> (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">            <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">                AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Object&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                        smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, getAccessControlContext());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="finishRefresh"><a href="#finishRefresh" class="headerlink" title="finishRefresh"></a>finishRefresh</h3><p>最后一步，完成 context 刷新，比如发布相应的事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finishRefresh</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 为此 context 初始化生命周期处理器。</span></span><br><span class="line">    initLifecycleProcessor();</span><br><span class="line">    <span class="comment">// 2. 将刷新传播到生命周期处理器。</span></span><br><span class="line">    getLifecycleProcessor().onRefresh();</span><br><span class="line">    <span class="comment">// 3. 发布 ContextRefreshedEvent。</span></span><br><span class="line">    publishEvent(<span class="keyword">new</span> <span class="title class_">ContextRefreshedEvent</span>(<span class="built_in">this</span>));</span><br><span class="line">    <span class="comment">// 4. 参与 LiveBeansView MBean（如果处于活动状态）。</span></span><br><span class="line">    LiveBeansView.registerApplicationContext(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Bean 加载过程</title>
    <url>/2023/08/10/how-does-Spring-load-beans/</url>
    <content><![CDATA[<h2 id="Spring-Bean-生命周期"><a href="#Spring-Bean-生命周期" class="headerlink" title="Spring Bean 生命周期"></a>Spring Bean 生命周期</h2><img src="/2023/08/10/how-does-Spring-load-beans/Pasted%20image%2020231118213120.png" class="" title="Spring Bean 生命周期">

<h2 id="获取-Bean"><a href="#获取-Bean" class="headerlink" title="获取 Bean"></a>获取 Bean</h2><p>获取指定 Bean 的入口方法是 getBean，在 Spring 上下文刷新过程中，就依次调用 <code>AbstractBeanFactory#getBean(java.lang.String)</code> 方法获取 <code>non-lazy-init</code> 的 Bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="comment">// 具体工作由 doGetBean 完成</span></span><br><span class="line">    <span class="keyword">return</span> doGetBean(name, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="deGetBean"><a href="#deGetBean" class="headerlink" title="deGetBean"></a>deGetBean</h3><p>作为公共处理逻辑，由 AbstractBeanFactory 自己实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="keyword">final</span> String name, <span class="keyword">final</span> Class&lt;T&gt; requiredType, <span class="keyword">final</span> Object[] args, <span class="type">boolean</span> typeCheckOnly)</span> </span><br><span class="line">    <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="comment">// 转换名称：去除 FactoryBean 的前缀 &amp;，将别名转换为规范名称</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> transformedBeanName(name);</span><br><span class="line">    Object bean;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查单例缓存中是否已存在</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="literal">null</span> &amp;&amp; args == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 如果已存在，直接返回该实例或者使用该实例（FactoryBean）创建并返回对象</span></span><br><span class="line">        bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前 Bean 是一个正在创建中的 prototype 类型，表明可能发生循环引用</span></span><br><span class="line">        <span class="comment">// 注意：Spring 并未解决 prototype 类型的循环引用问题，要抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果当前 beanFactory 没有 bean 定义，去 parent beanFactory 中查找</span></span><br><span class="line">        <span class="type">BeanFactory</span> <span class="variable">parentBeanFactory</span> <span class="operator">=</span> getParentBeanFactory();</span><br><span class="line">        <span class="keyword">if</span> (parentBeanFactory != <span class="literal">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">nameToLookup</span> <span class="operator">=</span> originalBeanName(name);</span><br><span class="line">            <span class="keyword">if</span> (args != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">            <span class="comment">// 标记为至少创建过一次</span></span><br><span class="line">            markBeanAsCreated(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">RootBeanDefinition</span> <span class="variable">mbd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 确保 bean 依赖的 bean（构造器参数） 都已实例化</span></span><br><span class="line">            String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">            <span class="keyword">if</span> (dependsOn != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">                        <span class="comment">// 注意：Spring 并未解决构造器方法中的循环引用问题，要抛异常</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 注册依赖关系，确保先销毁被依赖的 bean</span></span><br><span class="line">                    registerDependentBean(dep, beanName);</span><br><span class="line">                    <span class="comment">// 递归，获取依赖的 bean</span></span><br><span class="line">                    getBean(dep);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">            <span class="comment">// 如果是单例类型（绝大多数都是此类型）</span></span><br><span class="line">            <span class="comment">// 再次从缓存中获取，如果仍不存在，则使用传入的 ObjectFactory 创建</span></span><br><span class="line">            sharedInstance = getSingleton(beanName, <span class="keyword">new</span> <span class="title class_">ObjectFactory</span>&lt;Object&gt;(</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 创建 bean</span></span><br><span class="line">                            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                            <span class="comment">// 由于可能已经提前暴露，需要显示地销毁                </span></span><br><span class="line">                            destroySingleton(beanName);</span><br><span class="line">                            <span class="keyword">throw</span> ex;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">            <span class="comment">// 如果是原型类型，每次都新创建一个</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果是其他 scope 类型</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">        cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getSingleton"><a href="#getSingleton" class="headerlink" title="getSingleton"></a>getSingleton</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">        <span class="comment">// 再次从缓存中获取（和调用前从缓存中获取构成双重校验）</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.singletonsCurrentlyInDestruction) &#123;</span><br><span class="line">                <span class="comment">// 如果正在销毁单例，则抛异常</span></span><br><span class="line">                <span class="comment">// 注意：不要在销毁方法中调用获取 bean 方法</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 创建前，先注册到正在创建中的集合</span></span><br><span class="line">            <span class="comment">// 在出现循环引用时，第二次进入 doGetBean，用此作为判断标志</span></span><br><span class="line">            beforeSingletonCreation(beanName);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">newSingleton</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 使用传入的单例工厂创建对象</span></span><br><span class="line">                singletonObject = singletonFactory.getObject();</span><br><span class="line">                newSingleton = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">                <span class="comment">// 如果异常的出现是因为 bean 被创建了，就忽略异常，否则抛出异常</span></span><br><span class="line">                singletonObject = <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="comment">// 创建后，从正在创建中集合移除</span></span><br><span class="line">                afterSingletonCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">                <span class="comment">// 添加单例到缓存</span></span><br><span class="line">                addSingleton(beanName, singletonObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建-Bean"><a href="#创建-Bean" class="headerlink" title="创建 Bean"></a>创建 Bean</h2><p>createBean 是创建 Bean 的入口方法，由 AbstractBeanFactory 定义，由 AbstractAutowireCapableBeanFactory 实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 给 Bean 后置处理器一个返回代理的机会</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 常规的创建 Bean</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">beanInstance</span> <span class="operator">=</span> doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">    <span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="doCreateBean"><a href="#doCreateBean" class="headerlink" title="doCreateBean"></a>doCreateBean</h3><p>常规的创建 Bean 的具体工作是由 doCreateBean 完成的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> Object[] args)</span> <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line">    <span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        instanceWrapper = <span class="built_in">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用相应的策略创建 bean 实例，例如通过工厂方法或者有参、无参构造器方法</span></span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> (instanceWrapper != <span class="literal">null</span> ? instanceWrapper.getWrappedInstance() : <span class="literal">null</span>);</span><br><span class="line">    Class&lt;?&gt; beanType = (instanceWrapper != <span class="literal">null</span> ? instanceWrapper.getWrappedClass() : <span class="literal">null</span>);</span><br><span class="line">    mbd.resolvedTargetType = beanType;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 ObjectFactory 封装实例并缓存，以解决循环引用问题</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() </span><br><span class="line">        &amp;&amp; <span class="built_in">this</span>.allowCircularReferences </span><br><span class="line">        &amp;&amp; isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        addSingletonFactory(beanName, <span class="keyword">new</span> <span class="title class_">ObjectFactory</span>&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">                <span class="keyword">return</span> getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 填充属性（包括解析依赖的 bean）</span></span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="keyword">if</span> (exposedObject != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 初始化 bean</span></span><br><span class="line">            exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如有需要，将 bean 注册为一次性的，以供 beanFactory 在关闭时调用销毁方法</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="createBeanInstance"><a href="#createBeanInstance" class="headerlink" title="createBeanInstance"></a>createBeanInstance</h4><p>创建 Bean 实例，并使用 BeanWrapper 封装。实例化的方式：</p>
<ol>
<li>工厂方法</li>
<li>构造器方法<ol>
<li>有参</li>
<li>无参</li>
</ol>
</li>
</ol>
<h4 id="populateBean"><a href="#populateBean" class="headerlink" title="populateBean"></a>populateBean</h4><p>为创建出的实例填充属性，包括解析当前 bean 所依赖的 bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, BeanWrapper bw)</span> &#123;</span><br><span class="line">    <span class="type">PropertyValues</span> <span class="variable">pvs</span> <span class="operator">=</span> mbd.getPropertyValues();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 给 InstantiationAwareBeanPostProcessors 一个机会，</span></span><br><span class="line">    <span class="comment">// 在设置 bean 属性前修改 bean 状态，可用于自定义的字段注入</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">continueWithPropertyPopulation</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                <span class="type">InstantiationAwareBeanPostProcessor</span> <span class="variable">ibp</span> <span class="operator">=</span> (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                <span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">                    continueWithPropertyPopulation = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否继续填充属性的流程</span></span><br><span class="line">    <span class="keyword">if</span> (!continueWithPropertyPopulation) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME</span><br><span class="line">        || mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">        <span class="type">MutablePropertyValues</span> <span class="variable">newPvs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MutablePropertyValues</span>(pvs);</span><br><span class="line">        <span class="comment">// 根据名称注入</span></span><br><span class="line">        <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">            autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据类型注入</span></span><br><span class="line">        <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">            autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">        &#125;</span><br><span class="line">        pvs = newPvs;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否存在 InstantiationAwareBeanPostProcessors</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">hasInstAwareBpps</span> <span class="operator">=</span> hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">    <span class="comment">// 是否需要检查依赖</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">needsDepCheck</span> <span class="operator">=</span> (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (hasInstAwareBpps || needsDepCheck) &#123;</span><br><span class="line">        PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">        <span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">            <span class="comment">// 后置处理 PropertyValues</span></span><br><span class="line">            <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                    <span class="type">InstantiationAwareBeanPostProcessor</span> <span class="variable">ibp</span> <span class="operator">=</span> (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                    pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">                    <span class="keyword">if</span> (pvs == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">            checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将属性应用到 bean 上（常规情况下，前面的处理都用不上）</span></span><br><span class="line">    applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="initializeBean"><a href="#initializeBean" class="headerlink" title="initializeBean"></a>initializeBean</h4><p>在填充完属性后，实例就可以进行初始化工作：</p>
<ol>
<li>invokeAwareMethods，让 Bean 通过 xxxAware 接口感知一些信息</li>
<li>调用 BeanPostProcessor 的 postProcessBeforeInitialization 方法</li>
<li>invokeInitMethods，调用初始化方法</li>
<li>调用 BeanPostProcessor 的 postProcessAfterInitialization 方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, RootBeanDefinition mbd)</span> &#123;</span><br><span class="line">    <span class="comment">// 处理 Aware 接口的相应方法</span></span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                invokeAwareMethods(beanName, bean);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, getAccessControlContext());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        invokeAwareMethods(beanName, bean);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 应用 BeanPostProcessor 的 postProcessBeforeInitialization 方法</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">wrappedBean</span> <span class="operator">=</span> bean;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="literal">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用初始化方法</span></span><br><span class="line">        invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">            (mbd != <span class="literal">null</span> ? mbd.getResourceDescription() : <span class="literal">null</span>),</span><br><span class="line">            beanName, <span class="string">&quot;Invocation of init method failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="literal">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        <span class="comment">// 应用 BeanPostProcessor 的 postProcessAfterInitialization 方法</span></span><br><span class="line">        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="处理-Aware-接口的相应方法"><a href="#处理-Aware-接口的相应方法" class="headerlink" title="处理 Aware 接口的相应方法"></a>处理 Aware 接口的相应方法</h5><p>让 Bean 在初始化中，感知（获知）和自身相关的资源，如 beanName、beanClassLoader 或者 beanFactory。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">invokeAwareMethods</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanNameAware) &#123;</span><br><span class="line">            ((BeanNameAware) bean).setBeanName(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanClassLoaderAware) &#123;</span><br><span class="line">            ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanFactoryAware) &#123;</span><br><span class="line">            ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="调用初始化方法"><a href="#调用初始化方法" class="headerlink" title="调用初始化方法"></a>调用初始化方法</h5><ol>
<li>如果 bean 实现 InitializingBean 接口，调用 afterPropertiesSet 方法</li>
<li>如果自定义 init 方法且满足调用条件，同样进行调用</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">invokeInitMethods</span><span class="params">(String beanName, <span class="keyword">final</span> Object bean, RootBeanDefinition mbd)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// 是否实现 InitializingBean 接口，是的话调用 afterPropertiesSet 方法</span></span><br><span class="line">    <span class="comment">// 给 bean 一个感知属性已设置并做出反应的机会</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isInitializingBean</span> <span class="operator">=</span> (bean <span class="keyword">instanceof</span> InitializingBean);</span><br><span class="line">    <span class="keyword">if</span> (isInitializingBean</span><br><span class="line">        &amp;&amp; (mbd == <span class="literal">null</span> || !mbd.isExternallyManagedInitMethod(<span class="string">&quot;afterPropertiesSet&quot;</span>))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedExceptionAction</span>&lt;Object&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        ((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, getAccessControlContext());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">                <span class="keyword">throw</span> pae.getException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果存在自定义的 init 方法且方法名称不是 afterPropertiesSet，判断是否调用</span></span><br><span class="line">    <span class="keyword">if</span> (mbd != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">initMethodName</span> <span class="operator">=</span> mbd.getInitMethodName();</span><br><span class="line">        <span class="keyword">if</span> (initMethodName != <span class="literal">null</span></span><br><span class="line">            &amp;&amp; !(isInitializingBean &amp;&amp; <span class="string">&quot;afterPropertiesSet&quot;</span>.equals(initMethodName))</span><br><span class="line">            &amp;&amp; !mbd.isExternallyManagedInitMethod(initMethodName)) &#123;</span><br><span class="line">            invokeCustomInitMethod(beanName, bean, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="BeanPostProcessor-处理"><a href="#BeanPostProcessor-处理" class="headerlink" title="BeanPostProcessor 处理"></a>BeanPostProcessor 处理</h5><p>在调用初始化方法前后，BeanPostProcessor 先后进行两次处理。其实和 BeanPostProcessor 相关的代码都非常相似：</p>
<ol>
<li>获取 Processor 列表</li>
<li>判断 Processor 类型是否是当前需要的</li>
<li>对 bean 进行处理</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">applyBeanPostProcessorsBeforeInitialization</span><span class="params">(Object existingBean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> existingBean;</span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">        result = beanProcessor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">applyBeanPostProcessorsAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> existingBean;</span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">        result = beanProcessor.postProcessAfterInitialization(result, beanName);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="再思-Bean-的初始化"><a href="#再思-Bean-的初始化" class="headerlink" title="再思 Bean 的初始化"></a>再思 Bean 的初始化</h4><p>以下代码片段一度让我困惑，从注释看，初始化 Bean 实例的工作包括了 populateBean 和 initializeBean，但是 initializeBean 方法的含义就是初始化 Bean。在 initializeBean 方法中，调用了 invokeInitMethods 方法，其含义仍然是调用初始化方法。<br>在更熟悉代码后，我有一种微妙的、个人性的体会，在 Spring 源码中，有时候视角的变化是很快的，痕迹是很小的。如果不加以理解和区分，很容易迷失在相似的描述中。以此处为例，“初始化 Bean 和 Bean 的初始化”扩展开来是 “Bean 工厂初始化一个 Bean 和 Bean 自身进行初始化”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Initialize the bean instance.</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">    <span class="keyword">if</span> (exposedObject != <span class="literal">null</span>) &#123;</span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在注释这一行，视角是属于 BeanFactory（AbstractAutowireCapableBeanFactory）。从工厂的视角，面对一个刚刚创建出来的 Bean 实例，需要完成两方面的工作：</p>
<ol>
<li>为 Bean 实例填充属性，包括解析依赖，为 Bean 自身的初始化做好准备。</li>
<li>Bean 自身的初始化。</li>
</ol>
<p>在万事俱备之后，就是 Bean 自身的初始化工作。由于 Spring 的高度扩展性，这部分并不只是单纯地调用初始化方法，还包含 Aware 接口和 BeanPostProcessor 的相关处理，前者偏属于 Java 对象层面，后者偏属于 Spring Bean 层面。<br>在认同 BeanPostProcessor 的处理属于 Bean 自身初始化工作的一部分后，@PostConstruct 注解的方法被称为 Bean 的初始化方法也就不那么违和了，因为它的实现原理正是 BeanPostProcessor，这仍然在 initializeBean 的范围内。</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 类加载器源码分析</title>
    <url>/2023/07/13/Java-class-loader-source-code-analysis/</url>
    <content><![CDATA[<h3 id="组织类加载工作：loadClass"><a href="#组织类加载工作：loadClass" class="headerlink" title="组织类加载工作：loadClass"></a>组织类加载工作：loadClass</h3><p>当 <code>Java</code> 程序启动的时候，<code>Java</code> 虚拟机会调用 <code>java.lang.ClassLoader#loadClass(java.lang.String)</code> 加载 <code>main</code> 方法所在的类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">return</span> loadClass(name, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据注释可知，此方法加载具有指定二进制名称的类，它由 <code>Java</code> 虚拟机调用来解析类引用，调用它等同于调用 <code>loadClass(name, false)</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 以二进制名称获取类加载的锁进行同步</span></span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        <span class="comment">// 首先检查类是否已加载，根据该方法注释可知：</span></span><br><span class="line">        <span class="comment">// 如果当前类加载器已经被 Java 虚拟机记录为具有该二进制名称的类的加载器（initiating loader），Java 虚拟机可以直接返回 Class 对象。</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果类还未加载，先委派给父·类加载器进行加载，如果父·类加载器为 null，则使用虚拟机内建的类加载器进行加载</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 递归调用</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 递归调用的终结点</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                <span class="comment">// 当父·类加载器长尝试加载但是失败，捕获异常但是什么都不做，因为接下来，当前类加载器需要自己也尝试加载。</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                <span class="comment">// 父·类加载器未找到类，当前类加载器自己找。</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据注释可知，<code>java.lang.ClassLoader#loadClass(java.lang.String, boolean)</code> 同样是加载“具有指定二进制名称的类”，此方法的实现按以下顺序搜索类：</p>
<ol>
<li>调用 <code>findLoadedClass(String)</code> 以检查该类是否已加载。</li>
<li>在父·类加载器上调用 <code>loadClass</code> 方法。如果父·类加载器为空，则使用虚拟机内置的类加载器。</li>
<li>调用 <code>findClass(String)</code> 方法来查找该类。</li>
</ol>
<p>如果使用上述步骤找到了该类（找到并定义类），并且解析标志为 <code>true</code>，则此方法将对生成的 <code>Class</code> 对象调用 <code>resolveClass(Class)</code> 方法。鼓励 <code>ClassLoader</code> 的子类重写 <code>findClass(String)</code>，而不是此方法。除非被重写，否则此方法在整个类加载过程中以 <code>getClassLoadingLock</code> 方法的结果进行同步。</p>
<blockquote>
<p>注意：<strong>父·类加载器</strong>并非<strong>父类·类加载器</strong>（当前类加载器的父类），而是当前的类加载器的 <code>parent</code> 属性被赋值另外一个类加载器实例，其含义更接近于“可以委派类加载工作的另一个类加载器（一个帮忙干活的上级）”。虽然绝大多数说法中，当一个类加载器的 <code>parent</code> 值为 <code>null</code> 时，它的父·类加载器是引导类加载器（<code>bootstrap class loader</code>），但是当看到 <code>findBootstrapClassOrNull</code> 方法时，我有点困惑，因为我以为会看到语义类似于 <code>loadClassByBootstrapClassLoader</code> 这样的方法名。从注释和代码的语义上看，<code>bootstrap class loader</code> 不像是任何一个类加载器的父·类加载器，但是从类加载的机制设计上说，它是，只是因为它并非由 Java 语言编写而成，不能实例化并赋值给 <code>parent</code> 属性。<code>findBootstrapClassOrNull</code> 方法的语义更接近于：当一个类加载器的父·类加载器为 <code>null</code> 时，将准备加载的目标类先当作启动类（<code>Bootstrap Class</code>）尝试查找，如果找不到就返回 <code>null</code>。</p>
</blockquote>
<h4 id="怎么并行地加载类-getClassLoadingLock"><a href="#怎么并行地加载类-getClassLoadingLock" class="headerlink" title="怎么并行地加载类 getClassLoadingLock"></a>怎么并行地加载类 getClassLoadingLock</h4><p>需要加载的类可能很多很多，我们很容易想到如果可以并行地加载类就好了。显然，<code>JDK</code> 的编写者考虑到了这一点。<br>此方法返回类加载操作的锁对象。为了向后兼容，此方法的默认实现的行为如下。如果此 <code>ClassLoader</code> 对象注册为具备并行能力，则该方法返回与指定类名关联的专用对象。 否则，该方法返回此 <code>ClassLoader</code> 对象。<br>简单地说，如果 <code>ClassLoader</code> 对象注册为具备并行能力，那么一个 <code>name</code> 一个锁对象，已创建的锁对象保存在 <code>ConcurrentHashMap</code> 类型的 <code>parallelLockMap</code> 中，这样类加载工作可以并行；否则所有类加载工作共用一个锁对象，就是 <code>ClassLoader</code> 对象本身。<br>这个方案意味着非同名的目标类可以认为在加载时没有冲突？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getClassLoadingLock</span><span class="params">(String className)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (parallelLockMap != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">newLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        lock = parallelLockMap.putIfAbsent(className, newLock);</span><br><span class="line">        <span class="keyword">if</span> (lock == <span class="literal">null</span>) &#123;</span><br><span class="line">            lock = newLock;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="什么是-“ClassLoader-对象注册为具有并行能力”呢？"><a href="#什么是-“ClassLoader-对象注册为具有并行能力”呢？" class="headerlink" title="什么是 “ClassLoader 对象注册为具有并行能力”呢？"></a>什么是 “<code>ClassLoader</code> 对象注册为具有并行能力”呢？</h5><p><code>AppClassLoader</code> 中有一段 <code>static</code> 代码。事实上 <code>java.lang.ClassLoader#registerAsParallelCapable</code> 是将 <code>ClassLoader</code> 对象注册为具有并行能力唯一的入口。因此，所有想要注册为具有并行能力的 <code>ClassLoader</code> 都需要调用一次该方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    ClassLoader.registerAsParallelCapable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>java.lang.ClassLoader#registerAsParallelCapable</code> 方法有一个注解 <code>@CallerSensitive</code>，这是因为它的代码中调用的 <code>native</code> 方法 <code>sun.reflect.Reflection#getCallerClass()</code> 方法。由注释可知，当且仅当以下所有条件全部满足时才注册成功：</p>
<ol>
<li>尚未创建调用者的实例（类加载器尚未实例化）</li>
<li>调用者的所有超类（<code>Object</code> 类除外）都注册为具有并行能力。</li>
</ol>
<h5 id="怎么保证这两个条件成立呢？"><a href="#怎么保证这两个条件成立呢？" class="headerlink" title="怎么保证这两个条件成立呢？"></a>怎么保证这两个条件成立呢？</h5><ol>
<li>对于第一个条件，可以通过将调用的代码写在 <code>static</code> 代码块中来实现。如果写在构造器方法里，并且通过单例模式保证只实例化一次可以吗？答案是不行的，后续会解释这个“注册”行为在构造器方法中是如何被使用以及为何不能写在构造器方法里。</li>
<li>对于第二个条件，由于 <code>Java</code> 虚拟机加载类时，总是会先尝试加载其父类，又因为加载类时会先调用 <code>static</code> 代码块，因此父类的 <code>static</code> 代码块总是先于子类的 <code>static</code> 代码块。</li>
</ol>
<p>你可以看到 <code>AppClassLoader-&gt;URLClassLoader-&gt;SecureClassLoader-&gt;ClassLoader</code> 均在 <code>static</code> 代码块实现注册，以保证满足以上两个条件。</p>
<h5 id="注册工作做了什么？"><a href="#注册工作做了什么？" class="headerlink" title="注册工作做了什么？"></a>注册工作做了什么？</h5><p>简单地说就是保存了类加载器所属 <code>Class</code> 的 <code>Set</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">registerAsParallelCapable</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获得此方法的调用者的 Class 实例，asSubClass 可以将 Class&lt;?&gt; 类型的 Class 转换为代表指定类的子类的 Class&lt;? extends U&gt; 类型的 Class。</span></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">ClassLoader</span>&gt; callerClass =</span><br><span class="line">        Reflection.getCallerClass().asSubclass(ClassLoader.class);</span><br><span class="line">    <span class="comment">// 注册调用者的 Class 为具有并行能力</span></span><br><span class="line">    <span class="keyword">return</span> ParallelLoaders.register(callerClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法 <code>java.lang.ClassLoader.ParallelLoaders#register</code>。<code>ParallelLoaders</code> 封装了一组具有并行能力的加载器类型。就是持有 <code>ClassLoader</code> 的 <code>Class</code> 实例的集合，并保证添加时加同步锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// private 修饰，只有其外部类 ClassLoader 才可以使用</span></span><br><span class="line"><span class="comment">// static 修饰，内部类如果需要定义 static 方法或者 static 变量，必须用 static 修饰</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ParallelLoaders</span> &#123;</span><br><span class="line">    <span class="comment">// private 修饰构造器方法，不希望这个类被实例化，只想要使用它的静态变量和方法。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ParallelLoaders</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the set of parallel capable loader types</span></span><br><span class="line">    <span class="comment">// 使用 loaderTypes 时通过 synchronized 加同步锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">ClassLoader</span>&gt;&gt; loaderTypes =</span><br><span class="line">        Collections.newSetFromMap(</span><br><span class="line">            <span class="comment">// todo: 为什么使用弱引用来实现？为了卸载类时的垃圾回收？</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">ClassLoader</span>&gt;, Boolean&gt;());</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 将 ClassLoader 本身注册为具有并行能力</span></span><br><span class="line">        <span class="keyword">synchronized</span> (loaderTypes) &#123; loaderTypes.add(ClassLoader.class); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Registers the given class loader type as parallel capabale.</span></span><br><span class="line"><span class="comment">     * Returns &#123;<span class="doctag">@code</span> true&#125; is successfully registered; &#123;<span class="doctag">@code</span> false&#125; if</span></span><br><span class="line"><span class="comment">     * loader&#x27;s super class is not registered.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">register</span><span class="params">(Class&lt;? extends ClassLoader&gt; c)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (loaderTypes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (loaderTypes.contains(c.getSuperclass())) &#123;</span><br><span class="line">                <span class="comment">// register the class loader as parallel capable</span></span><br><span class="line">                <span class="comment">// if and only if all of its super classes are.</span></span><br><span class="line">                <span class="comment">// Note: given current classloading sequence, if</span></span><br><span class="line">                <span class="comment">// the immediate super class is parallel capable,</span></span><br><span class="line">                <span class="comment">// all the super classes higher up must be too.</span></span><br><span class="line">                <span class="comment">// 当且仅当其所有超类都具有并行能力时，才将类加载器注册为具有并行能力。</span></span><br><span class="line">                <span class="comment">// 注意：给定当前的类加载顺序（加载类时，Java 虚拟机总是先尝试加载其父类），如果直接超类具有并行能力，则所有更高的超类也必然具有并行能力。</span></span><br><span class="line">                loaderTypes.add(c);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &#123;<span class="doctag">@code</span> true&#125; if the given class loader type is</span></span><br><span class="line"><span class="comment">     * registered as parallel capable.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isRegistered</span><span class="params">(Class&lt;? extends ClassLoader&gt; c)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (loaderTypes) &#123;</span><br><span class="line">            <span class="keyword">return</span> loaderTypes.contains(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="“注册”怎么和锁产生联系？"><a href="#“注册”怎么和锁产生联系？" class="headerlink" title="“注册”怎么和锁产生联系？"></a>“注册”怎么和锁产生联系？</h5><p>但是以上的注册过程只是起到一个“标记”作用，没有涉及和锁相关的代码，那么这个“标记”是怎么和真正的锁产生联系呢？<code>ClassLoader</code> 提供了三个构造器方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">ClassLoader</span><span class="params">(Void unused, ClassLoader parent)</span> &#123;</span><br><span class="line">    <span class="comment">// 由 private 修饰，不允许子类重写</span></span><br><span class="line">    <span class="built_in">this</span>.parent = parent;</span><br><span class="line">    <span class="keyword">if</span> (ParallelLoaders.isRegistered(<span class="built_in">this</span>.getClass())) &#123;</span><br><span class="line">        <span class="comment">// 如果类加载器已经注册为具有并行能力，则做一些赋值操作</span></span><br><span class="line">        parallelLockMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 保存 package-&gt;certs 的 map 映射，相关的工作也可以并行进行</span></span><br><span class="line">        package2certs = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">        assertionLock = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// no finer-grained lock; lock on the classloader instance</span></span><br><span class="line">        parallelLockMap = <span class="literal">null</span>;</span><br><span class="line">        package2certs = <span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;&gt;();</span><br><span class="line">        assertionLock = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由 protect 修饰，允许子类重写，传递了父·类加载器。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">ClassLoader</span><span class="params">(ClassLoader parent)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(checkCreateClassLoader(), parent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由 protect 修饰，允许子类重写，父·类加载器使用 getSystemClassLoader 方法返回的系统类加载器。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">ClassLoader</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(checkCreateClassLoader(), getSystemClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ClassLoader</code> 的构造器方法最终都调用 <code>private</code> 修饰的 <code>java.lang.ClassLoader#ClassLoader(java.lang.Void, java.lang.ClassLoader)</code>，又因为父类的构造器方法总是先于子类的构造器方法被执行，这样一来，所有继承 <code>ClassLoader</code> 的类加载器在创建的时候都会根据在创建实例之前是否注册为具有并行能力而做不同的操作。</p>
<h5 id="为什么注册的代码不能写在构造器方法里？"><a href="#为什么注册的代码不能写在构造器方法里？" class="headerlink" title="为什么注册的代码不能写在构造器方法里？"></a>为什么注册的代码不能写在构造器方法里？</h5><p>使用“注册”的代码也解释了 <code>java.lang.ClassLoader#registerAsParallelCapable</code> 为了满足调用成功的第一个条件为什么不能写在构造器方法中，因为使用这个机制的代码先于你在子类构造器方法里编写的代码被执行。<br>同时，不论是 <code>loadLoader</code> 还是 <code>getClassLoadingLock</code> 都是由 <code>protect</code> 修饰，允许子类重写，来自定义并行加载类的能力。</p>
<blockquote>
<p>todo: 讨论自定义类加载器的时候，印象里似乎对并行加载类的提及比较少，之后留意一下。</p>
</blockquote>
<h4 id="检查目标类是否已加载"><a href="#检查目标类是否已加载" class="headerlink" title="检查目标类是否已加载"></a>检查目标类是否已加载</h4><p>加载类之前显然需要检查目标类是否已加载，这项工作最终是交给 <code>native</code> 方法，在虚拟机中执行，就像在黑盒中一样。<br>todo: 不同类加载器同一个类名会如何判定？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass(String name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!checkName(name))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> findLoadedClass0(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass0(String name);</span><br></pre></td></tr></table></figure>

<h4 id="保证核心类库的安全性：双亲委派模型"><a href="#保证核心类库的安全性：双亲委派模型" class="headerlink" title="保证核心类库的安全性：双亲委派模型"></a>保证核心类库的安全性：双亲委派模型</h4><p>正如在代码和注释中所看到的，正常情况下，类的加载工作先委派给自己的父·类加载器，即 <code>parent</code> 属性的值——另一个类加载器实例。一层一层向上委派直到 <code>parent</code> 为 <code>null</code>，代表类加载工作会尝试先委派给虚拟机内建的 <code>bootstrap class loader</code> 处理，然后由 <code>bootstrap class loader</code> 首先尝试加载。如果被委派方加载失败，委派方会自己再尝试加载。<br>正常加载类的是应用类加载器 <code>AppClassLoader</code>，它的 <code>parent</code> 为 <code>ExtClassLoader</code>，<code>ExtClassLoader</code> 的 <code>parent</code> 为 <code>null</code>。</p>
<blockquote>
<p>在网上也能看到有人提到以前大家称之为“父·类加载器委派机制”，“双亲”一词易引人误解。</p>
</blockquote>
<h5 id="为什么要用这套奇怪的机制"><a href="#为什么要用这套奇怪的机制" class="headerlink" title="为什么要用这套奇怪的机制"></a>为什么要用这套奇怪的机制</h5><p>这样设计很明显的一个目的就是保证核心类库的类加载安全性。比如 <code>Object</code> 类，设计者不希望编写代码的人重新写一个 <code>Object</code> 类并加载到 <code>Java</code> 虚拟机中，但是加载类的本质就是读取字节数据传递给 <code>Java</code> 虚拟机创建一个 <code>Class</code> 实例，使用这套机制的目的之一就是为了让核心类库先加载，同时先加载的类不会再次被加载。</p>
<p>通常流程如下：</p>
<ol>
<li><code>AppClassLoader</code> 调用 <code>loadClass</code> 方法，先委派给 <code>ExtClassLoader</code>。</li>
<li><code>ExtClassLoader</code> 调用 <code>loadClass</code> 方法，先委派给 <code>bootstrap class loader</code>。</li>
<li><code>bootstrap class loader</code> 在其设置的类路径中无法找到 <code>BananaTest</code> 类，抛出 <code>ClassNotFoundException</code> 异常。</li>
<li><code>ExtClassLoader</code> 捕获异常，然后自己调用 <code>findClass</code> 方法尝试进行加载。</li>
<li><code>ExtClassLoader</code> 在其设置的类路径中无法找到 <code>BananaTest</code> 类，抛出 <code>ClassNotFoundException</code> 异常。</li>
<li><code>AppClassLoader</code> 捕获异常，然后自己调用 <code>findClass</code> 方法尝试进行加载。</li>
</ol>
<p>注释中提到鼓励重写 <code>findClass</code> 方法而不是 <code>loadClass</code>，因为正是该方法实现了所谓的“双亲委派模型”，<code>java.lang.ClassLoader#findClass</code> 实现了如何查找加载类。如果不是专门为了破坏这个类加载模型，应该选择重写 <code>findClass</code>；其次是因为该方法中涉及并行加载类的机制。</p>
<h3 id="查找类资源：findClass"><a href="#查找类资源：findClass" class="headerlink" title="查找类资源：findClass"></a>查找类资源：findClass</h3><p>默认情况下，类加载器在自己尝试进行加载时，会调用 <code>java.lang.ClassLoader#findClass</code> 方法，该方法由子类重写。<code>AppClassLoader</code> 和 <code>ExtClassLoader</code> 都是继承 <code>URLClassLoader</code>，而 <code>URLClassLoader</code> 重写了 <code>findClass</code> 方法。根据注释可知，该方法会从 <code>URL</code> 搜索路径查找并加载具有指定名称的类。任何引用 <code>Jar</code> 文件的 <code>URL</code> 都会根据需要加载并打开，直到找到该类。</p>
<p>过程如下：</p>
<ol>
<li>将 <code>name</code> 转换为 <code>path</code>，比如 <code>com.example.BananaTest</code> 转换为 <code>com/example/BananaTest.class</code>。</li>
<li>使用 <code>URL</code> 搜索路径 <code>URLClassPath</code> 和 <code>path</code> 中获取 <code>Resource</code>，本质上就是轮流将可能存放的目录列表拼接上文件路径进行查找。</li>
<li>调用 <code>URLClassLoader</code> 的私有方法 <code>defineClass</code>，该方法调用父类 <code>SecureClassLoader</code> 的 <code>defineClass</code> 方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(<span class="keyword">final</span> String name)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// todo:</span></span><br><span class="line">        result = AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PrivilegedExceptionAction</span>&lt;Class&lt;?&gt;&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> Class&lt;?&gt; run() <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">                    <span class="comment">// 将 name 转换为 path</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> name.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>).concat(<span class="string">&quot;.class&quot;</span>);</span><br><span class="line">                    <span class="comment">// 从 URLClassPath 中查找 Resource</span></span><br><span class="line">                    <span class="type">Resource</span> <span class="variable">res</span> <span class="operator">=</span> ucp.getResource(path, <span class="literal">false</span>);</span><br><span class="line">                    <span class="keyword">if</span> (res != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> defineClass(name, res);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name, e);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (ClassFormatError e2) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (res.getDataError() != <span class="literal">null</span>) &#123;</span><br><span class="line">                                e2.addSuppressed(res.getDataError());</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">throw</span> e2;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, acc);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.security.PrivilegedActionException pae) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (ClassNotFoundException) pae.getException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="查找类的目录列表：URLClassPath"><a href="#查找类的目录列表：URLClassPath" class="headerlink" title="查找类的目录列表：URLClassPath"></a>查找类的目录列表：URLClassPath</h4><p><code>URLClassLoader</code> 拥有一个 <code>URLClassPath</code> 类型的属性 <code>ucp</code>。由注释可知，<code>URLClassPath</code> 类用于维护一个 <code>URL</code> 的搜索路径，以便从 <code>Jar</code> 文件和目录中加载类和资源。<br><code>URLClassPath</code> 的核心构造器方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">URLClassPath</span><span class="params">(URL[] urls,</span></span><br><span class="line"><span class="params">                    URLStreamHandlerFactory factory,</span></span><br><span class="line"><span class="params">                    AccessControlContext acc)</span> &#123;</span><br><span class="line">    <span class="comment">// 将 urls 保存到 ArrayList 类型的属性 path 中，根据注释，path 的含义为 URL 的原始搜索路径。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; urls.length; i++) &#123;</span><br><span class="line">        path.add(urls[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将 urls 保存到 Stack 类型的属性 urls 中，根据注释，urls 的含义为未打开的 URL 列表。</span></span><br><span class="line">    push(urls);</span><br><span class="line">    <span class="keyword">if</span> (factory != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果 factory 不为 null，使用它创建一个 URLStreamHandler 实例处理 Jar 文件。</span></span><br><span class="line">        jarHandler = factory.createURLStreamHandler(<span class="string">&quot;jar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (DISABLE_ACC_CHECKING)</span><br><span class="line">        <span class="built_in">this</span>.acc = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">this</span>.acc = acc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="URLClassPath-getResource"><a href="#URLClassPath-getResource" class="headerlink" title="URLClassPath#getResource"></a>URLClassPath#getResource</h5><p><code>URLClassLoader</code> 调用 <code>sun.misc.URLClassPath#getResource(java.lang.String, boolean)</code> 方法获取指定名称对应的资源。根据注释，该方法会查找 <code>URL</code> 搜索路径上的第一个资源，如果找不到资源，则返回 <code>null</code>。<br>显然，这里的 <code>Loader</code> 不是我们前面提到的类加载器。<code>Loader</code> 是 <code>URLClassPath</code> 的内部类，用于表示根据一个基本 <code>URL</code> 创建的资源和类的加载器。也就是说一个基本 <code>URL</code> 对应一个 <code>Loader</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Resource <span class="title function_">getResource</span><span class="params">(String name, <span class="type">boolean</span> check)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;URLClassPath.getResource(\&quot;&quot;</span> + name + <span class="string">&quot;\&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Loader loader;</span><br><span class="line">    <span class="comment">// 获取缓存（默认没有用）</span></span><br><span class="line">    <span class="type">int</span>[] cache = getLookupCache(name);</span><br><span class="line">    <span class="comment">// 不断获取下一个 Loader 来获取 Resource，直到获取到或者没有下一个 Loader</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; (loader = getNextLoader(cache, i)) != <span class="literal">null</span>; i++) &#123;</span><br><span class="line">        <span class="type">Resource</span> <span class="variable">res</span> <span class="operator">=</span> loader.getResource(name, check);</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="URLClassPath-getNextLoader"><a href="#URLClassPath-getNextLoader" class="headerlink" title="URLClassPath#getNextLoader"></a>URLClassPath#getNextLoader</h5><p>获取下一个 <code>Loader</code>，其实根据 <code>index</code> 从一个存放已创建 <code>Loader</code> 的 <code>ArrayList</code> 中获取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> Loader <span class="title function_">getNextLoader</span><span class="params">(<span class="type">int</span>[] cache, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; cache.length) &#123;</span><br><span class="line">            <span class="type">Loader</span> <span class="variable">loader</span> <span class="operator">=</span> loaders.get(cache[index]);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_LOOKUP_CACHE) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;HASCACHE: Loading from : &quot;</span> + cache[index]</span><br><span class="line">                                    + <span class="string">&quot; = &quot;</span> + loader.getBaseURL());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> loader;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// finished iterating over cache[]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取 Loader</span></span><br><span class="line">        <span class="keyword">return</span> getLoader(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="URLClassPath-getLoader-int"><a href="#URLClassPath-getLoader-int" class="headerlink" title="URLClassPath#getLoader(int)"></a>URLClassPath#getLoader(int)</h5><ol>
<li>用 <code>index</code> 到存放已创建 <code>Loader</code> 的列表中去获取（调用方传入的 <code>index</code> 从 <code>0</code> 开始不断递增直到超过范围）。</li>
<li>如果 <code>index</code> 超过范围，说明已有的 <code>Loader</code> 都找不到目标 <code>Resource</code>，需要到未打开的 <code>URL</code> 中查找。</li>
<li>从未打开的 <code>URL</code> 中取出（<code>pop</code>）一个来创建 <code>Loader</code>，如果 <code>urls</code> 已经为空，则返回 <code>null</code>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> Loader <span class="title function_">getLoader</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Expand URL search path until the request can be satisfied</span></span><br><span class="line">    <span class="comment">// or the URL stack is empty.</span></span><br><span class="line">    <span class="keyword">while</span> (loaders.size() &lt; index + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// Pop the next URL from the URL stack</span></span><br><span class="line">        <span class="comment">// 如果 index 超过数组范围，需要从未打开的 URL 中取出一个，创建 Loader 并返回</span></span><br><span class="line">        URL url;</span><br><span class="line">        <span class="keyword">synchronized</span> (urls) &#123;</span><br><span class="line">            <span class="keyword">if</span> (urls.empty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                url = urls.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Skip this URL if it already has a Loader. (Loader</span></span><br><span class="line">        <span class="comment">// may be null in the case where URL has not been opened</span></span><br><span class="line">        <span class="comment">// but is referenced by a JAR index.)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">urlNoFragString</span> <span class="operator">=</span> URLUtil.urlNoFragString(url);</span><br><span class="line">        <span class="keyword">if</span> (lmap.containsKey(urlNoFragString)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Otherwise, create a new Loader for the URL.</span></span><br><span class="line">        Loader loader;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 根据 URL 创建 Loader</span></span><br><span class="line">            loader = getLoader(url);</span><br><span class="line">            <span class="comment">// If the loader defines a local class path then add the</span></span><br><span class="line">            <span class="comment">// URLs to the list of URLs to be opened.</span></span><br><span class="line">            URL[] urls = loader.getClassPath();</span><br><span class="line">            <span class="keyword">if</span> (urls != <span class="literal">null</span>) &#123;</span><br><span class="line">                push(urls);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// Silently ignore for now...</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException se) &#123;</span><br><span class="line">            <span class="comment">// Always silently ignore. The context, if there is one, that</span></span><br><span class="line">            <span class="comment">// this URLClassPath was given during construction will never</span></span><br><span class="line">            <span class="comment">// have permission to access the URL.</span></span><br><span class="line">            <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;Failed to access &quot;</span> + url + <span class="string">&quot;, &quot;</span> + se );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Finally, add the Loader to the search path.</span></span><br><span class="line">        validateLookupCache(loaders.size(), urlNoFragString);</span><br><span class="line">        loaders.add(loader);</span><br><span class="line">        lmap.put(urlNoFragString, loader);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_LOOKUP_CACHE) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;NOCACHE: Loading from : &quot;</span> + index );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loaders.get(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="URLClassPath-getLoader-java-net-URL"><a href="#URLClassPath-getLoader-java-net-URL" class="headerlink" title="URLClassPath#getLoader(java.net.URL)"></a>URLClassPath#getLoader(java.net.URL)</h5><p>根据指定的 <code>URL</code> 创建 <code>Loader</code>，不同类型的 <code>URL</code> 会返回不同具体实现的 <code>Loader</code>。</p>
<ol>
<li>如果 <code>URL</code> 不是以 <code>/</code> 结尾，认为是 <code>Jar</code> 文件，则返回 <code>JarLoader</code> 类型，比如 <code>file:/C:/Users/xxx/.jdks/corretto-1.8.0_342/jre/lib/rt.jar</code>。</li>
<li>如果 <code>URL</code> 以 <code>/</code> 结尾，且协议为 <code>file</code>，则返回 <code>FileLoader</code> 类型，比如 <code>file:/C:/Users/xxx/IdeaProjects/java-test/target/classes/</code>。</li>
<li>如果 <code>URL</code> 以 <code>/</code> 结尾，且协议不会 <code>file</code>，则返回 <code>Loader</code> 类型。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Loader <span class="title function_">getLoader</span><span class="params">(<span class="keyword">final</span> URL url)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> java.security.AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">java</span>.security.PrivilegedExceptionAction&lt;Loader&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> Loader <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">file</span> <span class="operator">=</span> url.getFile();</span><br><span class="line">                <span class="keyword">if</span> (file != <span class="literal">null</span> &amp;&amp; file.endsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">&quot;file&quot;</span>.equals(url.getProtocol())) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FileLoader</span>(url);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Loader</span>(url);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JarLoader</span>(url, jarHandler, lmap, acc);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, acc);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.security.PrivilegedActionException pae) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (IOException)pae.getException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="URLClassPath-FileLoader-getResource"><a href="#URLClassPath-FileLoader-getResource" class="headerlink" title="URLClassPath.FileLoader#getResource"></a>URLClassPath.FileLoader#getResource</h4><p>以 <code>FileLoader</code> 的 <code>getResource</code> 为例，如果文件找到了，就会将文件包装成一个 <code>FileInputStream</code>，再将 <code>FileInputStream</code> 包装成一个 <code>Resource</code> 返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Resource <span class="title function_">getResource</span><span class="params">(<span class="keyword">final</span> String name, <span class="type">boolean</span> check)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> URL url;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">normalizedBase</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(getBaseURL(), <span class="string">&quot;.&quot;</span>);</span><br><span class="line">        url = <span class="keyword">new</span> <span class="title class_">URL</span>(getBaseURL(), ParseUtil.encodePath(name, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (url.getFile().startsWith(normalizedBase.getFile()) == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="comment">// requested resource had ../..&#x27;s in path</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (check)</span><br><span class="line">            URLClassPath.check(url);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> File file;</span><br><span class="line">        <span class="keyword">if</span> (name.indexOf(<span class="string">&quot;..&quot;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">            file = (<span class="keyword">new</span> <span class="title class_">File</span>(dir, name.replace(<span class="string">&#x27;/&#x27;</span>, File.separatorChar)))</span><br><span class="line">                    .getCanonicalFile();</span><br><span class="line">            <span class="keyword">if</span> ( !((file.getPath()).startsWith(dir.getPath())) ) &#123;</span><br><span class="line">                <span class="comment">/* outside of base dir */</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            file = <span class="keyword">new</span> <span class="title class_">File</span>(dir, name.replace(<span class="string">&#x27;/&#x27;</span>, File.separatorChar));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Resource</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; <span class="keyword">return</span> name; &#125;;</span><br><span class="line">                <span class="keyword">public</span> URL <span class="title function_">getURL</span><span class="params">()</span> &#123; <span class="keyword">return</span> url; &#125;;</span><br><span class="line">                <span class="keyword">public</span> URL <span class="title function_">getCodeSourceURL</span><span class="params">()</span> &#123; <span class="keyword">return</span> getBaseURL(); &#125;;</span><br><span class="line">                <span class="keyword">public</span> InputStream <span class="title function_">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br><span class="line">                    &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file); &#125;;</span><br><span class="line">                <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getContentLength</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br><span class="line">                    &#123; <span class="keyword">return</span> (<span class="type">int</span>)file.length(); &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ClassLoader-的搜索路径"><a href="#ClassLoader-的搜索路径" class="headerlink" title="ClassLoader 的搜索路径"></a>ClassLoader 的搜索路径</h4><p>从上文可知，<code>ClassLoader</code> 调用 <code>findClass</code> 方法查找类的时候，并不是漫无目的地查找，而是根据设置的类路径进行查找，不同的 <code>ClassLoader</code> 有不同的类路径。</p>
<p>以下是通过 <code>IDEA</code> 启动 <code>Java</code> 程序时的命令，可以看到其中通过 <code>-classpath</code> 指定了应用·类加载器 <code>AppClassLoader</code> 的类路径，该类路径除了包含常规的 <code>JRE</code> 的文件路径外，还额外添加了当前 <code>maven</code> 工程编译生成的 <code>target\classes</code> 目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">C:\Users\xxx\.jdks\corretto-1.8.0_342\bin\java.exe -agentlib:jdwp=transport=dt_socket,address=127.0.0.1:52959,suspend=y,server=n -javaagent:C:\Users\xxx\AppData\Local\JetBrains\IntelliJIdea2022.3\captureAgent\debugger-agent.jar -Dfile.encoding=UTF-8 -classpath &quot;C:\Users\xxx\.jdks\corretto-1.8.0_342\jre\lib\charsets.jar;C:\Users\xxx\.jdks\corretto-1.8.0_342\jre\lib\ext\access-bridge-64.jar;C:\Users\xxx\.jdks\corretto-1.8.0_342\jre\lib\ext\cldrdata.jar;C:\Users\xxx\.jdks\corretto-1.8.0_342\jre\lib\ext\dnsns.jar;C:\Users\xxx\.jdks\corretto-1.8.0_342\jre\lib\ext\jaccess.jar;C:\Users\xxx\.jdks\corretto-1.8.0_342\jre\lib\ext\jfxrt.jar;C:\Users\xxx\.jdks\corretto-1.8.0_342\jre\lib\ext\localedata.jar;C:\Users\xxx\.jdks\corretto-1.8.0_342\jre\lib\ext\nashorn.jar;C:\Users\xxx\.jdks\corretto-1.8.0_342\jre\lib\ext\sunec.jar;C:\Users\xxx\.jdks\corretto-1.8.0_342\jre\lib\ext\sunjce_provider.jar;C:\Users\xxx\.jdks\corretto-1.8.0_342\jre\lib\ext\sunmscapi.jar;C:\Users\xxx\.jdks\corretto-1.8.0_342\jre\lib\ext\sunpkcs11.jar;C:\Users\xxx\.jdks\corretto-1.8.0_342\jre\lib\ext\zipfs.jar;C:\Users\xxx\.jdks\corretto-1.8.0_342\jre\lib\jce.jar;C:\Users\xxx\.jdks\corretto-1.8.0_342\jre\lib\jfr.jar;C:\Users\xxx\.jdks\corretto-1.8.0_342\jre\lib\jfxswt.jar;C:\Users\xxx\.jdks\corretto-1.8.0_342\jre\lib\jsse.jar;C:\Users\xxx\.jdks\corretto-1.8.0_342\jre\lib\management-agent.jar;C:\Users\xxx\.jdks\corretto-1.8.0_342\jre\lib\resources.jar;C:\Users\xxx\.jdks\corretto-1.8.0_342\jre\lib\rt.jar;C:\Users\xxx\IdeaProjects\java-test\target\classes;C:\Program Files\JetBrains\IntelliJ IDEA 2022.3.3\lib\idea_rt.jar&quot; org.example.BananaTest</span><br></pre></td></tr></table></figure>

<h5 id="bootstrap-class-loader"><a href="#bootstrap-class-loader" class="headerlink" title="bootstrap class loader"></a>bootstrap class loader</h5><p>启动·类加载器 <code>bootstrap class loader</code>，加载核心类库，即 <code>&lt;JRE_HOME&gt;/lib</code> 目录中的部分类库，如 <code>rt.jar</code>，只有名字符合要求的 <code>jar</code> 才能被识别。 启动 Java 虚拟机时可以通过选项 <code>-Xbootclasspath</code> 修改默认的类路径，有三种使用方式：</p>
<ul>
<li><code>-Xbootclasspath:</code>：完全覆盖核心类库的类路径，不常用，除非重写核心类库。</li>
<li><code>-Xbootclasspath/a:</code> 以后缀的方式拼接在原搜索路径后面，常用。</li>
<li><code>-Xbootclasspath/p:</code> 以前缀的方式拼接再原搜索路径前面.不常用，避免引起不必要的冲突。</li>
</ul>
<p>在 <code>IDEA</code> 中编辑启动配置，添加 <code>VM</code> 选项，<code>-Xbootclasspath:C:\Software</code>，里面没有类文件，启动虚拟机失败，提示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Error occurred during initialization of VM</span><br><span class="line">java/lang/NoClassDefFoundError: java/lang/Object</span><br><span class="line"></span><br><span class="line">进程已结束,退出代码1</span><br></pre></td></tr></table></figure>

<h5 id="ExtClassLoader"><a href="#ExtClassLoader" class="headerlink" title="ExtClassLoader"></a>ExtClassLoader</h5><p>扩展·类加载器 <code>ExtClassLoader</code>，加载 <code>&lt;JRE_HOME&gt;/lib/ext/</code> 目录中的类库。启动 <code>Java</code> 虚拟机时可以通过选项 <code>-Djava.ext.dirs</code> 修改默认的类路径。显然修改不当同样可能会引起 <code>Java</code> 程序的异常。</p>
<h5 id="AppClassLoader"><a href="#AppClassLoader" class="headerlink" title="AppClassLoader"></a>AppClassLoader</h5><p>应用·类加载器 <code>AppClassLoader</code> ，加载应用级别的搜索路径中的类库。可以使用系统的环境变量 <code>CLASSPATH</code> 的值，也可以在启动 Java 虚拟机时通过选项 <code>-classpath</code> 修改。</p>
<p><code>CLASSPATH</code> 在 <code>Windows</code> 中，多个文件路径使用分号 <code>;</code> 分隔，而 <code>Linux</code> 中则使用冒号 <code>:</code> 分隔。以下例子表示当前目录和另一个文件路径拼接而成的类路径。</p>
<ul>
<li>Windows：<code>.;C:\path\to\classes</code></li>
<li>Linux：<code>.:/path/to/classes</code></li>
</ul>
<p>事实上，<code>AppClassLoader</code> 最终的类路径，不仅仅包含 <code>-classpath</code> 的值，还会包含 <code>-javaagent</code> 指定的值。</p>
<h3 id="字节数据转换为-Class-实例：defineClass"><a href="#字节数据转换为-Class-实例：defineClass" class="headerlink" title="字节数据转换为 Class 实例：defineClass"></a>字节数据转换为 Class 实例：defineClass</h3><p>方法 <code>defineClass</code>，顾名思义，就是定义类，将字节数据转换为 <code>Class</code> 实例。在 <code>ClassLoader</code> 以及其子类中有很多同名方法，方法内各种处理和包装，最终都是为了使用 <code>name</code> 和字节数据等参数，调用 <code>native</code> 方法获得一个 <code>Class</code> 实例。<br>以下是定义类时最终可能调用的 <code>native</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> Class&lt;?&gt; defineClass0(String name, <span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len,</span><br><span class="line">                                     ProtectionDomain pd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> Class&lt;?&gt; defineClass1(String name, <span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len,</span><br><span class="line">                                     ProtectionDomain pd, String source);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> Class&lt;?&gt; defineClass2(String name, java.nio.ByteBuffer b,</span><br><span class="line">                                     <span class="type">int</span> off, <span class="type">int</span> len, ProtectionDomain pd,</span><br><span class="line">                                     String source);</span><br></pre></td></tr></table></figure>

<p>其方法参数有：</p>
<ul>
<li><code>name</code>，目标类的名称。</li>
<li><code>byte[]</code> 或 <code>ByteBuffer</code> 类型的字节数据，<code>off</code> 和 <code>len</code> 只是为了定位传入的字节数组中关于目标类的字节数据，通常分别是 0 和字节数组的长度，毕竟专门构造一个包含无关数据的字节数组很无聊。</li>
<li><code>ProtectionDomain</code>，保护域，todo:</li>
<li><code>source</code>，<code>CodeSource</code> 的位置。</li>
</ul>
<p><code>defineClass</code> 方法的调用过程，其实就是从 <code>URLClassLoader</code> 开始，一层一层处理后再调用父类的 <code>defineClass</code> 方法，分别经过了 <code>SecureClassLoader</code> 和 <code>ClassLoader</code>。</p>
<h4 id="URLClassLoader-defineClass"><a href="#URLClassLoader-defineClass" class="headerlink" title="URLClassLoader#defineClass"></a>URLClassLoader#defineClass</h4><p>此方法是再 <code>URLClassLoader</code> 的 <code>findClass</code> 方法中，获得正确的 <code>Resource</code> 之后调用的，由 <code>private</code> 修饰。根据注释，它使用从指定资源获取的类字节来定义类，生成的类必须先解析才能使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; defineClass(String name, Resource res) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">    <span class="comment">// 获取最后一个 . 的位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> name.lastIndexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="comment">// 返回资源的 CodeSourceURL</span></span><br><span class="line">    <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> res.getCodeSourceURL();</span><br><span class="line">    <span class="keyword">if</span> (i != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 截取包名 com.example</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">pkgname</span> <span class="operator">=</span> name.substring(<span class="number">0</span>, i);</span><br><span class="line">        <span class="comment">// Check if package already loaded.</span></span><br><span class="line">        <span class="type">Manifest</span> <span class="variable">man</span> <span class="operator">=</span> res.getManifest();</span><br><span class="line">        definePackageInternal(pkgname, man, url);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Now read the class bytes and define the class</span></span><br><span class="line">    <span class="comment">// 先尝试以 ByteBuffer 的形式返回字节数据，如果资源的输入流不是在 ByteBuffer 之上实现的，则返回 null</span></span><br><span class="line">    java.nio.<span class="type">ByteBuffer</span> <span class="variable">bb</span> <span class="operator">=</span> res.getByteBuffer();</span><br><span class="line">    <span class="keyword">if</span> (bb != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Use (direct) ByteBuffer:</span></span><br><span class="line">        <span class="comment">// 不常用</span></span><br><span class="line">        CodeSigner[] signers = res.getCodeSigners();</span><br><span class="line">        <span class="type">CodeSource</span> <span class="variable">cs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CodeSource</span>(url, signers);</span><br><span class="line">        sun.misc.PerfCounter.getReadClassBytesTime().addElapsedTimeFrom(t0);</span><br><span class="line">        <span class="comment">// 调用 java.security.SecureClassLoader#defineClass(java.lang.String, java.nio.ByteBuffer, java.security.CodeSource)</span></span><br><span class="line">        <span class="keyword">return</span> defineClass(name, bb, cs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 以字节数组的形式返回资源数据</span></span><br><span class="line">        <span class="type">byte</span>[] b = res.getBytes();</span><br><span class="line">        <span class="comment">// must read certificates AFTER reading bytes.</span></span><br><span class="line">        <span class="comment">// 必须再读取字节数据后读取证书，todo:</span></span><br><span class="line">        CodeSigner[] signers = res.getCodeSigners();</span><br><span class="line">        <span class="comment">// 根据 URL 和签名者创建 CodeSource</span></span><br><span class="line">        <span class="type">CodeSource</span> <span class="variable">cs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CodeSource</span>(url, signers);</span><br><span class="line">        sun.misc.PerfCounter.getReadClassBytesTime().addElapsedTimeFrom(t0);</span><br><span class="line">        <span class="comment">// 调用 java.security.SecureClassLoader#defineClass(java.lang.String, byte[], int, int, java.security.CodeSource)</span></span><br><span class="line">        <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length, cs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Resource</code> 类提供了 <code>getBytes</code> 方法，此方法以字节数组的形式返回字节数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] getBytes() <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">byte</span>[] b;</span><br><span class="line">    <span class="comment">// Get stream before content length so that a FileNotFoundException</span></span><br><span class="line">    <span class="comment">// can propagate upwards without being caught too early</span></span><br><span class="line">    <span class="comment">// 在获取内容长度之前获取流，以便 FileNotFoundException 可以向上传播而不会过早被捕获（todo: 不理解）</span></span><br><span class="line">    <span class="comment">// 获取缓存的 InputStream</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> cachedInputStream();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This code has been uglified to protect against interrupts.</span></span><br><span class="line">    <span class="comment">// Even if a thread has been interrupted when loading resources,</span></span><br><span class="line">    <span class="comment">// the IO should not abort, so must carefully retry, failing only</span></span><br><span class="line">    <span class="comment">// if the retry leads to some other IO exception.</span></span><br><span class="line">    <span class="comment">// 该代码为了防止中断有点丑陋。即使线程在加载资源时被中断，IO 也不应该中止，因此必须小心重试，只有当重试导致其他 IO 异常时才会失败。</span></span><br><span class="line">    <span class="comment">// 检测当前线程是否收到中断信号，收到的话则返回 true 且清除中断状态，重新变更为未中断状态。</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isInterrupted</span> <span class="operator">=</span> Thread.interrupted();</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取内容长度，顺利的话就跳出循环</span></span><br><span class="line">            len = getContentLength();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedIOException iioe) &#123;</span><br><span class="line">            <span class="comment">// 如果获取内容长度时，线程被中断抛出了异常，捕获后清除中断状态</span></span><br><span class="line">            Thread.interrupted();</span><br><span class="line">            isInterrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (len == -<span class="number">1</span>) len = Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (pos &lt; len) &#123;</span><br><span class="line">            <span class="type">int</span> bytesToRead;</span><br><span class="line">            <span class="keyword">if</span> (pos &gt;= b.length) &#123; <span class="comment">// Only expand when there&#x27;s no room</span></span><br><span class="line">                <span class="comment">// 如果当前读取位置已经大于等于数组长度</span></span><br><span class="line">                <span class="comment">// 本次待读取字节长度 = 剩余未读取长度和 1024 取较小值</span></span><br><span class="line">                bytesToRead = Math.min(len - pos, b.length + <span class="number">1024</span>);</span><br><span class="line">                <span class="keyword">if</span> (b.length &lt; pos + bytesToRead) &#123;</span><br><span class="line">                    <span class="comment">// 如果当前读取位置 + 本次待读取字节长度 &gt; 数组长度，则创建新数组并复制数据</span></span><br><span class="line">                    b = Arrays.copyOf(b, pos + bytesToRead);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 数组还有空间，待读取字节长度 = 数组剩余空间</span></span><br><span class="line">                bytesToRead = b.length - pos;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cc</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 读取数据</span></span><br><span class="line">                cc = in.read(b, pos, bytesToRead);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedIOException iioe) &#123;</span><br><span class="line">                <span class="comment">// 如果读取时，线程被中断抛出了异常，捕获后清除中断状态</span></span><br><span class="line">                Thread.interrupted();</span><br><span class="line">                isInterrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果读取返回值 &lt; 0</span></span><br><span class="line">                <span class="keyword">if</span> (len != Integer.MAX_VALUE) &#123;</span><br><span class="line">                    <span class="comment">// 且长度并未无限，表示提前检测到 EOF，抛出异常</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EOFException</span>(<span class="string">&quot;Detect premature EOF&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果长度无限，表示读到了文件结尾，数组长度大于当前读取位置，创建新数组并复制长度</span></span><br><span class="line">                    <span class="keyword">if</span> (b.length != pos) &#123;</span><br><span class="line">                        b = Arrays.copyOf(b, pos);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pos += cc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedIOException iioe) &#123;</span><br><span class="line">            isInterrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ignore) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isInterrupted) &#123;</span><br><span class="line">            <span class="comment">// 如果 isInterrupted 为 true，代表中断过，重新将线程状态置为中断。</span></span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>getByteBuffer</code> 之后会缓存 <code>InputStream</code> 以便调用 <code>getBytes</code> 时使用，方法由 <code>synchronized</code> 修饰。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> InputStream <span class="title function_">cachedInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (cis == <span class="literal">null</span>) &#123;</span><br><span class="line">        cis = getInputStream();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Resource</code> 的实例是 <code>URLClassPath</code> 中的匿名类 <code>FileLoader</code> 以 <code>Resource</code> 的匿名类的方式创建的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> InputStream <span class="title function_">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在该匿名类中，getInputStream 的实现就是简单地根据 FileLoader 中保存的 File 实例创建 FileInputStream 并返回。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getContentLength</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在该匿名类中，getContentLength 的实现就是简单地根据 FileLoader 中保存的 File 实例获取长度。</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)file.length();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="SecureClassLoader-defineClass"><a href="#SecureClassLoader-defineClass" class="headerlink" title="SecureClassLoader#defineClass"></a>SecureClassLoader#defineClass</h4><p><code>URLClassLoader</code> 继承自 <code>SecureClassLoader</code>，<code>SecureClassLoader</code> 提供并重载了 <code>defineClass</code> 方法，两个方法的注释均比代码长得多。<br>由注释可知，方法的作用是将字节数据（<code>byte[]</code> 类型或者 <code>ByteBuffer</code> 类型）转换为 <code>Class</code> 类型的实例，有一个可选的 <code>CodeSource</code> 类型的参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name,</span><br><span class="line">                                     <span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len,</span><br><span class="line">                                     CodeSource cs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> defineClass(name, b, off, len, getProtectionDomain(cs));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, java.nio.ByteBuffer b,</span><br><span class="line">                                     CodeSource cs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> defineClass(name, b, getProtectionDomain(cs));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法中只是简单地将 <code>CodeSource</code> 类型的参数转换成 <code>ProtectionDomain</code> 类型，就调用 <code>ClassLoader</code> 的 <code>defineClass</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ProtectionDomain <span class="title function_">getProtectionDomain</span><span class="params">(CodeSource cs)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 CodeSource 为 null，直接返回 null</span></span><br><span class="line">    <span class="keyword">if</span> (cs == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">ProtectionDomain</span> <span class="variable">pd</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (pdcache) &#123;</span><br><span class="line">        <span class="comment">// 先从 Map 缓存中获取 ProtectionDomain</span></span><br><span class="line">        pd = pdcache.get(cs);</span><br><span class="line">        <span class="keyword">if</span> (pd == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 从 CodeSource 中获取 PermissionCollection</span></span><br><span class="line">            <span class="type">PermissionCollection</span> <span class="variable">perms</span> <span class="operator">=</span> getPermissions(cs);</span><br><span class="line">            <span class="comment">// 缓存中没有，则创建一个 ProtectionDomain 并放入缓存</span></span><br><span class="line">            pd = <span class="keyword">new</span> <span class="title class_">ProtectionDomain</span>(cs, perms, <span class="built_in">this</span>, <span class="literal">null</span>);</span><br><span class="line">            pdcache.put(cs, pd);</span><br><span class="line">            <span class="keyword">if</span> (debug != <span class="literal">null</span>) &#123;</span><br><span class="line">                debug.println(<span class="string">&quot; getPermissions &quot;</span>+ pd);</span><br><span class="line">                debug.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="getPermissions"><a href="#getPermissions" class="headerlink" title="getPermissions"></a>getPermissions</h5><p>根据注释可知，此方法会返回给定 <code>CodeSource</code> 对象的权限。此方法由 <code>protect</code> 修饰，<code>AppClassLoader</code> 和 <code>URLClassLoader</code> 都有重写。当前 <code>ClassLoader</code> 是 <code>AppClassLoader</code>。</p>
<p><code>AppClassLoader#getPermissions</code>，添加允许从类路径加载的任何类退出 VM的权限。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> PermissionCollection <span class="title function_">getPermissions</span><span class="params">(CodeSource codesource)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用父类 URLClassLoader 的 getPermissions</span></span><br><span class="line">    <span class="type">PermissionCollection</span> <span class="variable">perms</span> <span class="operator">=</span> <span class="built_in">super</span>.getPermissions(codesource);</span><br><span class="line">    <span class="comment">// 允许从类路径加载的任何类退出 VM的权限。</span></span><br><span class="line">    <span class="comment">// todo: 这是否自定义的类加载器加载的类，可能不能退出 VM。</span></span><br><span class="line">    perms.add(<span class="keyword">new</span> <span class="title class_">RuntimePermission</span>(<span class="string">&quot;exitVM&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> perms;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SecureClassLoader#getPermissions</code>，添加一个读文件或读目录的权限。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> PermissionCollection <span class="title function_">getPermissions</span><span class="params">(CodeSource codesource)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用父类 SecureClassLoader 的 getPermissions</span></span><br><span class="line">    <span class="type">PermissionCollection</span> <span class="variable">perms</span> <span class="operator">=</span> <span class="built_in">super</span>.getPermissions(codesource);</span><br><span class="line"></span><br><span class="line">    <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> codesource.getLocation();</span><br><span class="line"></span><br><span class="line">    Permission p;</span><br><span class="line">    URLConnection urlConnection;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// FileURLConnection 实例</span></span><br><span class="line">        urlConnection = url.openConnection();</span><br><span class="line">        <span class="comment">// 允许 read 的 FilePermission 实例</span></span><br><span class="line">        p = urlConnection.getPermission();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.io.IOException ioe) &#123;</span><br><span class="line">        p = <span class="literal">null</span>;</span><br><span class="line">        urlConnection = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p <span class="keyword">instanceof</span> FilePermission) &#123;</span><br><span class="line">        <span class="comment">// if the permission has a separator char on the end,</span></span><br><span class="line">        <span class="comment">// it means the codebase is a directory, and we need</span></span><br><span class="line">        <span class="comment">// to add an additional permission to read recursively</span></span><br><span class="line">        <span class="comment">// 如果文件路径以文件分隔符结尾，表示目录，需要在末尾添加&quot;-&quot;改为递归读的权限</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> p.getName();</span><br><span class="line">        <span class="keyword">if</span> (path.endsWith(File.separator)) &#123;</span><br><span class="line">            path += <span class="string">&quot;-&quot;</span>;</span><br><span class="line">            p = <span class="keyword">new</span> <span class="title class_">FilePermission</span>(path, SecurityConstants.FILE_READ_ACTION);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((p == <span class="literal">null</span>) &amp;&amp; (url.getProtocol().equals(<span class="string">&quot;file&quot;</span>))) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> url.getFile().replace(<span class="string">&#x27;/&#x27;</span>, File.separatorChar);</span><br><span class="line">        path = ParseUtil.decode(path);</span><br><span class="line">        <span class="keyword">if</span> (path.endsWith(File.separator))</span><br><span class="line">            path += <span class="string">&quot;-&quot;</span>;</span><br><span class="line">        p =  <span class="keyword">new</span> <span class="title class_">FilePermission</span>(path, SecurityConstants.FILE_READ_ACTION);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Not loading from a &#x27;file:&#x27; URL so we want to give the class</span></span><br><span class="line"><span class="comment">         * permission to connect to and accept from the remote host</span></span><br><span class="line"><span class="comment">         * after we&#x27;ve made sure the host is the correct one and is valid.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">URL</span> <span class="variable">locUrl</span> <span class="operator">=</span> url;</span><br><span class="line">        <span class="keyword">if</span> (urlConnection <span class="keyword">instanceof</span> JarURLConnection) &#123;</span><br><span class="line">            locUrl = ((JarURLConnection)urlConnection).getJarFileURL();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> locUrl.getHost();</span><br><span class="line">        <span class="keyword">if</span> (host != <span class="literal">null</span> &amp;&amp; (host.length() &gt; <span class="number">0</span>))</span><br><span class="line">            p = <span class="keyword">new</span> <span class="title class_">SocketPermission</span>(host,</span><br><span class="line">                                        SecurityConstants.SOCKET_CONNECT_ACCEPT_ACTION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make sure the person that created this class loader</span></span><br><span class="line">    <span class="comment">// would have this permission</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Permission</span> <span class="variable">fp</span> <span class="operator">=</span> p;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> SecurityException &#123;</span><br><span class="line">                    sm.checkPermission(fp);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, acc);</span><br><span class="line">        &#125;</span><br><span class="line">        perms.add(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> perms;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SecureClassLoader#getPermissions</code>，延迟设置权限，在创建 <code>ProtectionDomain</code> 时再设置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> PermissionCollection <span class="title function_">getPermissions</span><span class="params">(CodeSource codesource)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 检查以确保类加载器已初始化。在 SecureClassLoader 构造器最后会用一个布尔变量表示加载器初始化成功。</span></span><br><span class="line">    <span class="comment">// 从代码上看，似乎只能保证 SecureClassLoader 的构造器方法已执行完毕？</span></span><br><span class="line">    check();</span><br><span class="line">    <span class="comment">// ProtectionDomain 延迟绑定，Permissions 继承 PermissionCollection 类。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Permissions</span>(); <span class="comment">// ProtectionDomain defers the binding</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ProtectionDomain"><a href="#ProtectionDomain" class="headerlink" title="ProtectionDomain"></a>ProtectionDomain</h5><p><code>ProtectionDomain</code> 的相关构造器参数：</p>
<ul>
<li><code>CodeSource</code></li>
<li><code>PermissionCollection</code>，如果不为 <code>null</code>，会设置权限为只读，表示权限在使用过程中不再修改；同时检查是否需要设置拥有全部权限。</li>
<li><code>ClassLoader</code></li>
<li><code>Principal[]</code></li>
</ul>
<p>这样看来，<code>SecureClassLoader</code> 为了定义类做的处理，就是简单地创建一些关于权限的对象，并保存了 <code>CodeSource-&gt;ProtectionDomain</code> 的映射作为缓存。</p>
<h4 id="ClassLoader-defineClass"><a href="#ClassLoader-defineClass" class="headerlink" title="ClassLoader#defineClass"></a>ClassLoader#defineClass</h4><p>抽象类 <code>ClassLoader</code> 中最终用于定义类的 <code>native</code> 方法 <code>define0</code>，<code>define1</code>，<code>define2</code> 都是由 <code>private</code> 修饰的，<code>ClassLoader</code> 提供并重载了 <code>defineClass</code> 方法作为使用它们的入口，这些 <code>defineClass</code> 方法都由 <code>protect</code> <code>final</code> 修饰，这意味着这些方法只能被子类使用，并且不能被重写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len)</span><br><span class="line">    <span class="keyword">throws</span> ClassFormatError</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> defineClass(name, b, off, len, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len,</span><br><span class="line">                                     ProtectionDomain protectionDomain)</span><br><span class="line">    <span class="keyword">throws</span> ClassFormatError</span><br><span class="line">&#123;</span><br><span class="line">    protectionDomain = preDefineClass(name, protectionDomain);</span><br><span class="line">    <span class="type">String</span> <span class="variable">source</span> <span class="operator">=</span> defineClassSourceLocation(protectionDomain);</span><br><span class="line">    Class&lt;?&gt; c = defineClass1(name, b, off, len, protectionDomain, source);</span><br><span class="line">    postDefineClass(c, protectionDomain);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, java.nio.ByteBuffer b,</span><br><span class="line">                                     ProtectionDomain protectionDomain)</span><br><span class="line">    <span class="keyword">throws</span> ClassFormatError</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> b.remaining();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use byte[] if not a direct ByteBufer:</span></span><br><span class="line">    <span class="keyword">if</span> (!b.isDirect()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b.hasArray()) &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, b.array(),</span><br><span class="line">                                b.position() + b.arrayOffset(), len,</span><br><span class="line">                                protectionDomain);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// no array, or read-only array</span></span><br><span class="line">            <span class="type">byte</span>[] tb = <span class="keyword">new</span> <span class="title class_">byte</span>[len];</span><br><span class="line">            b.get(tb);  <span class="comment">// get bytes out of byte buffer.</span></span><br><span class="line">            <span class="keyword">return</span> defineClass(name, tb, <span class="number">0</span>, len, protectionDomain);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protectionDomain = preDefineClass(name, protectionDomain);</span><br><span class="line">    <span class="type">String</span> <span class="variable">source</span> <span class="operator">=</span> defineClassSourceLocation(protectionDomain);</span><br><span class="line">    Class&lt;?&gt; c = defineClass2(name, b, b.position(), len, protectionDomain, source);</span><br><span class="line">    postDefineClass(c, protectionDomain);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要步骤：</p>
<ol>
<li><code>preDefineClass</code> 前置处理</li>
<li><code>defineClassX</code></li>
<li><code>postDefineClass</code> 后置处理</li>
</ol>
<h5 id="preDefineClass"><a href="#preDefineClass" class="headerlink" title="preDefineClass"></a>preDefineClass</h5><p>确定保护域 <code>ProtectionDomain</code>，并检查：</p>
<ol>
<li>未定义 <code>java.*</code> 类</li>
<li>该类的签名者与包（<code>package</code>）中其余类的签名者相匹配</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ProtectionDomain <span class="title function_">preDefineClass</span><span class="params">(String name,</span></span><br><span class="line"><span class="params">                                        ProtectionDomain pd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 检查 name 为 null 或者有可能是有效的二进制名称</span></span><br><span class="line">    <span class="keyword">if</span> (!checkName(name))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoClassDefFoundError</span>(<span class="string">&quot;IllegalName: &quot;</span> + name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note:  Checking logic in java.lang.invoke.MemberName.checkForTypeAlias</span></span><br><span class="line">    <span class="comment">// relies on the fact that spoofing is impossible if a class has a name</span></span><br><span class="line">    <span class="comment">// of the form &quot;java.*&quot;</span></span><br><span class="line">    <span class="comment">// 如果 name 以 java. 开头，则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> ((name != <span class="literal">null</span>) &amp;&amp; name.startsWith(<span class="string">&quot;java.&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span></span><br><span class="line">            (<span class="string">&quot;Prohibited package name: &quot;</span> +</span><br><span class="line">                name.substring(<span class="number">0</span>, name.lastIndexOf(<span class="string">&#x27;.&#x27;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果未传入 ProtectionDomain，取默认的 ProtectionDomain</span></span><br><span class="line">        pd = defaultDomain;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存放了 package-&gt;certs 的 map 映射作为缓存，检查一个包内的 certs 都是一样的</span></span><br><span class="line">    <span class="comment">// todo: certs</span></span><br><span class="line">    <span class="keyword">if</span> (name != <span class="literal">null</span>) checkCerts(name, pd.getCodeSource());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="defineClassSourceLocation"><a href="#defineClassSourceLocation" class="headerlink" title="defineClassSourceLocation"></a>defineClassSourceLocation</h5><p>确定 <code>Class</code> 的 <code>CodeSource</code> 位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">defineClassSourceLocation</span><span class="params">(ProtectionDomain pd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">CodeSource</span> <span class="variable">cs</span> <span class="operator">=</span> pd.getCodeSource();</span><br><span class="line">    <span class="type">String</span> <span class="variable">source</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (cs != <span class="literal">null</span> &amp;&amp; cs.getLocation() != <span class="literal">null</span>) &#123;</span><br><span class="line">        source = cs.getLocation().toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> source;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="defineClassX-方法"><a href="#defineClassX-方法" class="headerlink" title="defineClassX 方法"></a>defineClassX 方法</h5><p>这些 <code>native</code> 方法使用了 <code>name</code>，字节数据，<code>ProtectionDomain</code> 和 <code>source</code> 等参数，像黑盒一样，在虚拟机中定义了一个类。</p>
<h5 id="postDefineClass"><a href="#postDefineClass" class="headerlink" title="postDefineClass"></a>postDefineClass</h5><p>在定义类后使用 <code>ProtectionDomain</code> 中的 <code>certs</code> 补充 <code>Class</code> 实例的 <code>signer</code> 信息，猜测在 <code>native</code> 方法 <code>defineClassX</code> 方法中，对 <code>ProtectionDomain</code> 做了一些修改。事实上，从代码上看，将 <code>CodeSource</code> 包装为 <code>ProtectionDomain</code> 传入后，除了 <code>defineClassX</code> 方法外，其他地方都是取出 <code>CodeSource</code> 使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postDefineClass</span><span class="params">(Class&lt;?&gt; c, ProtectionDomain pd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pd.getCodeSource() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取证书</span></span><br><span class="line">        Certificate certs[] = pd.getCodeSource().getCertificates();</span><br><span class="line">        <span class="keyword">if</span> (certs != <span class="literal">null</span>)</span><br><span class="line">            setSigners(c, certs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>java</tag>
        <tag>class loader</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM GC 的测试和分析</title>
    <url>/2023/11/01/testing-and-analysis-of-jvm-gc/</url>
    <content><![CDATA[<h3 id="堆的组成"><a href="#堆的组成" class="headerlink" title="堆的组成"></a>堆的组成</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JvmGcTest_1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_512KB</span> <span class="operator">=</span> <span class="number">512</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_6MB</span> <span class="operator">=</span> <span class="number">6</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_7MB</span> <span class="operator">=</span> <span class="number">7</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_8MB</span> <span class="operator">=</span> <span class="number">8</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</span></span><br><span class="line">    <span class="comment">// -XX:+UseSerialGC 避免幸存区比例动态调整</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 2010K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">  eden space 8192K,  24% used [0x00000000fec00000, 0x00000000fedf68c8, 0x00000000ff400000)</span><br><span class="line">  from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)</span><br><span class="line"> tenured generation   total 10240K, used 0K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">   the space 10240K,   0% used [0x00000000ff600000, 0x00000000ff600000, 0x00000000ff600200, 0x0000000100000000)</span><br><span class="line"> Metaspace       used 3288K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 348K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>根据打印的信息，组成如下：</p>
<ul>
<li><code>Heap</code>: 堆。<ul>
<li><code>def new generation</code>: 新生代。</li>
<li><code>tenured generation</code>: 老年代。</li>
<li><code>Metaspace</code>: 元空间，实际上并不属于堆， <code>-XX:+PrintGCDetails</code> 将它的信息一起输出。</li>
</ul>
</li>
</ul>
<h4 id="堆空间的比例"><a href="#堆空间的比例" class="headerlink" title="堆空间的比例"></a>堆空间的比例</h4><p>新生代中的空间占比 <code>eden:from:to</code> 在默认情况下是 <code>8:1:1</code>，与观察到的数据 <code>8192K:1024K:1024K</code> 一致。<br>新生代的空间 <code>eden + from + to</code> 为 10240K，符合 <code>-Xmn10M</code> 设置的大小。<br><code>total</code> 显示为 9216K，即 <code>eden + from</code> 的大小，是因为 <code>to</code> 的空间不计算在内。新生代可用的空间只有 <code>eden + from</code>，<code>to</code> 空间只是在使用标记-复制算法进行垃圾回收时使用。<br>老年代的空间为 10240K。<br>目前仅 <code>eden</code> 中已用 2010K，约占 <code>eden</code> 空间的 24%。</p>
<h4 id="从内存地址分析堆空间"><a href="#从内存地址分析堆空间" class="headerlink" title="从内存地址分析堆空间"></a>从内存地址分析堆空间</h4><p>内存地址为 16 位的 16 进制的数字，64 位机器。<br><code>[0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</code> 分别表示地址空间的开始、已用、结束的地址指针。<br>新生代 <code>[0x00000000fec00000, 0x00000000ff600000)</code>，老年代 <code>[0x00000000ff600000, 0x0000000100000000)</code>，计算可得空间大小均为 10MB。<br><code>eden</code> 中已用的空间地址为 <code>[0x00000000fec00000, 0x00000000fedf68c8)</code>，空间大小为 2058440 byte，约等于 2010K。</p>
<p>显而易见，新生代和老生代是一片完全连续的地址空间。</p>
<h3 id="堆的垃圾回收"><a href="#堆的垃圾回收" class="headerlink" title="堆的垃圾回收"></a>堆的垃圾回收</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_7MB]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: 2013K-&gt;721K(9216K), 0.0105099 secs] 2013K-&gt;721K(19456K), 0.0105455 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span><br><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 8135K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">  eden space 8192K,  90% used [0x00000000fec00000, 0x00000000ff33d8c0, 0x00000000ff400000)</span><br><span class="line">  from space 1024K,  70% used [0x00000000ff500000, 0x00000000ff5b45f0, 0x00000000ff600000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)</span><br><span class="line"> tenured generation   total 10240K, used 0K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">   the space 10240K,   0% used [0x00000000ff600000, 0x00000000ff600000, 0x00000000ff600200, 0x0000000100000000)</span><br><span class="line"> Metaspace       used 3354K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 360K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p><code>Allocation Failure</code>，正常情况下，新对象总是分配在 Eden，分配空间失败，<code>eden</code> 的剩余空间不足以存放 7M 大小的对象，新生代发生 <code>minor GC</code>。<br><code>[DefNew: 2013K-&gt;721K(9216K), 0.0105099 secs]</code>，新生代在垃圾回收前后空间的占用变化和耗时。<br><code>2013K-&gt;721K(19456K), 0.0105455 secs</code>，整个堆在垃圾回收前后空间的占用变化和耗时。</p>
<h4 id="GC-类型"><a href="#GC-类型" class="headerlink" title="GC 类型"></a>GC 类型</h4><ul>
<li>GC: minor GC。</li>
<li>Fulle GC: full GC。</li>
</ul>
<h4 id="from-和-to-的角色变换"><a href="#from-和-to-的角色变换" class="headerlink" title="from 和 to 的角色变换"></a>from 和 to 的角色变换</h4><p><code>from</code> 的已用空间的地址为 <code>[0x00000000ff500000, 0x00000000ff5b45f0)</code>，空间大小为 738800 byte，约 721K，与 GC 后的新生代空间占用大小一致。在垃圾回收后，<code>eden</code> 区域存活的对象全部转移到了原 <code>to</code> 空间，<code>from</code> 和 <code>to</code> 空间的角色相互转换（从地址空间的信息可以看到此时 <code>to</code> 的地址指针比 <code>from</code> 的地址指针小）。<br><code>eden</code> 的已用空间的地址为 <code>[0x00000000fec00000, 0x00000000ff33d8c0)</code>，空间大小为 7592128 byte，约 7.24M，比 7M 大不少。此时 <code>eden</code> 区域除了 <code>byte[]</code> 对象外，还存储了其他对象，比如为了创建 <code>List&lt;byte[]&gt;</code> 对象而新加载的类对象。</p>
<h3 id="eden-空间足够时不发生-GC"><a href="#eden-空间足够时不发生-GC" class="headerlink" title="eden 空间足够时不发生 GC"></a>eden 空间足够时不发生 GC</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_7MB]);</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_512KB]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: 2013K-&gt;721K(9216K), 0.0011172 secs] 2013K-&gt;721K(19456K), 0.0011443 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 8647K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">  eden space 8192K,  96% used [0x00000000fec00000, 0x00000000ff3bd8d0, 0x00000000ff400000)</span><br><span class="line">  from space 1024K,  70% used [0x00000000ff500000, 0x00000000ff5b45f0, 0x00000000ff600000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)</span><br><span class="line"> tenured generation   total 10240K, used 0K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">   the space 10240K,   0% used [0x00000000ff600000, 0x00000000ff600000, 0x00000000ff600200, 0x0000000100000000)</span><br><span class="line"> Metaspace       used 3354K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 360K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>由于 <code>eden</code> 区域还能放下 512K 的对象，所以仍然只会发生一次垃圾回收。<br><code>eden</code> 区域的已用空间比例上升到 96%，已用空间的地址为 <code>[0x00000000fec00000, 0x00000000ff3bd8d0)</code>，空间大小为 8116432 byte，约 7.74M，比上一次增加了 524304 byte，即 <code>512 * 1024 + 16</code>。显然第二次添加时，不再因为创建 <code>List&lt;byte[]&gt;</code> 而创建额外的对象，只有创建对象所需的 512K 和 16 字节的对象头。<strong>这一刻数值的精确让人欣喜hhh</strong>。</p>
<h3 id="新生代空间不足，部分对象提前晋升到老年代"><a href="#新生代空间不足，部分对象提前晋升到老年代" class="headerlink" title="新生代空间不足，部分对象提前晋升到老年代"></a>新生代空间不足，部分对象提前晋升到老年代</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_7MB]);</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_512KB]);</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_512KB]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: 2013K-&gt;721K(9216K), 0.0013580 secs] 2013K-&gt;721K(19456K), 0.0013932 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [DefNew: 8565K-&gt;512K(9216K), 0.0046378 secs] 8565K-&gt;8396K(19456K), 0.0046540 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 1350K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">  eden space 8192K,  10% used [0x00000000fec00000, 0x00000000fecd1a20, 0x00000000ff400000)</span><br><span class="line">  from space 1024K,  50% used [0x00000000ff400000, 0x00000000ff480048, 0x00000000ff500000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)</span><br><span class="line"> tenured generation   total 10240K, used 7884K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">   the space 10240K,  77% used [0x00000000ff600000, 0x00000000ffdb33a0, 0x00000000ffdb3400, 0x0000000100000000)</span><br><span class="line"> Metaspace       used 3354K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 360K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>在第三次添加时，由于 <code>eden</code> 空间不足，因此又发生了第二次垃圾回收。<br><code>[DefNew: 8565K-&gt;512K(9216K), 0.0046378 secs]</code>，新生代的空间占用下降到了 512K，应该是在 from 中留下了第二次添加时的 512K。<br>在第二次添加完成后，<code>eden</code> <code>[0x00000000fec00000, 0x00000000ff3bd8d0)</code> 和 <code>from</code> <code>[0x00000000ff500000, 0x00000000ff5b45f0)</code> 占用的空间为 <code>8116432 + 738800 = 8855232</code> 约 8647.7K，略大于 8565K。很奇怪，第二次垃圾回收前，新生代的空间占用为什么有小幅度下降。<br><code>8565K-&gt;8396K(19456K), 0.0046540 secs</code>，堆的占用空间并未发生明显下降。部分对象因为新生代空间不足，提前晋升到了老年代中。8396K - 512 K 剩余 7884K，全部晋升到老年代，符合 77% 的统计数据。<br><code>eden</code> 中加入了第三次添加时的对象，大于 512K 不少。<br>此时 <code>eden</code>、<code>from</code>、<code>tenured</code> 中均有不好确认成分的空间占用，比如 from 中多了 56 字节。</p>
<h3 id="新生代空间不足，大对象直接在老年代创建"><a href="#新生代空间不足，大对象直接在老年代创建" class="headerlink" title="新生代空间不足，大对象直接在老年代创建"></a>新生代空间不足，大对象直接在老年代创建</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_8MB]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Heap</span><br><span class="line"> def <span class="keyword">new</span> <span class="title class_">generation</span>   total 9216K, used 2177K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  eden space 8192K,  <span class="number">26</span>% used [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000fee20730</span>, <span class="number">0x00000000ff400000</span>)</span><br><span class="line">  from space 1024K,   <span class="number">0</span>% used [<span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff500000</span>)</span><br><span class="line">  to   space 1024K,   <span class="number">0</span>% used [<span class="number">0x00000000ff500000</span>, <span class="number">0x00000000ff500000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line"> tenured generation   total 10240K, used 8192K [<span class="number">0x00000000ff600000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">   the space 10240K,  <span class="number">80</span>% used [<span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ffe00010</span>, <span class="number">0x00000000ffe00200</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line"> Metaspace       used 3353K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 360K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>在 Eden 空间肯定不足而老年代空间足够的情况下，大对象会直接在老年代中创建，此时不会发生 GC。</p>
<h3 id="内存不足-OOM"><a href="#内存不足-OOM" class="headerlink" title="内存不足 OOM"></a>内存不足 OOM</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_8MB]);</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_8MB]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">waiting...</span><br><span class="line">[GC (Allocation Failure) [DefNew: 4711K-&gt;928K(9216K), 0.0017245 secs][Tenured: 8192K-&gt;9117K(10240K), 0.0021690 secs] 12903K-&gt;9117K(19456K), [Metaspace: 4267K-&gt;4267K(1056768K)], 0.0039336 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (Allocation Failure) [Tenured: 9117K-&gt;9063K(10240K), 0.0014352 secs] 9117K-&gt;9063K(19456K), [Metaspace: 4267K-&gt;4267K(1056768K)], 0.0014614 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">Exception in thread &quot;Thread-0&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at com.moralok.jvm.gc.JvmGcTest.lambda$main$0(JvmGcTest.java:27)</span><br><span class="line">	at com.moralok.jvm.gc.JvmGcTest$$Lambda$1/2003749087.run(Unknown Source)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:750)</span><br><span class="line"></span><br><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 1502K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">  eden space 8192K,  18% used [0x00000000fec00000, 0x00000000fed77a00, 0x00000000ff400000)</span><br><span class="line">  from space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)</span><br><span class="line"> tenured generation   total 10240K, used 9063K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">   the space 10240K,  88% used [0x00000000ff600000, 0x00000000ffed9c50, 0x00000000ffed9e00, 0x0000000100000000)</span><br><span class="line"> Metaspace       used 4787K, capacity 4884K, committed 4992K, reserved 1056768K</span><br><span class="line">  class space    used 522K, capacity 558K, committed 640K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>当新生代和老年代的空间均不足时，在尝试 GC 和 Full GC 后仍不能成功分配对象，就会发生 <code>OutOfMemoryError</code>。</p>
<h4 id="线程中发生内存不足，不会影响其他线程"><a href="#线程中发生内存不足，不会影响其他线程" class="headerlink" title="线程中发生内存不足，不会影响其他线程"></a>线程中发生内存不足，不会影响其他线程</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_8MB]);</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_8MB]);</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: 2013K-&gt;721K(9216K), 0.0012274 secs][Tenured: 8192K-&gt;8912K(10240K), 0.0113036 secs] 10205K-&gt;8912K(19456K), [Metaspace: 3345K-&gt;3345K(1056768K)], 0.0125751 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span><br><span class="line">[Full GC (Allocation Failure) [Tenured: 8912K-&gt;8895K(10240K), 0.0011880 secs] 8912K-&gt;8895K(19456K), [Metaspace: 3345K-&gt;3345K(1056768K)], 0.0012009 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 246K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">  eden space 8192K,   3% used [0x00000000fec00000, 0x00000000fec3d890, 0x00000000ff400000)</span><br><span class="line">  from space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)</span><br><span class="line"> tenured generation   total 10240K, used 8895K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">   the space 10240K,  86% used [0x00000000ff600000, 0x00000000ffeafce0, 0x00000000ffeafe00, 0x0000000100000000)</span><br><span class="line"> Metaspace       used 3380K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 363K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at com.moralok.jvm.gc.JvmGcTest.main(JvmGcTest.java:21)</span><br></pre></td></tr></table></figure>

<p>当 <code>Thread-0</code> 发生 <code>OutOfMemoryError</code> 后，<code>main</code> 线程仍然正常运行。</p>
<h3 id="大对象的划分指标"><a href="#大对象的划分指标" class="headerlink" title="大对象的划分指标"></a>大对象的划分指标</h3><p>当创建的大对象 + 对象头的容量小于等于 <code>eden</code>，如果 GC 后的存活对象可以放入 <code>to</code>，那么还是会先在 <code>eden</code> 中创建大对象。<br>在本案例中，又会马上发生一次 GC，大对象提前晋升到老年代中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_8MB - <span class="number">16</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: 2013K-&gt;693K(9216K), 0.0015517 secs] 2013K-&gt;693K(19456K), 0.0015828 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [DefNew: 8885K-&gt;0K(9216K), 0.0048110 secs] 8885K-&gt;8885K(19456K), 0.0048264 secs] [Times: user=0.00 sys=0.02, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 410K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">  eden space 8192K,   5% used [0x00000000fec00000, 0x00000000fec66958, 0x00000000ff400000)</span><br><span class="line">  from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)</span><br><span class="line"> tenured generation   total 10240K, used 8885K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">   the space 10240K,  86% used [0x00000000ff600000, 0x00000000ffead580, 0x00000000ffead600, 0x0000000100000000)</span><br><span class="line"> Metaspace       used 3321K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 354K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>尽管最终大部分对象提前晋升到老年代，但是可以看到第二次 GC 前的新生代空间占用，可见数组分配时，所需空间刚好为 Eden 空间大小时，还是会在 eden 创建对象。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>正常情况下，新对象都是在 eden 中创建。</li>
<li>空间足够的意思并非空间占用相加的值仍小于总额，而是有连续的一片内存可供分配。因此紧凑才能利用率高。</li>
<li>正常情况下，GC 前 to 区域总是为空，GC 后 eden 区域总是为空。</li>
<li>正常情况下，GC 后 eden 和 from 的存活对象要么去了 to，要么去老年代。</li>
<li>只要 GC 后腾空 eden，创建在 eden 中的新对象的空间占用可以等于 eden 的大小。</li>
</ul>
<p>尽管总体上有迹可循，但是 GC 的具体情况，仍然需要具体分析，有很多分支情况未一一确认。</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串常量池的测试和分析</title>
    <url>/2023/11/03/testing-and-analysis-of-StringTable/</url>
    <content><![CDATA[<p>如果你准备过 Java 的面试，应该看到过一个问题：“<code>String s1 = new String(&quot;abc&quot;);</code> 这个语句创建了几个字符串对象”。这个问题曾经困扰我，当时的我不能理解这个问题想要考察的是什么？<br>答案中或许提及了字符串常量池，但是如果细究起来，会发现答案并不完善，有些令人困惑，甚至问题本身就有一定的误导作用。它很容易让初学者以为创建一个字符串对象和创建一个其他类型的对象在过程上是有一些区别的。<br>其实关键的地方在于 “abc” 而不是 <code>new String(&quot;abc&quot;)</code>。</p>
<h2 id="字符串常量池的作用"><a href="#字符串常量池的作用" class="headerlink" title="字符串常量池的作用"></a>字符串常量池的作用</h2><h3 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h3><p>字面量(literal)是用于表达源代码中的一个固定值的表示法(notion)，比如代码中的整数、浮点数、字符串。简而言之，字符串字面量就是双引号包裹的字符串，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>在 Java 中，字符串对象就是一个 String 类型的对象，因此在程序运行时，String 类型的变量 s1 指向的一定是一个 String 对象。<strong>字面量 “a” 在某一个时刻，没有经过 new 关键字，变成了一个 String 对象</strong>。</p>
<p>接下来我们来思考一个问题，程序中每一个字符串字面量都要对应着生成一个单独的 String 对象吗？考虑到 Java 中 String 对象是不可变的，显然相同的字符串字面量完全可以共用一个 String 对象从而避免重复创建对象。JVM 也是这样设计的，这些可以共用的 String 对象组成了一个字符串常量池。</p>
<ol>
<li>第一次遇到某一个字符串字面量时，会在字符串常量池中创建一个 String 对象，以后遇到相同的字符串字面量，就复用该对象，不再重复创建。</li>
<li>每一次 new 都会创建一个新的 String 对象。</li>
</ol>
<p>ps: 以上的“遇到某一个字符串字面量”就是很纯粹地指代程序的源代码中出现用双引号括起来的字符串字面量。</p>
<h3 id="进入字符串常量池的两种情况"><a href="#进入字符串常量池的两种情况" class="headerlink" title="进入字符串常量池的两种情况"></a>进入字符串常量池的两种情况</h3><p>因此，<strong>如果字符串常量池中没有值为 “abc” 的 String 对象</strong>，<code>new String(&quot;abc&quot;)</code> 语句将涉及两个 String 对象的创建，第一个是因为括号里的 “abc” 而在字符串常量池中生成的，第二个才是 new 关键字在堆中创建的；否则只会涉及一个 String 对象的创建。<br>为什么上面改用<strong>如果字符串常量池中没有值为 “abc” 的 String 对象</strong>呢？这是因为，字符串常量池里保留的 String 对象有两种产生来源：</p>
<ol>
<li>因为第一次遇到字符串字面量而生成的字符串对象。</li>
<li>使用 <code>java.lang.String#intern</code> 主动地尝试将字符串对象放入字符串常量池。</li>
</ol>
<h2 id="常量池的分类"><a href="#常量池的分类" class="headerlink" title="常量池的分类"></a>常量池的分类</h2><ol>
<li>Class 文件中的常量池(Constant Pool)</li>
<li>运行时常量池(Runtime Constant Pool)</li>
<li>字符串常量池</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableTest_1</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>javap -v .\StringTableTest_1.class</code> 进行反编译，摘取重要部分：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">1 = Methodref          <span class="comment">#6.#24         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">2 = String             <span class="comment">#25            // a</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">3 = String             <span class="comment">#26            // b</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">4 = String             <span class="comment">#27            // ab</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">25 = Utf8               a</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">26 = Utf8               b</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">27 = Utf8               ab</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0: ldc           #2                  // String a</span><br><span class="line">2: astore_1</span><br><span class="line">3: ldc           #3                  // String b</span><br><span class="line">5: astore_2</span><br><span class="line">6: ldc           #4                  // String ab</span><br><span class="line">8: astore_3</span><br><span class="line">9: return</span><br></pre></td></tr></table></figure>
<ul>
<li>Class 文件中的常量池 Constant pool 会记录代码中出现的字面量（文本文件）。</li>
<li>运行时常量池是方法区的一部分，Class 文件中的常量池的内容，在类加载后，就进入了运行时常量池中（内存中的数据）。</li>
<li>字符串常量池，记录 interned string 的一个全局表，JDK 6 前在方法区，后移到堆中。</li>
</ul>
<h2 id="字符串常量池的位置和形式"><a href="#字符串常量池的位置和形式" class="headerlink" title="字符串常量池的位置和形式"></a>字符串常量池的位置和形式</h2><p>在《深入理解Java虚拟机》提到：字符串常量池的位置从 JDK 7 开始，从永久代中移到了堆中。在这句话中，字符串常量池像是一个特定的内存区域，存储了 interned string 的实例。</p>
<img src="/2023/11/03/testing-and-analysis-of-StringTable/Pasted%20image%2020231103113047.png" class="" title="字符串常量池的位置">

<h3 id="验证字符串常量池的位置"><a href="#验证字符串常量池的位置" class="headerlink" title="验证字符串常量池的位置"></a>验证字符串常量池的位置</h3><p>书中使用了以下方式来验证字符串常量池的位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableTest_8</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// JDK 1.8 设置 -Xmx10m -XX:-UseGCOverheadLimit    </span></span><br><span class="line">    <span class="comment">// JDK 1.6 设置 -XX:MaxPerSize=10m</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">260000</span>; j++) &#123;  </span><br><span class="line">                list.add(String.valueOf(j).intern());  </span><br><span class="line">                i++;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">            System.out.println(i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 JDK 8 中异常如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure>
<p>在 JDK 6 中异常如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: PermGen space</span><br></pre></td></tr></table></figure>

<p>同时书中也提到了，在字符串常量池的位置改变后，它只用保存第一次出现时字符串对象的引用。JDK 8 中的 intern 方法可以印证该说法，方法注释中提到：如果字符串常量池中已存在相等(equals)的字符串，那就返回已存在的对象（这样原先准备加入的对象就可以释放）；否则，将字符串对象加入字符串常量池中，直接返回对该对象的引用（不用像 JDK 6 时，复制一个对象加入常量池，返回该复制对象的引用）。</p>
<h3 id="关于-intern-的实验"><a href="#关于-intern-的实验" class="headerlink" title="关于 intern 的实验"></a>关于 intern 的实验</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableTest_5</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="comment">// &quot;a&quot;、&quot;b&quot; 作为字符串字面量，会解析得到字符串对象放入字符串常量池      </span></span><br><span class="line">        <span class="comment">// 但是 new String(&quot;a&quot;) 创建出来的字符串对象，不会进入字符串常量池        </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);  </span><br><span class="line">        <span class="comment">// intern 方法尝试将 s1 放入 StringTable，无则放入，返回该对象引用，有则返回已存在对象的引用  </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.intern();  </span><br><span class="line">  </span><br><span class="line">        <span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;  </span><br><span class="line">  </span><br><span class="line">		System.out.println(s2 == x);  </span><br><span class="line">		System.out.println(s1 == x); </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableTest_6</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="comment">// 将 &quot;ab&quot; 的赋值语句提前到最开始，&quot;ab&quot; 生成的字符串对象进入字符串常量池       </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);  </span><br><span class="line">        <span class="comment">// intern 方法尝试将 s1 放入 StringTable，无则放入，返回该对象引用，有则返回已存在对象的引用  </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.intern();  </span><br><span class="line">  </span><br><span class="line">        System.out.println(s2 == x);  </span><br><span class="line">        System.out.println(s1 == x);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实验结果证实了上述说法。</p>
<h3 id="字符串常量池到底是什么？"><a href="#字符串常量池到底是什么？" class="headerlink" title="字符串常量池到底是什么？"></a>字符串常量池到底是什么？</h3><p>但是 <a href="https://www.zhihu.com/people/logirl.cc">xinxi</a> 提及：字符串常量池，也称为 StringTable，本质上是一个惰性维护的哈希表，是一个纯运行时的结构，只存储对 <code>java.lang.String</code> 实例的引用，而不存储 String 对象的内容。当我们提到一个字符串进入字符串常量池其实是说在这个 StringTable 中保存了对它的引用，反之，如果说没有在其中就是说 StringTable 中没有对它的引用。<br><a href="https://blog.csdn.net/zyplanke">zyplanke</a> 分析 StringTable 在内存中的形式时，也表达了类似的观点。</p>
<img src="/2023/11/03/testing-and-analysis-of-StringTable/Pasted%20image%2020231103194544.png" class="" title="StringTable 的内存形式">

<p>尽管这个疑问似乎不妨碍我们理解很多东西，但是深究之后，真的让人困惑，网上也没有搜集到更多的信息。字符串常量池和 StringTable 是否等价？字符串常量池更准确的说法是否是“一个保存引用的 StringTable 加上分布在堆（JDK 6 以前的永久代）中的字符串实例”？<br>已经好几次打开 jvm 的源码，却看不懂它到底什么意思啊！！！！！难道是时候开始学 C++ 了吗。</p>
<h2 id="进入字符串常量池的时机"><a href="#进入字符串常量池的时机" class="headerlink" title="进入字符串常量池的时机"></a>进入字符串常量池的时机</h2><p>前面提到了第一次遇到的字符串字面量会在某一个时刻，生成对应的字符串对象进入字符串常量池，同时也提到了，字符串常量池（StringTable）的维护是懒惰的，那么这些究竟是什么时候发生的呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableTest_12</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"> 0: new           #2                  // class java/lang/String</span><br><span class="line"> 3: dup</span><br><span class="line"> 4: ldc           #3                  // String ab</span><br><span class="line"> 6: invokespecial #4                  // Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br><span class="line"> 9: pop</span><br><span class="line">10: return</span><br></pre></td></tr></table></figure>

<p><a href="https://www.zhihu.com/people/rednaxelafx">RednaxelaFX</a> 的文章提到：</p>
<blockquote>
<p>在类加载阶段，JVM 会在堆中创建对应这些 class 文件常量池中的字符串对象实例，并在字符串常量池中驻留其引用。具体在 resolve 阶段执行。这些常量全局共享。</p>
</blockquote>
<p><a href="https://www.zhihu.com/people/logirl.cc">xinxi</a> 的文章中补充到：</p>
<blockquote>
<p>这里说的比较笼统，没错，是 resolve 阶段，但是并不是大家想的那样，立即就创建对象并且在字符串常量池中驻留了引用。 <strong>JVM规范里明确指定resolve阶段可以是lazy的。</strong><br>……<br>就 HotSpot VM 的实现来说，加载类的时候，那些字符串字面量会进入到当前类的运行时常量池，不会进入全局的字符串常量池（即在 StringTable 中并没有相应的引用，在堆中也没有对应的对象产生）。</p>
</blockquote>
<p>《深入理解Java虚拟机》中提到：</p>
<blockquote>
<p>《Java虚拟机规范》之中并未规定解析阶段发生的具体时间，只要求了在执行ane-warray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invoke-special、invokestatic、invokevirtual、ldc、ldc_w、ldc2_w、multianewarray、new、putfield和putstatic这17个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。所以虚拟机实现可以根据需要来自行判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。</p>
</blockquote>
<p>综上可知，字符串字面量的解析是属于类加载的解析阶段，但是《Java虚拟机规范》并未规定解析发生的具体时间，只要求在执行一些字节码指令前进行，其中包括了 ldc 指令。虚拟机的具体实现，比如 Hotspot 就在执行 <code>ldc #indexNumber</code> 前触发解析，根据字符串常量池中是否已存在字符串对象决定是否创建对象，并将对象推送到栈顶。<br>这也证实了前文中提到的字符串字面量生成字符串对象和 new 关键字无关。</p>
<h3 id="验证延迟实例化"><a href="#验证延迟实例化" class="headerlink" title="验证延迟实例化"></a>验证延迟实例化</h3><p>使用 IDEA memory 功能，观察字符串对象的个数逐个变化。</p>
<ol>
<li>直到第一次运行到字符串字面量时，才会创建对应的字符串对象。</li>
<li>相同的字符串常量，不会重复创建字符串对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableTest_4</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        System.out.println();  </span><br><span class="line">         </span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;4&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;5&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;6&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;7&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;8&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;9&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;0&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;4&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;5&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;6&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;7&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;8&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;9&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;0&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2023/11/03/testing-and-analysis-of-StringTable/Pasted%20image%2020231102225445.png" class="" title="字符串字面量延迟实例化">

<h2 id="字符串常量池的垃圾回收和性能优化"><a href="#字符串常量池的垃圾回收和性能优化" class="headerlink" title="字符串常量池的垃圾回收和性能优化"></a>字符串常量池的垃圾回收和性能优化</h2><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>前文提到字符串常量池在 JDK 7 开始移到堆中，是因为考虑在方法区中的垃圾回收是比较困难的，同时随着字节码技术的发展，CGLib 等会大量动态生成类的技术的运用使得方法区的内存紧张，将字符串常量池移到堆中，可以有效提高其垃圾回收效率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableTest_9</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// -Xmx10m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails -verbose:gc  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="comment">// 0-&gt;100-&gt;10000，观察统计信息中数量的变化以及垃圾回收记录</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;  </span><br><span class="line">                String.valueOf(j).intern();  </span><br><span class="line">                i++;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">            System.out.println(i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 2048K-&gt;488K(2560K)] 2048K-&gt;856K(9728K), 0.0007745 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">StringTable statistics:</span><br><span class="line">Number of buckets       :     60013 =    480104 bytes, avg   8.000</span><br><span class="line">Number of entries       :      7277 =    174648 bytes, avg  24.000</span><br><span class="line">Number of literals      :      7277 =    421560 bytes, avg  57.930</span><br><span class="line">Total footprint         :           =   1076312 bytes</span><br><span class="line">Average bucket size     :     0.121</span><br><span class="line">Variance of bucket size :     0.125</span><br><span class="line">Std. dev. of bucket size:     0.354</span><br><span class="line">Maximum bucket size     :         3</span><br></pre></td></tr></table></figure>

<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><h4 id="调整-buckets-size"><a href="#调整-buckets-size" class="headerlink" title="调整 buckets size"></a>调整 buckets size</h4><p>当 size 过小，哈希碰撞增加，链表变长，效率会变低，需要增大 buckets size。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableTest_10</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// -XX:StringTableSize=200000 -XX:+PrintStringTableStatistics  </span></span><br><span class="line">    <span class="comment">// 默认-&gt;200000-&gt;1009(最小值)，观察耗时  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/main/resources/linux.words&quot;</span>), StandardCharsets.UTF_8))) &#123;  </span><br><span class="line">            <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">            <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();  </span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;  </span><br><span class="line">                line = br.readLine();  </span><br><span class="line">                <span class="keyword">if</span> (line == <span class="literal">null</span>) &#123;  </span><br><span class="line">                    <span class="keyword">break</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">                line.intern();  </span><br><span class="line">            &#125;  </span><br><span class="line">            System.out.println(<span class="string">&quot;cost: &quot;</span> + (System.nanoTime() - start) / <span class="number">1000000</span>) ;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="主动运用-intern-的场景"><a href="#主动运用-intern-的场景" class="headerlink" title="主动运用 intern 的场景"></a>主动运用 intern 的场景</h4><p>当你需要大量缓存重复的字符串时，使用 intern 可以大大减少内存占用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableTest_11</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// -Xms500m -Xmx500m -XX:StringTableSize=200000 -XX:+PrintStringTableStatistics  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">        List&lt;String&gt; words = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">        System.in.read();  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;  </span><br><span class="line">            <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/main/resources/linux.words&quot;</span>), StandardCharsets.UTF_8))) &#123;  </span><br><span class="line">                <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">                <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();  </span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;  </span><br><span class="line">                    line = br.readLine();  </span><br><span class="line">                    <span class="keyword">if</span> (line == <span class="literal">null</span>) &#123;  </span><br><span class="line">                        <span class="keyword">break</span>;  </span><br><span class="line">                    &#125;    </span><br><span class="line">                    <span class="comment">// words.add(line);  </span></span><br><span class="line">                    words.add(line.intern());  </span><br><span class="line">                &#125;  </span><br><span class="line">                System.out.println(<span class="string">&quot;cost: &quot;</span> + (System.nanoTime() - start) / <span class="number">1000000</span>) ;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.in.read();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 VisualVM 观察字符串和 char[] 内存占用情况，可以发现提升显著。</p>
<img src="/2023/11/03/testing-and-analysis-of-StringTable/Pasted%20image%2020231103131707.png" class="" title="intern 减少内存占用">

<h2 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h2><h3 id="变量的拼接"><a href="#变量的拼接" class="headerlink" title="变量的拼接"></a>变量的拼接</h3><p>字符串变量的拼接，底层是使用 StringBuilder 实现：<code>new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString()</code>，而 toString 方法使用拼接得到的 char 数组创建一个新的 String 对象，因此 s3 和 s4 是不相同的两个对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableTest_2</span> &#123;  </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"> 0: ldc           #2                  // String a</span><br><span class="line"> 2: astore_1</span><br><span class="line"> 3: ldc           #3                  // String b</span><br><span class="line"> 5: astore_2</span><br><span class="line"> 6: ldc           #4                  // String ab</span><br><span class="line"> 8: astore_3</span><br><span class="line"> 9: new           #5                  // class java/lang/StringBuilder</span><br><span class="line">12: dup</span><br><span class="line">13: invokespecial #6                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">16: aload_1</span><br><span class="line">17: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">20: aload_2</span><br><span class="line">21: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">24: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">27: astore        4</span><br><span class="line">29: return</span><br></pre></td></tr></table></figure>

<h3 id="常量的拼接"><a href="#常量的拼接" class="headerlink" title="常量的拼接"></a>常量的拼接</h3><p>字符串常量的拼接是在编译期间，因为已知结果而被优化为一个字符串常量。又因为 “ab” 字符串在 StringTable 中是已存在的，所以不会重新创建新对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableTest_3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"> 0: ldc           #2                  // String a</span><br><span class="line"> 2: astore_1</span><br><span class="line"> 3: ldc           #3                  // String b</span><br><span class="line"> 5: astore_2</span><br><span class="line"> 6: ldc           #4                  // String ab</span><br><span class="line"> 8: astore_3</span><br><span class="line"> 9: new           #5                  // class java/lang/StringBuilder</span><br><span class="line">12: dup</span><br><span class="line">13: invokespecial #6                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">16: aload_1</span><br><span class="line">17: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">20: aload_2</span><br><span class="line">21: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">24: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">27: astore        4</span><br><span class="line">29: ldc           #4                  // String ab</span><br><span class="line">31: astore        5</span><br><span class="line">33: return</span><br></pre></td></tr></table></figure>

<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="https://www.zhihu.com/question/55994121/answer/147296098">Java 中new String(“字面量”) 中 “字面量” 是何时进入字符串常量池的? - xinxi的回答 - 知乎</a></li>
<li><a href="https://www.iteye.com/topic/774673">请别再拿“String s &#x3D; new String(“xyz”);创建了多少个String实例”来面试了吧</a></li>
<li><a href="https://blog.csdn.net/zyplanke/article/details/108699727">JVM中字符串常量池StringTable在内存中形式分析</a></li>
</ol>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 内存区域的测试和分析</title>
    <url>/2023/11/04/testing-and-analysis-of-jvm-memory-area/</url>
    <content><![CDATA[<h2 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h2><p>JVM 内存区域划分为：</p>
<ul>
<li>程序计数器</li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
<li>堆</li>
<li>方法区</li>
</ul>
<img src="/2023/11/04/testing-and-analysis-of-jvm-memory-area/Pasted%20image%2020231102215652.png" class="" title="内存区域划分">

<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>Java 虚拟机栈（Java Virtual Machine Stack），线程私有，生命周期与线程相同。虚拟机栈描述的是 Java 方法执行的线程内存模型。每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。</p>
<p>可以使用 <code>-Xss1024k</code> 设置虚拟机栈的大小。默认情况下都是 1024k，只有 Windows 中取决于虚拟内存。</p>
<h3 id="栈内存溢出"><a href="#栈内存溢出" class="headerlink" title="栈内存溢出"></a>栈内存溢出</h3><ol>
<li>栈帧过多导致栈内存溢出</li>
<li>栈帧过大导致栈内存溢出（难复现）</li>
</ol>
<h4 id="不正确的递归调用"><a href="#不正确的递归调用" class="headerlink" title="不正确的递归调用"></a>不正确的递归调用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackTest_4</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变栈的大小限制 -Xss256k，观察调用次数的变化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            method1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 默认情况下经过 20000+ 次，改变参数后 3000+ 次</span></span><br><span class="line">            System.out.println(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">        method1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="循环引用导致-JSON-解析无限循环"><a href="#循环引用导致-JSON-解析无限循环" class="headerlink" title="循环引用导致 JSON 解析无限循环"></a>循环引用导致 JSON 解析无限循环</h4><p>并非只有自己写的递归方法可能引发栈内存溢出，有可能第三方库也会引发栈内存溢出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackTest_5</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">        <span class="type">Department</span> <span class="variable">department</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Department</span>();</span><br><span class="line">        department.setName(<span class="string">&quot;Tech&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">employee1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">        employee1.setName(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        employee1.setDepartment(department);</span><br><span class="line"></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">employee2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">        employee2.setName(<span class="string">&quot;Tim&quot;</span>);</span><br><span class="line">        employee2.setDepartment(department);</span><br><span class="line"></span><br><span class="line">        department.setEmployees(Arrays.asList(employee1, employee2));</span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        System.out.println(objectMapper.writeValueAsString(department));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Department</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> List&lt;Employee&gt; employees;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> List&lt;Employee&gt; <span class="title function_">getEmployees</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> employees;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmployees</span><span class="params">(List&lt;Employee&gt; employees)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.employees = employees;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> Department department;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Department <span class="title function_">getDepartment</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> department;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDepartment</span><span class="params">(Department department)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.department = department;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="局部变量的线程安全问题"><a href="#局部变量的线程安全问题" class="headerlink" title="局部变量的线程安全问题"></a>局部变量的线程安全问题</h3><ol>
<li>局部变量如果未逃离方法的作用范围，就是线程安全的。</li>
<li>局部变量如果是引用类型且逃离了方法的作用范围，就是线程不安全的。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackTest_3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        method1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(<span class="number">1</span>);</span><br><span class="line">        sb.append(<span class="number">2</span>);</span><br><span class="line">        sb.append(<span class="number">3</span>);</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程不安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(StringBuilder sb)</span> &#123;</span><br><span class="line">        sb.append(<span class="number">1</span>);</span><br><span class="line">        sb.append(<span class="number">2</span>);</span><br><span class="line">        sb.append(<span class="number">3</span>);</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程不安全，看到一个说法：发生指令重排，sb 的 append 操作发生在返回之后（有待确认）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> StringBuilder <span class="title function_">method3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(<span class="number">1</span>);</span><br><span class="line">        sb.append(<span class="number">2</span>);</span><br><span class="line">        sb.append(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程问题排查"><a href="#线程问题排查" class="headerlink" title="线程问题排查"></a>线程问题排查</h3><h4 id="CPU-占用率居高不下"><a href="#CPU-占用率居高不下" class="headerlink" title="CPU 占用率居高不下"></a>CPU 占用率居高不下</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest_1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="literal">null</span>, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t1...&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="literal">null</span>, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t2...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="literal">null</span>, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t3...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread3&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当发现 CPU 占用率居高不下时，可以尝试以下步骤：</p>
<ol>
<li><code>top</code>，定位 cpu 占用高的进程 id。</li>
<li><code>ps H -eo pid,tid,%cpu | grep pid</code>，进一步定位引起 cpu 占用高的线程 id。</li>
<li><code>jstack pid</code>，根据线程 id 换算成 16进制的 nid 找到对应线程，进一步定位到问题的源码行号。</li>
</ol>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">&quot;thread1&quot; #8 prio=5 os_prio=0 tid=0x00007f9bd0162800 nid=0x1061ad runnable [0x00007f9bd56eb000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">	at com.moralok.jvm.thread.ThreadTest_1.lambda$main$0(ThreadTest_1.java:10)</span><br><span class="line">	at com.moralok.jvm.thread.ThreadTest_1$$Lambda$1/250421012.run(Unknown Source)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:750)</span><br></pre></td></tr></table></figure>

<h4 id="死锁，迟迟未返回结果"><a href="#死锁，迟迟未返回结果" class="headerlink" title="死锁，迟迟未返回结果"></a>死锁，迟迟未返回结果</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest_2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">A</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">B</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="literal">null</span>, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t1...&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; get A&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; get B&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="literal">null</span>, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t2...&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; get B&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; get A&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>jstack pid</code>，会显示找到死锁，以及死锁涉及的线程,，并各自持有的锁还有等待的锁。</li>
<li>其他工具如 jconsole 也具有检测死锁的功能。</li>
</ol>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆（Heap）的特点：</p>
<ol>
<li>线程共享，需要考虑线程安全问题。</li>
<li>存在垃圾回收机制。</li>
<li>使用 -Xmx8m 设置大小。</li>
</ol>
<h3 id="堆内存溢出"><a href="#堆内存溢出" class="headerlink" title="堆内存溢出"></a>堆内存溢出</h3><p>既然堆有垃圾回收机制，为什么还会发生内存溢出呢？最开始的时候，我也有这样的困惑。<br>后来我才认识到，还在使用中的对象是不能被强制回收的，不再使用的对象不是立刻回收的。当创建对象却没有足够的内存空间时，如果清理掉那些不再使用的对象就有足够的内存空间，就不会发生内存溢出，程序只是表现为卡顿。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapTest_1</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// -Xmx8m  </span></span><br><span class="line">    <span class="comment">// 不设置可能不提示 Java heap space，出错地方不同，报错信息不同  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;  </span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;  </span><br><span class="line">                list.add(s);  </span><br><span class="line">                s = s + s;  </span><br><span class="line">                i++;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;  </span><br><span class="line">            t.printStackTrace();  </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;运行次数 &quot;</span> + i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at java.util.Arrays.copyOf(Arrays.java:3332)</span><br><span class="line">	at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:124)</span><br><span class="line">	at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:448)</span><br><span class="line">	at java.lang.StringBuilder.append(StringBuilder.java:141)</span><br><span class="line">	at com.moralok.jvm.memory.heap.HeapTest_1.main(HeapTest_1.java:21)</span><br><span class="line">运行次数 17</span><br></pre></td></tr></table></figure>

<p>堆内存溢出的发生往往需要长时间的运行，因此在排查相关问题时，可以适当调小堆内存。</p>
<h3 id="监测堆内存"><a href="#监测堆内存" class="headerlink" title="监测堆内存"></a>监测堆内存</h3><ol>
<li>使用 jps 查看 Java 进程列表</li>
<li>使用 <code>jmap -heap pid</code> 查看堆内存信息</li>
<li>还可以使用 jconsole 观察堆内存变化曲线</li>
<li>还可以使用 VisualVM 查看堆信息</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapTest_2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1...&quot;</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">30</span>);</span><br><span class="line">        <span class="comment">// 堆空间占用上升 10MB</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>];</span><br><span class="line">        System.out.println(<span class="string">&quot;2...&quot;</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">30</span>);</span><br><span class="line">        bytes = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 堆空间占用下降</span></span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">&quot;3...&quot;</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>jmap -heap pid</code> 查看堆内存信息：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Eden Space:</span><br><span class="line">   capacity = 268435456 (256.0MB)</span><br><span class="line">   used     = 32212360 (30.72010040283203MB)</span><br><span class="line"></span><br><span class="line">   used     = 42698136 (40.720115661621094MB)</span><br><span class="line"></span><br><span class="line">   used     = 5368728 (5.120018005371094MB)</span><br></pre></td></tr></table></figure>

<p>使用 jconsole 查看堆内存信息：</p>
<img src="/2023/11/04/testing-and-analysis-of-jvm-memory-area/Pasted%20image%2020231104200411.png" class="" title="jconsole 观察堆内存占用">

<h3 id="堆内存占用居高不下"><a href="#堆内存占用居高不下" class="headerlink" title="堆内存占用居高不下"></a>堆内存占用居高不下</h3><p>当你发现堆内存占用居高不下，经过 GC，下降也不明显，如果你想查看一下堆内的具体情况，可以将其 dump 查看。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapTest_3</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// jps 查进程，jmap 看堆内存，jconsole 执行GC，堆内存占用没有明显下降  </span></span><br><span class="line">    <span class="comment">// 使用 VisualVM 的堆 dump 功能，观察大对象  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">        List&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;  </span><br><span class="line">            students.add(<span class="keyword">new</span> <span class="title class_">Student</span>());  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.in.read();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="type">byte</span>[] score = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可使用 VisualVM 的 Heap Dump 功能：</p>
<img src="/2023/11/04/testing-and-analysis-of-jvm-memory-area/Pasted%20image%2020231104201139.png" class="" title="VisualVM 观察堆中的大对象">

<p>也可使用 <code>jmap -dump:format=b,file=filename.hprof pid</code>，需要其他分析工具搭配。</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>根据《Java虚拟机规范》，方法区在逻辑上是堆的一部分，但是在具体实现上，各个虚拟机厂商并不相同。对于 Hotspot 而言：</p>
<ul>
<li>JDK 8 之前，方法区的具体实现为永久代，使用堆内存，使用 -XX:MaxPermSize&#x3D;10m 设置大小。</li>
<li>JDK 8 开始，方法区的具体实现为元空间，使用直接内存，使用 -XX:MaxMetaspaceSize&#x3D;10m 设置大小。</li>
</ul>
<h3 id="方法区溢出"><a href="#方法区溢出" class="headerlink" title="方法区溢出"></a>方法区溢出</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAreaTest_1</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -XX:MaxMetaspaceSize=8m MaxMetaspaceSize is too small.</span></span><br><span class="line">    <span class="comment">// -XX:MaxMetaspaceSize=10m java.lang.OutOfMemoryError: Compressed class space</span></span><br><span class="line">    <span class="comment">// 不是 Metaspace 应该是某个参数设置的问题</span></span><br><span class="line">    <span class="comment">// JDK 6: -XX:MaxPermSize=8m PermGen space</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">MethodAreaTest_1</span> <span class="variable">methodAreaTest1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodAreaTest_1</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++, j++) &#123;</span><br><span class="line">                <span class="type">ClassWriter</span> <span class="variable">classWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">// 版本号，public，类名，包名，父类，接口</span></span><br><span class="line">                classWriter.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, <span class="string">&quot;Class&quot;</span> + i, <span class="literal">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">                <span class="comment">// 返回二进制字节码</span></span><br><span class="line">                <span class="type">byte</span>[] code = classWriter.toByteArray();</span><br><span class="line">                <span class="comment">// 加载类</span></span><br><span class="line">                methodAreaTest1.defineClass(<span class="string">&quot;Class&quot;</span> + i, code, <span class="number">0</span>, code.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;次数 &quot;</span> + j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>当设置的值太小时 -XX:MaxMetaspaceSize&#x3D;8m，提示 MaxMetaspaceSize is too small。</li>
<li>实验中抛出 java.lang.OutOfMemoryError: Compressed class space。</li>
<li>添加参数 -XX:-UseCompressedClassPointers 后，抛出 java.lang.OutOfMemoryError: Metaspace。</li>
<li>JDK 6 设置 -XX:MaxPermSize&#x3D;8m，抛出 java.lang.OutOfMemoryError: PermGen space。</li>
</ol>
<p>不要认为自己不会写动态生成字节码相关的代码就忽略这方面的问题，如今很多框架使用字节码技术大量地动态生成类。</p>
<h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>二进制字节码文件主要包含三类信息：</p>
<ol>
<li>类的基本信息</li>
<li>类的常量池（Constant Pool）</li>
<li>类的方法信息</li>
</ol>
<h3 id="使用-javap-反编译"><a href="#使用-javap-反编译" class="headerlink" title="使用 javap 反编译"></a>使用 javap 反编译</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAreaTest_2</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Classfile /C:/Users/username/Documents/github/jvm-study/target/classes/com/moralok/jvm/memory/methodarea/MethodAreaTest_2.class</span><br><span class="line">  Last modified 2023-11-4; size 619 bytes</span><br><span class="line">  MD5 checksum 0ed10a8f0a03be54fd4159958ee7446c</span><br><span class="line">  Compiled from &quot;MethodAreaTest_2.java&quot;</span><br><span class="line">public class com.moralok.jvm.memory.methodarea.MethodAreaTest_2</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">1 = Methodref          <span class="comment">#6.#20         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">2 = Fieldref           <span class="comment">#21.#22        // java/lang/System.out:Ljava/io/PrintStream;</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">3 = String             <span class="comment">#23            // hello world</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">4 = Methodref          <span class="comment">#24.#25        // java/io/PrintStream.println:(Ljava/lang/String;)V</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">5 = Class              <span class="comment">#26            // com/moralok/jvm/memory/methodarea/MethodAreaTest_2</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">6 = Class              <span class="comment">#27            // java/lang/Object</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">7 = Utf8               &lt;init&gt;</span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">8 = Utf8               ()V</span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">9 = Utf8               Code</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">10 = Utf8               LineNumberTable</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">11 = Utf8               LocalVariableTable</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">12 = Utf8               this</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">13 = Utf8               Lcom/moralok/jvm/memory/methodarea/MethodAreaTest_2;</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">14 = Utf8               main</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">15 = Utf8               ([Ljava/lang/String;)V</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">16 = Utf8               args</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">17 = Utf8               [Ljava/lang/String;</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">18 = Utf8               SourceFile</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">19 = Utf8               MethodAreaTest_2.java</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">20 = NameAndType        <span class="comment">#7:#8          // &quot;&lt;init&gt;&quot;:()V</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">21 = Class              <span class="comment">#28            // java/lang/System</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">22 = NameAndType        <span class="comment">#29:#30        // out:Ljava/io/PrintStream;</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">23 = Utf8               hello world</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">24 = Class              <span class="comment">#31            // java/io/PrintStream</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">25 = NameAndType        <span class="comment">#32:#33        // println:(Ljava/lang/String;)V</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">26 = Utf8               com/moralok/jvm/memory/methodarea/MethodAreaTest_2</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">27 = Utf8               java/lang/Object</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">28 = Utf8               java/lang/System</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">29 = Utf8               out</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">30 = Utf8               Ljava/io/PrintStream;</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">31 = Utf8               java/io/PrintStream</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">32 = Utf8               println</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">33 = Utf8               (Ljava/lang/String;)V</span></span><br><span class="line">&#123;</span><br><span class="line">  public com.moralok.jvm.memory.methodarea.MethodAreaTest_2();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom/moralok/jvm/memory/methodarea/MethodAreaTest_2;</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #3                  // String hello world</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 6: 0</span><br><span class="line">        line 7: 8</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       9     0  args   [Ljava/lang/String;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;MethodAreaTest_2.java&quot;</span><br></pre></td></tr></table></figure>

<ol>
<li>Class 文件的常量池就是一张表，虚拟机根据索引去查找类名、字段名及其类型，方法名及其参数类型和字面量等。</li>
<li>当类被加载到虚拟机之后，Class 文件中的常量池中的信息就进入到了运行时常量池。</li>
<li>这个过程其实就是信息从文件进入了内存。</li>
</ol>
<p>虚拟机解释器（interpreter）需要解释的字节码指令如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">0: getstatic     #2</span><br><span class="line">3: ldc           #3</span><br><span class="line">5: invokevirtual #4</span><br></pre></td></tr></table></figure>
<p>索引 <code>#2</code> 的意思就是去常量表里查找对应项代表的事物。</p>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><ul>
<li>常见于 NIO 操作中的数据缓冲区。</li>
<li>分配和回收的成本较高，但读写性能更高。</li>
<li>不由 JVM 进行内存释放</li>
</ul>
<h3 id="NIO-和-IO-的拷贝性能"><a href="#NIO-和-IO-的拷贝性能" class="headerlink" title="NIO 和 IO 的拷贝性能"></a>NIO 和 IO 的拷贝性能</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectMemoryTest_1</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FROM</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\username\\Videos\\jellyfin\\media\\movies\\Harry Potter and the Chamber of Secrets (2002) [1080p]\\Harry.Potter.and.the.Chamber.of.Secrets.2002.1080p.BrRip.x264.YIFY.mp4&quot;</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TO</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\username\\Videos\\jellyfin\\media\\movies\\Harry Potter and the Chamber of Secrets (2002) [1080p]\\Harry.Potter.and.the.Chamber.of.Secrets.2002.1080p.BrRip.x264.YIFY-copy.mp4&quot;</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1Mb</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        io();  </span><br><span class="line">        directBuffer();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">directBuffer</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();  </span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileChannel</span> <span class="variable">from</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(FROM).getChannel();  </span><br><span class="line">             <span class="type">FileChannel</span> <span class="variable">to</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(TO).getChannel()) &#123;  </span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(_1Mb);  </span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;  </span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> from.read(buffer);  </span><br><span class="line">                <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;  </span><br><span class="line">                    <span class="keyword">break</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">                buffer.flip();  </span><br><span class="line">                to.write(buffer);  </span><br><span class="line">                buffer.clear();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();  </span><br><span class="line">        System.out.println(<span class="string">&quot;directBuffer 用时 &quot;</span> + (end - start) / <span class="number">1000_000.0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">io</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();  </span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">from</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(FROM);  </span><br><span class="line">             <span class="type">FileOutputStream</span> <span class="variable">to</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(TO)) &#123;  </span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[_1Mb];  </span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;  </span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> from.read(buffer);  </span><br><span class="line">                <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;  </span><br><span class="line">                    <span class="keyword">break</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">                to.write(buffer);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();  </span><br><span class="line">        System.out.println(<span class="string">&quot;io 用时 &quot;</span> + (end - start) / <span class="number">1000_000.0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">io 用时 1676.9797</span><br><span class="line">directBuffer 用时 836.4796</span><br></pre></td></tr></table></figure>

<img src="/2023/11/04/testing-and-analysis-of-jvm-memory-area/Pasted%20image%2020231104235546.png" class="" title="普通的 IO 拷贝">

<img src="/2023/11/04/testing-and-analysis-of-jvm-memory-area/Pasted%20image%2020231104235846.png" class="" title="NIO 拷贝">


<h3 id="直接内存溢出"><a href="#直接内存溢出" class="headerlink" title="直接内存溢出"></a>直接内存溢出</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectMemoryTest_2</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_100Mb</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        List&lt;ByteBuffer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;  </span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(_100Mb);  </span><br><span class="line">                list.add(byteBuffer);  </span><br><span class="line">                i++;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;  </span><br><span class="line">            t.printStackTrace();  </span><br><span class="line">        &#125; System.out.println(i);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Direct buffer memory</span><br><span class="line">	at java.nio.Bits.reserveMemory(Bits.java:695)</span><br><span class="line">	at java.nio.DirectByteBuffer.&lt;init&gt;(DirectByteBuffer.java:123)</span><br><span class="line">	at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:311)</span><br><span class="line">	at com.moralok.jvm.memory.direct.DirectMemoryTest_2.main(DirectMemoryTest_2.java:16)</span><br><span class="line">145</span><br></pre></td></tr></table></figure>

<p>这似乎是代码中抛出的异常，而不是真正的直接内存溢出？</p>
<h3 id="直接内存释放的原理"><a href="#直接内存释放的原理" class="headerlink" title="直接内存释放的原理"></a>直接内存释放的原理</h3><h4 id="演示直接内存的释放受-GC-影响"><a href="#演示直接内存的释放受-GC-影响" class="headerlink" title="演示直接内存的释放受 GC 影响"></a>演示直接内存的释放受 GC 影响</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectMemoryTest_3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1GB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(_1GB);</span><br><span class="line">        System.out.println(<span class="string">&quot;分配完毕&quot;</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line">        System.out.println(<span class="string">&quot;开始释放&quot;</span>);</span><br><span class="line">        byteBuffer = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 随着 ByteBuffer 的释放，从任务管理器界面看到程序的内存的占用迅速下降 1GB。</span></span><br><span class="line">        System.gc();</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="手动进行直接内存的分配和释放"><a href="#手动进行直接内存的分配和释放" class="headerlink" title="手动进行直接内存的分配和释放"></a>手动进行直接内存的分配和释放</h4><p>在代码中实现手动进行直接内存的分配和释放。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectMemoryTest_4</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1GB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> getUnsafe();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分配内存</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> unsafe.allocateMemory(_1GB);</span><br><span class="line">        unsafe.setMemory(base, _1GB, (<span class="type">byte</span>) <span class="number">0</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放内存</span></span><br><span class="line">        unsafe.freeMemory(base);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) f.get(<span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span> unsafe;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="如何将-GC-和直接内存的分配和释放关联"><a href="#如何将-GC-和直接内存的分配和释放关联" class="headerlink" title="如何将 GC 和直接内存的分配和释放关联"></a>如何将 GC 和直接内存的分配和释放关联</h4><p>本质上，直接内存的自动释放是利用了虚引用的机制，间接调用了 unsafe 的分配和释放直接内存的方法。</p>
<p>DirectByteBuffer 就是使用 unsafe.allocateMemory(size) 分配直接内存。DirectByteBuffer 对象以及一个 Deallocator 对象（Runnable 类型）一起用于创建了一个虚引用类型的 Cleaner 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DirectByteBuffer(<span class="type">int</span> cap) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        base = unsafe.allocateMemory(size);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">    cleaner = Cleaner.create(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">Deallocator</span>(base, size, cap));</span><br><span class="line">    att = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据虚引用的机制，如果 DirectByteBuffer 对象被回收，虚引用对象会被加入到 Cleanner 的引用队列，ReferenceHandler 线程会处理引用队列中的 Cleaner 对象，进而调用 Deallocator 对象的 run 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (address == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Paranoia</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.freeMemory(address);</span><br><span class="line">    address = <span class="number">0</span>;</span><br><span class="line">    Bits.unreserveMemory(size, capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 垃圾收集</title>
    <url>/2023/11/07/garbage-collection-in-Java/</url>
    <content><![CDATA[<blockquote>
<p>每一次重新阅读，都有新的收获，也将过去这段时间以来一些新的零散的知识点串联在一起。<br>沿着周志明老师的行文脉络，了解问题发生的背景，当时的人如何思考，提出了哪些方案，各自有什么优缺点，附带产生的问题如何解决，理论研究如何应用到工程实践中，就像真实地经历一段研发历史。这让人对垃圾收集的认识不再停留在记忆上，而是深入到理解中，相关的知识点不再是空中楼阁，无根之水，而是从一些事实基础和问题自然延申出来。<br>尽管在更底层的实现上仍然缺乏认识和想象力，以至于在一些细节上还是疑惑重重，但是仍然有豁然开朗的感觉呢。比如以前看不同垃圾收集器的过程示意图如鸡肋，如今看其中的停顿和并发，只觉充满智慧。</p>
</blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>垃圾收集（Garbage Collection，简称 GC）需要考虑什么？</strong></p>
<ul>
<li>哪些内存需要回收？</li>
<li>什么时候回收？</li>
<li>如何回收？</li>
</ul>
<p><strong>为什么要去了解垃圾收集和内存分配？</strong><br>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就需要对这些“自动化技术”实施必要的监控和调节。</p>
<p><strong>在 Java 中，垃圾收集需要关注哪些内存区域？</strong><br>程序计数器、虚拟机栈和本地方法栈，随线程而生，随线程而灭，栈中的栈帧随着方法的进入和退出有条不紊地执行着入栈和出栈操作，每个栈帧中分配多少内存可以认为是<strong>编译期可知</strong>的，因此这几个区域地内存分配和回收具备确定性。<br>但是 Java 堆和方法区这两个区域则有显著的不确定性，只有<strong>运行期间</strong>，我们才知道程序会创建哪些对象，创建多少个对象，这部分内存的分配和回收是动态的。</p>
<h2 id="哪些内存需要回收？"><a href="#哪些内存需要回收？" class="headerlink" title="哪些内存需要回收？"></a>哪些内存需要回收？</h2><p><strong>哪些对象是还存活着，哪些已经死亡？</strong></p>
<blockquote>
<p>对象死亡即不可能再被任何途径使用。其实曾经的我会怀疑，遗落在内存中的对象，真的没有办法“魔法般地”获取其引用地址吗？引用变量的值不就是 64 位的数字吗？</p>
</blockquote>
<h3 id="引用计数算法（Reference-Counting）"><a href="#引用计数算法（Reference-Counting）" class="headerlink" title="引用计数算法（Reference Counting）"></a>引用计数算法（Reference Counting）</h3><p>优点：</p>
<ul>
<li>原理简单</li>
<li>判定效率高</li>
</ul>
<p>缺点：</p>
<ul>
<li>例外情况多，需要额外处理（比如循环引用）</li>
</ul>
<blockquote>
<p>提及引用计数算法，人们好像认定它无法应对循环引用因而被抛弃。虽说 Java 虚拟机中没有选用它，但是在其他计算机领域有所运用。循环引用也并非它绕不过去的难题，事实上，跨代引用问题中，老年代引用新生代形成的引用链不是也可能是一个尚未回收的孤岛吗？</p>
</blockquote>
<h3 id="可达性分析算法（Reachability-Analysis）"><a href="#可达性分析算法（Reachability-Analysis）" class="headerlink" title="可达性分析算法（Reachability Analysis）"></a>可达性分析算法（Reachability Analysis）</h3><ul>
<li>选取一系列称为“GC Roots”的根对象作为起始节点集。</li>
<li>根据引用关系向下搜索。</li>
<li>如果某个对象到 GC Roots 间没有任何引用链相连，即该对象不可能再被使用。用图论的话说，就是 GC Roots 到该对象不可达。</li>
</ul>
<img src="/2023/11/07/garbage-collection-in-Java/Pasted%20image%2020231108011042.png" class="" title="利用可达性分析算法判定对象是否可回收">

<p><strong>那么可作为 GC Roots 的对象有哪些呢？</strong><br>固定的 GC Roots，主要是在全局性引用和执行上下文中：</p>
<ol>
<li>在虚拟机栈（栈帧中的本地变量表）中引用的对象，比如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</li>
<li>在方法区中类静态属性引用的变量。</li>
<li>在方法区中类常量引用的对象，比如字符串常量池（String Table）里的引用。</li>
<li>在本地方法栈中 JNI，即 Native 方法引用的对象。</li>
<li>Java 虚拟机内部的引用，如基本类型的 Class 对象，常驻的异常类型，还有系统类加载器。</li>
<li>所有被同步锁（synchronized）持有的对象</li>
<li>反映 Java 虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等（不懂）。</li>
</ol>
<p>临时性的GC Roots：<br>除了固定的 GC Roots 集合外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入。</p>
<blockquote>
<p>比如，当针对新生代发起垃圾收集时，如果老年代对象引用了它，那么被引用的对象就不应该被回收，尽管老年代对象可能已经不可达。为此，老年代对象需要临时性加入 GC Roots 集合。<br>当然，为了避免将所有老年代对象加入 GC Roots 集合这样一看就很不合理的操作，会做一些优化处理。</p>
</blockquote>
<img src="/2023/11/07/garbage-collection-in-Java/Snipaste_2023-11-08_20-01-41.png" class="" title="跨代引用问题">

<h3 id="“引用”的概念扩充"><a href="#“引用”的概念扩充" class="headerlink" title="“引用”的概念扩充"></a>“引用”的概念扩充</h3><p>对于判断对象是否存活而言，“引用”的重要性不言而喻。但是如果对象只有“被引用”和“未被引用”两种状态，对于描述一些“内存足够就保留，内存不足就抛弃”的对象就显得无能为力。<br>缓存系统就是这样的一个典型应用场景。当内存充足时，就保留作为缓存；当内存不足时，就抛弃腾出空间给其他资源。</p>
<blockquote>
<p>曾经有一位热衷实践技术的同事就和我介绍了他在项目中使用弱引用实现的缓存模块，当时我还不太理解他为何这样做。事实上，享受自动垃圾收集的我并不能在一开始就敏锐地把握到对象在应用程序中的创建、存活和消亡过程。<br>当然我们并不推荐自己实现基于 JVM 的缓存系统，事实上他之所以提及，正是因为出了 bug。</p>
</blockquote>
<h4 id="引用的分类"><a href="#引用的分类" class="headerlink" title="引用的分类"></a>引用的分类</h4><ul>
<li>强引用（Strongly Reference），只要强引用还在，绝不会回收。</li>
<li>软引用（Soft Reference），只被软引用关联的对象，在系统发生 OOM 前，会被列入回收范围进行第二次回收。</li>
<li>弱引用（Weak Reference），只被弱引用关联的对象，只能生存到下一次垃圾收集发生为止，无论内存是否 足够，都会回收。</li>
<li>虚引用（Phantom Reference），一个对象是否有虚引用，不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。设置虚引用的唯一目的就是为了在对象被回收时收到一个系统通知。</li>
</ul>
<p>虚引用的一个经典应用是是 ByteBuffer 对象被回收时自动释放直接内存。</p>
<h4 id="弱引用的测试"><a href="#弱引用的测试" class="headerlink" title="弱引用的测试"></a>弱引用的测试</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceTest_3</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_4MB</span> <span class="operator">=</span> <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -Xmx20m -XX:+PrintGCDetails -verbose:gc</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// list -&gt; WeakReference -&gt; byte[]</span></span><br><span class="line">        List&lt;WeakReference&lt;<span class="type">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            WeakReference&lt;<span class="type">byte</span>[]&gt; ref = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[_4MB]);</span><br><span class="line">            list.add(ref);</span><br><span class="line">            System.out.print(list.size() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (WeakReference&lt;<span class="type">byte</span>[]&gt; w : list) &#123;</span><br><span class="line"></span><br><span class="line">                System.out.print(w.get() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;循环结束： &quot;</span> + list.size());</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在测试中，minor GC 并没有回收掉全部的只被弱引用关联的对象，full GC 才全部回收掉，我一度以为关于弱引用的表述不正确。后来进一步测试发现，是因为部分对象直接分配在老年代。因此更准确的表述是，每一次 GC 都会回收所在发生区域里只被弱引用关联的对象。<br>这是一个有趣的经验，让我对部分垃圾收集中的“部分”二字有更深刻的体会，原来非收集区域的对象真的对发生在其他区域的垃圾收集无感。</p>
</blockquote>
<blockquote>
<p>了解为什么扩充引用的概念，让人对引用的分类豁然开朗。我的脑海里情不自禁冒出了不太恰当的比喻：一个城市里的公民被区分了等级，一等公民（强）永远不会被强行驱逐；二等公民（软）在城市资源紧张时会被强行驱逐；三等公民（弱）被认为影响市容市貌，一旦有整顿就会被强行驱逐；一等公民里有一些需要被监视，一旦离开，会触发一个事件。</p>
</blockquote>
<h3 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize 方法"></a>finalize 方法</h3><blockquote>
<p>有趣的知识点，无趣的面试考点。</p>
</blockquote>
<h3 id="方法区的垃圾回收是什么样的？"><a href="#方法区的垃圾回收是什么样的？" class="headerlink" title="方法区的垃圾回收是什么样的？"></a>方法区的垃圾回收是什么样的？</h3><ul>
<li>《Java虚拟机规范》中提到可以不要求虚拟机在方法区实现垃圾收集</li>
<li>确实有未实现或未完整实现方法区类型卸载的收集器</li>
<li>原因是<strong>方法区垃圾收集的性价比通常比较低</strong></li>
</ul>
<p>方法区的垃圾收集主要回收两部分：</p>
<ul>
<li>废弃的常量</li>
<li>不再使用的类型</li>
</ul>
<p><strong>如何判定一个常量是否废弃？</strong><br>没有任何字符串对象引用常量池中的“java”常量，且虚拟机中也没有其他地方引用这个字面量。<br>如果这时发生垃圾回收，而且垃圾收集器判断确实有必要，才会将“java”常量清理出常量池。</p>
<blockquote>
<p>“虚拟机中也没有其他地方引用这个字面量”怎么理解？</p>
</blockquote>
<p><strong>如何判定一个类型是否可卸载？</strong></p>
<ul>
<li>该类的所有的实例都已经被回收</li>
<li>加载该类的类加载器已经被回收</li>
<li>该类对应的 Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li>
</ul>
<p>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是<br>和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot 虚拟机提供了 -Xnoclassgc 参数进行控制，还可以使用 -verbose:class 以及 -XX:+TraceClassLoading、-XX:+TraceClassUnLoading 查看类加载和卸载信息。</p>
<blockquote>
<p>条件二如此苛刻，系统类加载器不会被回收，是否意味着正常的应用程序，类一旦加载就不会卸载？<br>“无法在任何地方通过反射访问该类的方法”是否多余，Method 对象不是引用了 Class 对象吗？<br>Class 对象没有被引用时，会被回收吗？<br>卸载类是指回收 Class 对象加上清理方法区中的类的信息（怎么样的存储结构呢）吗？</p>
</blockquote>
<h2 id="如何回收：垃圾收集算法"><a href="#如何回收：垃圾收集算法" class="headerlink" title="如何回收：垃圾收集算法"></a>如何回收：垃圾收集算法</h2><p>分类：</p>
<ul>
<li>引用计数式垃圾收集（Reference Counting GC）</li>
<li>追踪式垃圾收集（Tracing GC）</li>
</ul>
<h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><p>分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则，它建立在<strong>两个分代假说</strong>之上：</p>
<ol>
<li>弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。</li>
<li>强分代假说（String Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。</li>
</ol>
<p>这两个分代假说共同奠定了多款常用垃圾收集器的<strong>一致的设计原则</strong>：收集器应该将 Java 堆划分出不同的区域，然后将回收对象依据其年龄分配到不同的区域之中存储。<br>正因为有了区域划分，垃圾收集器才可以每次只回收一个或某些部分的区域，因而才有了“Minor GC”、“Major GC”和“Full GC”等回收类型划分；针对不同区域安排与里面存储对象存亡特征相匹配的垃圾收集算法，因而才发展出“标记-复制”、“标记-清除”和“标记-整理”等垃圾收集算法。</p>
<blockquote>
<p>了解分代收集理论，分代收集算法更显得有理有据。</p>
</blockquote>
<p>一般把 Java 堆划分为新生代（Young Generation）和老年代（Old Generation）两个区域。</p>
<p><strong>针对不同分代的垃圾收集分类：</strong></p>
<ul>
<li>部分收集（Partial GC）：目标不是完整收集整个堆、<ul>
<li>新生代收集（Minor GC&#x2F;Young GC）</li>
<li>老年代收集（Major GC&#x2F;Old GC）：只有 CMS。Major GC有些混淆，应按上下文注意是老年代收集还是整堆收集。</li>
<li>混合收集（Mixed GC）：只有 G1</li>
</ul>
</li>
<li>整堆收集（Full GC）</li>
</ul>
<p>区域划分引起另一个问题，跨代引用。这个问题在前文的 GC Roots 选择时也提到过。<br>根据前两条假说可逻辑推理得出隐含推论：存在相互引用关系的两个对象，是应该倾向于同时生存或者同时消亡的。</p>
<ol start="3">
<li>跨代引用假说（Integenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。</li>
</ol>
<p>依据这条假说，我们不应再为少量的跨代引用而去扫描整个老年代。那么怎么处理跨代引用呢？在后面 HotSpot 的实现细节中我们再提。</p>
<h3 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark Sweep）"></a>标记-清除算法（Mark Sweep）</h3><p>在 1960 年由 Lisp 之父 John McCarthy 提出，分为标记和清除两个阶段。<br>缺点：</p>
<ul>
<li>执行效率不稳定，对象越多，且需要回收的对象越多，效率会降低。</li>
<li>内存空间碎片化，长时间后没有足够的连续内存分配大对象。</li>
</ul>
<img src="/2023/11/07/garbage-collection-in-Java/Pasted%20image%2020231108041337.png" class="" title="“标记-清除”算法示意图">

<h3 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h3><p>为解决标记-清除算法面对大量可回收对象时执行效率低的问题，1969 年 Fenichel 提出“半区复制”（Semispace Copying）。将内存划分为大小相等的两块，每次只使用一块，用完的时候，复制存活的对象到另一块。</p>
<p>优点：</p>
<ul>
<li>存活对象少时，仅需复制少量对象。</li>
<li>不存在内存空间碎片</li>
</ul>
<p>缺点：</p>
<ul>
<li>空间浪费</li>
</ul>
<p>适用场景：</p>
<ul>
<li>新生代。</li>
</ul>
<img src="/2023/11/07/garbage-collection-in-Java/Pasted%20image%2020231108042320.png" class="" title="标记-复制算法示意图">

<p><strong>怎么减少空间的浪费呢？</strong><br>IBM 公司研究表明新生代中 98% 的对象熬不过第一轮收集。在 1989 年，Andrew Appel 针对具备“朝生夕灭”特点的对象，提出了一种更优化的半区复制分代策略，现在称为“Appel 式回收”。具体做法是把新生代分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次分配内存只使用 Eden 和其中一块 Survivor。<br>HotSpot 虚拟机默认 Eden:Suvivor 为 8:1。</p>
<blockquote>
<p>在测试中，尽管 survivor 有空间，仍然只在 Eden 空间进行分配。</p>
</blockquote>
<p>如果 Survivor 空间不足以容纳一次 Minor GC 之后存活的对象时怎么办？<br>罕见情况的“逃生门”——使用其他区域（通常是老年代）进行分配担保（Handle Promotion）。</p>
<h3 id="标记-整理算法（Mark-Compact）"><a href="#标记-整理算法（Mark-Compact）" class="headerlink" title="标记-整理算法（Mark Compact）"></a>标记-整理算法（Mark Compact）</h3><p>标记-复制算法面对对象存活率较高的情况，效率会降低；更关键的是，它需要额外空间进行分配担保。<br>针对老年代对象的存亡特征，1974 年 Edward Lueders 提出了另外一种有针对性的“标记-整理”算法，让所有存活对象都向内存空间一端移动。</p>
<blockquote>
<p>移动和复制的开销有什么差距吗？撇开分配担保问题，大量复制和大量移动是类似的把？</p>
</blockquote>
<img src="/2023/11/07/garbage-collection-in-Java/Pasted%20image%2020231108044446.png" class="" title="标记-整理算法示意图">

<p>移动对象的弊端</p>
<ul>
<li>大量对象存活的话需要大量移动对象，负担重。在以前，对象移动操作必须全程暂停用户应用程序才能进行（STW，Stop The World）。</li>
<li>不整理内存碎片的话，需要依赖更复杂的内存分配器和内存访问器解决。内存访问最频繁，反而影响吞吐量。</li>
</ul>
<p>不移动对象停顿时间会更短，甚至可以不需要停顿，但是从整个程序的吞吐量来看，移动对象会更划算。在这点上的区别分别演变出两种发展方向，低延迟和高吞吐量。</p>
<blockquote>
<p>书中提到的内存分配器和内存访问器解决的是在碎片化的内存空间中进行内存分配，还是可以将大对象分散地存储到碎片化的空间中呢？还提到硬盘存储大文件不要求物理连续的磁盘空间以及内存访问环节的额外负担，应该是指一种分散存储的实现方案吧？</p>
</blockquote>
<blockquote>
<p>对于 CMS 的“和稀泥”解决方案，暂时容忍内存碎片，直到影响对象分配时再采用标记-整理算法收集一次，如果抛开备用的 Serial Old 单线程的效率问题不谈，除非在碎片化的内存空间中分配和访问内存在效率上低于在整理后的内存空间中，要不然“和稀泥”这种懒惰式的处理方案理论上效率更高吧？</p>
</blockquote>
<h2 id="HotSpot-的算法细节实现"><a href="#HotSpot-的算法细节实现" class="headerlink" title="HotSpot 的算法细节实现"></a>HotSpot 的算法细节实现</h2><h3 id="根节点枚举"><a href="#根节点枚举" class="headerlink" title="根节点枚举"></a>根节点枚举</h3><p><strong>对象浩如烟海，怎么实现高效查找根节点的呢？</strong></p>
<p>迄今为止，<strong>所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的</strong>。这是因为根节点枚举如果不在一个一致性快照中进行，准确性无法保证。</p>
<p>Exact VM 类型的虚拟机使用的是准确式垃圾回收，当用户线程停顿后，不需要一个不漏地检查完所有执行上下文和全局的引用位置，就有办法直接得到哪些地方存放着对象引用。HotSpot 的具体解决方案是使用一组称为 OopMap（Ordinary Object Pointer Map） 的数据结构。</p>
<ul>
<li>一旦类加载动作完成，HotSpot 会把对象内什么偏移量上是什么类型的数据计算出来。</li>
<li>在即时编译过程中，也会在特定位置记录下栈和寄存器里什么位置是引用。</li>
</ul>
<blockquote>
<p>看书时，在这个地方其实有很多困惑。对于 OopMap，就像知道了一个不太懂的东西，了解了它能做什么，最明确的是，在即时编译中，会在安全点位置生成 OopMap。</p>
</blockquote>
<h4 id="如何识别数据类型"><a href="#如何识别数据类型" class="headerlink" title="如何识别数据类型"></a>如何识别数据类型</h4><p>首先，我困惑的是，非准确式垃圾回收是什么东西，要找到对象引用得怎么做？<br>书中提到，准确式内存管理是指虚拟机可以知道内存中某个位置的数据具体是什么类型。比如内存中有一个 32 位的整数 123456，虚拟机将有能力分辨出它到底是一个指向了 123456 的内存地址的引用类型还是一个数值为 123456 的整数。<br>Exact VM 抛弃掉以前 Classic VM 基于句柄（Handle）的对象查找方式，因为在垃圾收集后对象可能被移动，如果地址改变（123456-&gt;654321），在没有明确信息表明内存中哪些数值式引用类型的情况下，虚拟机肯定不能把所有123456的值改为654321，所以要使用句柄来保持引用值得稳定。</p>
<blockquote>
<p>看到这个举例之后容易理解多了，可能是没有手动管理内存的经验，对这方面体会不深刻。</p>
</blockquote>
<p>以栈为例，栈帧里装有 int、double 等类型的数值，也有引用类型变量的地址，这些值在保守式 GC 看无法直接分辨是数值还是引用。但保守式 GC 其实还是有一定的分辨能力：</p>
<ol>
<li>是不是正确的对齐值（可以理解为是一个正确的指针的值）</li>
<li>是否指向堆内的地址</li>
<li>是否指向对象的头（从这点上看，虚拟机是会尝试获取对象头校验一下吗？）</li>
</ol>
<p>但是根据这些规则进行检测还是不够的，比如某一个 int 的值刚好指向某个对象的起始地址，就恰好满足上述的所有条件，这样就可能造成该对象被错误识别为存活对象，这个现象称为对堆的压迫。<br>保守式 GC 的“保守”二字体现在它将可疑的根看作是指针进行保守地处理。</p>
<img src="/2023/11/07/garbage-collection-in-Java/Snipaste_2023-11-09_01-02-45.png" class="" title="保守式 GC 视可以根为指针">

<blockquote>
<p>死亡的对象被错误保留下来，挤占了堆空间，称其为“压迫”还听形象的。这个“保守”在理解以后才不感觉违和。</p>
</blockquote>
<h4 id="OopMap-的类型"><a href="#OopMap-的类型" class="headerlink" title="OopMap 的类型"></a>OopMap 的类型</h4><ul>
<li>类型信息里记录了自己的 OopMap，这应该对应的是“一旦类加载动作完成，HotSpot 会把对象内什么偏移量上是什么类型的数据计算出来”，从对象向它引用的对象查找时使用。</li>
<li>被 JIT 编译后的指令流，也会在特定的位置（安全点）记录下 OopMap。</li>
<li>奇怪的是，暂时没有找到明确指出在 Java 字节码的特定位置（安全点）也记录着 OopMap。</li>
</ul>
<blockquote>
<p>方法区的类静态属性和类常量也是根据类型信息里的 OopMap 查找的吗？</p>
</blockquote>
<h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p><strong>为什么引入安全点，它解决了什么问题？</strong></p>
<p>在 OopMap 的协助下，HotSpot 可以快速准确地完成 GC Roots。但是非常多的指令可能导致 OopMap 的内容发生变化。</p>
<blockquote>
<p>书中“可能导致引用关系变化……的指令非常多”这句话让人困惑，OopMap 不是为了定位哪里是引用而非引用指向哪吧？如果只看“导致 OopMap 内容变化的指令非常多”更易理解。</p>
</blockquote>
<p><strong>在哪里生成 OopMap 呢？</strong><br>既然指令会导致 OopMap 内容发生变化，最简单粗暴的就是为每一条指令生成 OopMap，但是这样会空间成本会急剧上升。<br>HotSpot 只在特定的位置生成 OopMap，这些位置被称为“安全点”（Safepoint）。<br>安全点的设定决定了并非在代码指令流的任意位置都能够停顿下来开始垃圾收集，而是要求必须到达安全点才能够暂停。</p>
<p><strong>安全点怎么选择呢？</strong></p>
<ul>
<li>不能太少以至于让收集器等太久</li>
<li>不能太频繁以至于过分增大运行时的内存负担</li>
</ul>
<p>安全点的位置的选取基本上是以“是否具有让程序长时间执行的特征”为标准进行选定的：</p>
<ul>
<li>所有的非计数循环的末尾</li>
<li>方法返回之前&#x2F;调用方法的 call 指令后</li>
<li>每条 Java 编译后的字节码的边界（不理解）</li>
<li>可能抛异常的地方</li>
</ul>
<blockquote>
<p>有没有权威的标准描述啊。</p>
</blockquote>
<p><strong>如何在垃圾收集发生时，让所有线程（不包括 JNI 调用的线程）都跑到最近的安全点，然后停顿下来呢？</strong></p>
<ul>
<li>抢先式中断（Preemptive Suspension），系统先中断全部用户线程，如果有用户线程中断的地方不是安全点，就恢复该线程执行，再中断，直到跑到安全点。（没人选）</li>
<li>主动式中断（Voluntary Suspenstion），设置一个标志位，线程执行时不停主动轮询，发现中断标志为真就在最近的安全点主动挂起。</li>
</ul>
<blockquote>
<p>这个问题和如何通知多线程一起做一件事很像，设置标志位，再让线程运行过程中轮询。</p>
</blockquote>
<p><strong>什么时候进行轮询？</strong><br>轮询标志的地方与安全点是重合的，另外还要加上创建对象和其他需要在堆上分配内存的地方，这样可以检查是否即将发生垃圾收集，避免没有足够内存分配给新对象。</p>
<blockquote>
<p>仔细一想，与安全点重合似乎是理所当然，额外选取的地方也有恰当的理由。</p>
</blockquote>
<p><strong>轮询在印象里都意味着额外开销，虚拟机如何应对？</strong><br>HotSpot 使用内存保护陷阱的方式，把轮询操作精简至只有一条汇编指令的程度。</p>
<blockquote>
<p>很遗憾，看懂又不懂，总之，轮询操作优化得很高效。</p>
</blockquote>
<h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p><strong>为什么引入安全区域，它解决了什么问题？</strong></p>
<p>安全点机制保证了程序执行时，在不太长的时间内，就会遇到可进入垃圾收集过程的安全点，但是如果程序“不执行”的时候，比如线程处于 Sleep 或者 Blocked 时，就无法通过轮询获知中断标识。对于这种情况，引入了安全区域（Safe Region）来解决。</p>
<p>安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化。安全区域可以看作是扩展拉伸了的安全点。</p>
<ol>
<li>当用户线程执行到安全区域里的代码，首先会标识自己进入了安全区域</li>
<li>虚拟机发起垃圾回收时，不去管这些写线程</li>
<li>当线程要离开安全区域，会检查虚拟机是否已完成根节点枚举（或者其他需要暂定用户线程的阶段），<strong>看起来是否处于用户线程暂停是可以检测的</strong>。</li>
<li>如果已完成，继续；如果未完成，<strong>等待至收到可以离开安全区域的信号</strong></li>
</ol>
<blockquote>
<p>不去管处于安全区域的线程的意思是什么，不是线程主动轮询是否中断的标志吗？这个标志不是全局共享的吗，是虚拟机为各个线程单独设置的？</p>
</blockquote>
<h3 id="记忆集和卡表"><a href="#记忆集和卡表" class="headerlink" title="记忆集和卡表"></a>记忆集和卡表</h3><p><strong>为什么引入记忆集，它解决了什么问题？</strong></p>
<p>为了解决对象跨代引用所带来的问题，比如在标记新生代时，避免将整个老年代的对象都加入 GC Roots 进行扫描。</p>
<blockquote>
<p>这个问题起初让我很迷惑，直到我认识到“老年代里有一些已经不可达但还没回收的对象，它们可能引用了新生代里的对象”这个现象，我在想我可能理解了跨代问题。但是此时，我又迟疑了，如果引用新生代对象的老年代对象已经不可达，回收掉就好了，如果老年代对象可达，那么从固定的 GC Roots 一定可以找到老年代对象，再找到新生代对象。</p>
</blockquote>
<p>记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。<br>如果不考虑效率和成本，最简单的方法可以用非收集区域中所有含跨代引用的对象数组来实现。</p>
<p>设计者通常选择更为粗犷的记录粒度来节省记忆集的存储和维护成本，比如：</p>
<ul>
<li>字长精度：每个记录精确到一个机器字长，该字包含跨代指针。</li>
<li>对象精度：每个记录精确到一个对象，该对象里包含跨代指针。</li>
<li>卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。</li>
</ul>
<p>卡表（Card Table）是记忆集的一种具体实现。<br>卡表最简单的形式可以只是一个字节数组，HotSpot 虚拟机也是这样做的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CARD_TABLE[<span class="built_in">this</span> address &gt;&gt; <span class="number">9</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<img src="/2023/11/07/garbage-collection-in-Java/Pasted%20image%2020231108160535.png" class="" title="卡表与卡页对应示意图">

<p>一个卡页的内存中通常包含不止一个对象，只要卡页内有一个或更多对象的字段存在跨代引用指针，就将卡表的数组元素的值标识为 1，成该元素变脏（Dirty）。</p>
<blockquote>
<p>这是否以为着卡表长度为 (老年代容量 &#x2F; 512)，这内存占用还是不低欸。</p>
</blockquote>
<blockquote>
<p>区域内怎么判断出对象的开始和结束位置呢？虚拟机可以通过一个地址，知道该地址是一个对象的起始地址吗？</p>
</blockquote>
<h3 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h3><p><strong>卡表元素如何维护？它们何时变脏，谁来把它们变脏？</strong></p>
<p>卡表元素何时变脏的答案是明确的——有其他分代区域中对象引用本区域对象时，其对应的卡表元素就应该变脏。</p>
<p><strong>问题是如何在对象赋值的那一刻去更新维护卡表呢？</strong><br>在解释执行字节码的情况中，虚拟机有充分的介入空间；但是在编译执行的场景中，即时编译后的代码已经是纯粹的机器指令流了。<br>HotSpot 虚拟机是通过写屏障（Write Barrier）技术维护卡表状态，在机器码层面介入每一个赋值操作。</p>
<blockquote>
<p>又是一个看懂又不懂的事情，很多资料里尝试用伪代码表达，但是我很想知道它是怎么实现在机器码层面介入每一个赋值操作，是在 JVM 源码中用 C++ 实现的吗？是在解释器和 JIT 编译器共同支持下，在机器码层面加入了代码片段吗？<br>总之，理解为引用字段赋值的 AOP 切面吧。</p>
</blockquote>
<ul>
<li>写前屏障（Pre-Write Barrier），直到 G1 收集器才使用到。</li>
<li>写后屏障（Post-Write Barrier）。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">oop_field_store</span><span class="params">(oop* field, oop new_value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 引用字段赋值操作</span></span><br><span class="line">    *field = new_value;</span><br><span class="line">    <span class="comment">// 写后屏障，在这里完成卡表状态更新</span></span><br><span class="line">    <span class="built_in">post_write_barrier</span>(field, new_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这应该只是为了表达思路的伪代码吧？</p>
</blockquote>
<p>应用写屏障后，每次只要对引用更新，都会产生额外的开销，但是和 Minor GC 时扫描整个老年代的代价相比还是低很多的。</p>
<p><strong>除了写屏障的开销外，卡表在高并发场景下还面临着“伪共享”（False Sharing）问题。</strong></p>
<p>现代中央处理器的缓存系统中是以缓存行（Cache Line）为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影响而导致性能降低。<br>假设 64 个卡表元素共享一个缓存行，对应的卡页总内存为 32 KB，如果不同线程更新的对象都在这 32 KB 的内存区域内，就会导致更新卡表时发生伪共享问题。<br>一种简单的解决方案是不采用无条件的写屏障，而是先检查卡表标记，只有未被标记才标记为变脏。</p>
<p>在 JDK 7 后，新增 -XX:+UseCondCardMark 参数决定是否开启卡表更新的条件判断。开启后增加一次额外的判断开销，但能够避免伪共享问题。</p>
<h3 id="并发的可达性分析"><a href="#并发的可达性分析" class="headerlink" title="并发的可达性分析"></a>并发的可达性分析</h3><p>从 GC Roots 再继续向下遍历对象图，停顿时间必然与堆容量成正比。如果能够削减这部分的停顿时间，对于所有使用追踪式垃圾收集算法的收集器而言，“标记”阶段都能收益匪浅。</p>
<p><strong>为什么必须在一个能保障一致性的快照上才能进行对象图的遍历？</strong><br>三色标记（Tri-color Marking），扫描过程就想灰色波峰从黑向白推进。<br>白色：表示对象尚未被垃圾收集器访问到。<br>黑色：表示对象已经被垃圾收集器访问到，且这个对象的所有引用都已经扫描过了。<br>灰色：表示对象已经被垃圾收集器访问到，但这个对象上至少有一个引用还没有被扫描过。</p>
<p>如果用户线程是冻结的，那么不会有问题。如果用户线程在收集过程中修改了引用关系，就会出现两种后果：</p>
<ul>
<li>把原本消亡的对象，错误标记为存活。（尚可以容忍，只是产生了浮动垃圾，下次收集即可）</li>
<li>把原本存活的对象，错误标记为死亡。这是不允许发生的。</li>
</ul>
<p>Wilson 于 1994 年在理论上证明，当且仅当以下两个条件同时满足，会产生“对象消失”的问题：</p>
<ul>
<li>赋值器插入了一条或多条从黑色对象到白色对象的新引用。</li>
<li>赋值器删除了全部从灰色到<strong>该</strong>白色对象的直接<strong>或间接</strong>引用。</li>
</ul>
<blockquote>
<p>第二个条件的描述需要很精确，不能忽略关键字眼。</p>
</blockquote>
<p>要解决并发扫描时的对象消亡问题，只需要破坏这两个条件的任意一个即可。由此分别产生了两种解决方案：</p>
<ul>
<li>增量更新（Incremental Update），当黑色对象插入新的指向白色对象的引用时，记录，在并发扫描结束后，以这些黑色对象为根，重新扫描。</li>
<li>原始快照（Snapshot At The Beginning，SATB），当灰色对象要删除指向白色对象的引用关系时，记录，在并发扫描结束后，以这些灰色对象为根，重新扫描。</li>
</ul>
<blockquote>
<p>和破坏死锁的思路类似。</p>
</blockquote>
<blockquote>
<p>不太理解“以这些灰色对象为根，重新扫描”，反而是“按照扫描的那一刻的对象图进行扫描”更容易理解。<br>应该是以这些灰色对象为根，根据记录的被删除引用，继续扫描。把继续扫描到的对象，统统视为存活对象。<br>理解起来有点绕，因为第一次扫描是沿着引用链进行，删除引用后，确实没办法继续往下。但是引用关系的变化通过写屏障记录了下来。第二次扫描需要 STW。<br>如果没有理解错的话，这时候会产生一种错误将白标记为黑的浮动垃圾；第一种方案不会出现该情况；但两种方案都不能避免已标记为黑的对象在并发时成为浮动垃圾。</p>
</blockquote>
<blockquote>
<p>理解了这部分，再看垃圾收集器的过程示意图中的停顿和并发，不再枯燥反觉有趣了。</p>
</blockquote>
<blockquote>
<p>其实我不太理解</p>
</blockquote>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li>《深入理解Java虚拟机》</li>
<li><a href="https://blog.csdn.net/u014028317/article/details/107435049">JVM中的OopMap</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/441867302">图解 OopMap、Safe Point、Safe Region</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/377672271">详解GC（一）理论篇</a></li>
</ol>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 Java 字节码指令的一些例子分析</title>
    <url>/2023/11/09/some-examples-of-Java-bytecode-instruction-analysis/</url>
    <content><![CDATA[<h2 id="演示字节码指令的执行"><a href="#演示字节码指令的执行" class="headerlink" title="演示字节码指令的执行"></a>演示字节码指令的执行</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteCodeTest_2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Short.MAX_VALUE + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="操作数栈和本地变量表的大小"><a href="#操作数栈和本地变量表的大小" class="headerlink" title="操作数栈和本地变量表的大小"></a>操作数栈和本地变量表的大小</h3><p>在编译期间就可计算得到操作数栈和本地变量表的大小。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">stack=2, locals=4, args_size=1</span><br></pre></td></tr></table></figure>

<h3 id="本地变量表"><a href="#本地变量表" class="headerlink" title="本地变量表"></a>本地变量表</h3><p>Slot，即槽位，可理解为索引。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Start  Length  Slot  Name   Signature</span><br><span class="line">    0      18     0  args   [Ljava/lang/String;</span><br><span class="line">    3      15     1     a   I</span><br><span class="line">    6      12     2     b   I</span><br><span class="line">   10       8     3     c   I</span><br></pre></td></tr></table></figure>

<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3 = Integer            32768</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4 = Fieldref           <span class="comment">#27.#28        // java/lang/System.out:Ljava/io/PrintStream;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">5 = Methodref          <span class="comment">#29.#30        // java/io/PrintStream.println:(I)V</span></span> </span><br></pre></td></tr></table></figure>

<img src="/2023/11/09/some-examples-of-Java-bytecode-instruction-analysis/Snipaste_2023-11-10_00-28-14.png" class="" title="字节码指令执行栈帧示意图">

<h3 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h3><figure class="highlight console"><table><tr><td class="code"><pre><span class="line"> 0: bipush        10</span><br><span class="line"> 2: istore_1</span><br><span class="line"> 3: ldc           #3             // int 32768</span><br><span class="line"> 5: istore_2</span><br><span class="line"> 6: iload_1</span><br><span class="line"> 7: iload_2</span><br><span class="line"> 8: iadd</span><br><span class="line"> 9: istore_3</span><br><span class="line">10: getstatic     #4             // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">13: iload_3</span><br><span class="line">14: invokevirtual #5             // Method java/io/PrintStream.println:(I)V</span><br><span class="line">17: return</span><br></pre></td></tr></table></figure>
<ul>
<li>bipush，将一个 byte，推入操作数栈。<ul>
<li>short 范围内的数是和字节码指令一起存储的，范围外的数是存储在运行时常量池中的。</li>
<li>操作数栈的宽度是 4 个字节，short 范围内的数在推入操作数栈前会经过符号扩展成为 int。</li>
</ul>
</li>
<li>istore_1，将栈顶的 int，存入局部变量表，槽位 1。</li>
<li>ldc，从运行时常量池中将指定常量推入操作数栈。</li>
<li>istore_2，将栈顶的 int，存入局部变量表，槽位 2。</li>
<li>iload_1 iload_2，依次从局部变量表将两个 int 推入操作数栈，槽位分别是 1 和 2。</li>
<li>iadd，将栈顶的两个 int 弹出并相加，将结果推入操作数栈。</li>
<li>istore_3，将栈顶的 int，存入局部变量表，槽位 3。</li>
<li>getstatic，获取类的静态属性，推入操作数栈。</li>
<li>iload_3，从局部变量表将 int 推入操作数栈，槽位 3。</li>
<li>invokevirtual，将栈顶的参数依次弹出，调用实例方法。</li>
<li>return，返回 void</li>
</ul>
<h2 id="分析-a-和-a"><a href="#分析-a-和-a" class="headerlink" title="分析 a++ 和 ++a"></a>分析 a++ 和 ++a</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteCodeTest_3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a++ + ++a + a--;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字节码指令-1"><a href="#字节码指令-1" class="headerlink" title="字节码指令"></a>字节码指令</h3><figure class="highlight console"><table><tr><td class="code"><pre><span class="line"> 0: bipush        10</span><br><span class="line"> 2: istore_1</span><br><span class="line"> 3: iload_1</span><br><span class="line"> 4: iinc          1, 1</span><br><span class="line"> 7: iinc          1, 1</span><br><span class="line">10: iload_1</span><br><span class="line">11: iadd</span><br><span class="line">12: iload_1</span><br><span class="line">13: iinc          1, -1</span><br><span class="line">16: iadd</span><br><span class="line">17: istore_2</span><br></pre></td></tr></table></figure>

<ul>
<li>a++ 和 ++a 的区别是先 load 还是先 iinc。</li>
<li>iinc，将局部变量表指定槽位的数加上一个常数。</li>
<li>注意 a 只 load 到操作数栈并没有 store 回局部变量表。</li>
<li>b &#x3D; 10 + 12 + 12 &#x3D; 34</li>
<li>a &#x3D; 10 + 1 + 1 - 1 &#x3D; 11</li>
</ul>
<h2 id="分析判断条件"><a href="#分析判断条件" class="headerlink" title="分析判断条件"></a>分析判断条件</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteCodeTest_4</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// ifeq, goto</span></span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">            a = <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            a = <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字节码指令-2"><a href="#字节码指令-2" class="headerlink" title="字节码指令"></a>字节码指令</h3><figure class="highlight console"><table><tr><td class="code"><pre><span class="line"> 0: iconst_0</span><br><span class="line"> 1: istore_1</span><br><span class="line"> 2: iload_1</span><br><span class="line"> 3: ifne          12</span><br><span class="line"> 6: bipush        10</span><br><span class="line"> 8: istore_1</span><br><span class="line"> 9: goto          15</span><br><span class="line">12: bipush        20</span><br><span class="line">14: istore_1</span><br><span class="line">15: return</span><br></pre></td></tr></table></figure>

<ul>
<li>iconst，将一个 int 常量推入操作数栈。</li>
<li>if<code>&lt;cond&gt;</code>，一个 int 和 0 的比较成立时进入分支，跳转到指定行号。</li>
<li>goto，总是进入的分支，跳转到指定行号。</li>
</ul>
<h2 id="涉及的字节码指令"><a href="#涉及的字节码指令" class="headerlink" title="涉及的字节码指令"></a>涉及的字节码指令</h2><ul>
<li>bipush，将一个 byte 符号扩展为一个 int，推入操作数栈。</li>
<li>istore，将栈顶的 int，存入局部变量表的指定槽位。</li>
<li>iload，将局部变量表指定槽位的 int，推入操作数栈。</li>
<li>ldc，从运行时常量池将指定常量推入操作数栈。</li>
<li>iadd，将栈顶的两个 int 弹出并相加，将结果推入操作数栈。</li>
<li>getstatic，获取类的静态属性，推入操作数栈。</li>
<li>invokevirtual，将栈顶的参数依次弹出，调用实例方法。</li>
<li>return，返回 void。</li>
<li>iinc，将局部变量表中指定槽位的数加一个常量。</li>
<li>if<code>&lt;cond&gt;</code>，一个 int 和 0 的比较成立时进入分支，跳转到指定行号。<ul>
<li>ifeq，equals</li>
<li>ifne，not equals</li>
<li>iflt，less than</li>
<li>ifge，greater than or equals</li>
<li>ifgt，great than</li>
<li>ifle，less than or equals</li>
</ul>
</li>
<li>goto，总是进入的分支，跳转到指定行号。</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>bytecode</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 Redis 的分布式锁的简单实现</title>
    <url>/2023/11/13/simple-implementation-of-distributed-lock-based-on-Redis/</url>
    <content><![CDATA[<p>在分布式应用中，并发访问资源需要谨慎考虑。比如读取和修改保存并不是一个原子操作，在并发时，就可能发生修改的结果被覆盖的问题。</p>
<img src="/2023/11/13/simple-implementation-of-distributed-lock-based-on-Redis/Pasted%20image%2020231110180458.png" class="" title="分布式应用中的并发问题">

<p>很多人都了解在必要的时候需要使用分布式锁来限制程序的并发执行，但是在具体的细节上，往往并不正确。</p>
<h2 id="基于-Redis-的分布式锁简单实现"><a href="#基于-Redis-的分布式锁简单实现" class="headerlink" title="基于 Redis 的分布式锁简单实现"></a>基于 Redis 的分布式锁简单实现</h2><p>本质上要实现的目标就是在 Redis 中占坑，告诉后来者资源已经被锁定，放弃或者稍后重试。Redis 原生支持 set if not exists 的语义。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">setnx lock:user1 <span class="literal">true</span></span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">... do something</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">del lock:user1</span></span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<h3 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h3><h4 id="问题一：异常引发死锁-1"><a href="#问题一：异常引发死锁-1" class="headerlink" title="问题一：异常引发死锁 1"></a>问题一：异常引发死锁 1</h4><p>如果在处理过程中，程序出现异常，将导致 del 指令没有执行成功。锁无法释放，其他线程将无法再获取锁。</p>
<img src="/2023/11/13/simple-implementation-of-distributed-lock-based-on-Redis/Pasted%20image%2020231110182254.png" class="" title="异常引发死锁 1">

<h4 id="改进一：设置超时时间"><a href="#改进一：设置超时时间" class="headerlink" title="改进一：设置超时时间"></a>改进一：设置超时时间</h4><p>对 key 设置过期时间，如果在处理过程中，程序出现异常，导致 del 指令没有执行成功，设置的过期时间一到，key 将自动被删除，锁也就等于被释放了。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">setnx lock:user1 <span class="literal">true</span></span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">expire lock:user1 5</span></span><br><span class="line"></span><br><span class="line">... do something</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">del lock:user1</span></span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<h4 id="问题二：异常引发死锁-2"><a href="#问题二：异常引发死锁-2" class="headerlink" title="问题二：异常引发死锁 2"></a>问题二：异常引发死锁 2</h4><p>事实上，上述措施并没有彻底解决问题。如果在设置 key 的超时时间之前，程序出现异常，一切仍旧会发生。</p>
<img src="/2023/11/13/simple-implementation-of-distributed-lock-based-on-Redis/Pasted%20image%2020231110190407.png" class="" title="异常引发死锁 2">

<p>本质原因是 setnx 和 expire 两个指令不是一个原子操作。那么是否可以使用 Redis 的事务解决呢？不行。因为 expire 依赖于 setnx 的执行结果，如果 setnx 没有成功，expire 就不应该执行。</p>
<h4 id="改进二：setnx-expire-的原子指令"><a href="#改进二：setnx-expire-的原子指令" class="headerlink" title="改进二：setnx + expire 的原子指令"></a>改进二：setnx + expire 的原子指令</h4><p>如果 setnx 和 expire 可以用一个原子指令实现就好了。</p>
<img src="/2023/11/13/simple-implementation-of-distributed-lock-based-on-Redis/Pasted%20image%2020231110190442.png" class="" title="setnx + expire 原子指令">

<h5 id="基于原生指令的实现"><a href="#基于原生指令的实现" class="headerlink" title="基于原生指令的实现"></a>基于原生指令的实现</h5><p>在 Redis 2.8 版本中，Redis 的作者加入 set 指令扩展参数，允许 setnx 和 expire 组合成一个原子指令。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">set</span> lock:user1 <span class="literal">true</span> ex 5 nx</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">... do something</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">del lock:user1</span></span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<h5 id="基于-Lua-脚本的实现"><a href="#基于-Lua-脚本的实现" class="headerlink" title="基于 Lua 脚本的实现"></a>基于 Lua 脚本的实现</h5><p>除了使用原生的指令外，还可以使用 Lua 脚本，将多个 Redis 指令组合成一个原子指令。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;setnx&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]) == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">  redis.call(<span class="string">&#x27;expire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>])</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="超时问题"><a href="#超时问题" class="headerlink" title="超时问题"></a>超时问题</h3><p>基于 Redis 的分布式锁还会面临超时问题。如果在加锁和释放之间的处理逻辑过于耗时，以至于超出了 key 的过期时间，锁将在处理结束前被释放，就可能发生问题。</p>
<img src="/2023/11/13/simple-implementation-of-distributed-lock-based-on-Redis/Pasted%20image%2020231110191738.png" class="" title="其他线程提前进入临界区">

<h4 id="问题一：其他线程提前进入临界区"><a href="#问题一：其他线程提前进入临界区" class="headerlink" title="问题一：其他线程提前进入临界区"></a>问题一：其他线程提前进入临界区</h4><p>如果第一个线程因为处理逻辑过于耗时导致在处理结束前锁已经被释放，其他线程将可以提前获得锁，临界区的代码将不能保证严格串行执行。</p>
<h4 id="问题二：错误释放其他线程的锁"><a href="#问题二：错误释放其他线程的锁" class="headerlink" title="问题二：错误释放其他线程的锁"></a>问题二：错误释放其他线程的锁</h4><p>如果在第二个线程获得锁后，第一个线程刚好处理逻辑结束去释放锁，将导致第二个线程的锁提前被释放，引发连锁问题。</p>
<h4 id="改进一：不要用于较长时间的任务"><a href="#改进一：不要用于较长时间的任务" class="headerlink" title="改进一：不要用于较长时间的任务"></a>改进一：不要用于较长时间的任务</h4><p>与其说是改进，不如说是注意事项。如果真的出现问题，造成的数据错误可能需要人工介入解决。</p>
<p>如果真的存在这样的业务场景，应考虑使用其他解决方案加以优化。</p>
<h4 id="改进二：使用-watchdog-实现锁续期"><a href="#改进二：使用-watchdog-实现锁续期" class="headerlink" title="改进二：使用 watchdog 实现锁续期"></a>改进二：使用 watchdog 实现锁续期</h4><p>为 Redis 的 key 设置过期时间，其实是为了解决死锁问题而做出的兜底措施。可以为获得的锁设置定时任务定期地为锁续期，以避免锁被提前释放。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">scheduleRenewal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> lockValue.get();</span><br><span class="line">    ScheduledFuture&lt;?&gt; scheduledFuture = sScheduler.scheduleAtFixedRate(</span><br><span class="line">        () -&gt; <span class="built_in">this</span>.renewal(value), RENEWAL_INTERVAL, RENEWAL_INTERVAL, TimeUnit.MILLISECONDS</span><br><span class="line">    );</span><br><span class="line">    renewalTask.set(scheduledFuture);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这个方式仍然不能避免解锁失败时的其他线程的等待时间。</p>
<h4 id="改进三：加锁时指定-tag"><a href="#改进三：加锁时指定-tag" class="headerlink" title="改进三：加锁时指定 tag"></a>改进三：加锁时指定 tag</h4><p>可以将 set 指令的 value 参数设置为一个随机数，释放锁时先匹配持有的 tag 是否和 value 一致，如果一致再删除 key，以此避免锁被其他线程错误释放。</p>
<h5 id="基于原生指令的实现-1"><a href="#基于原生指令的实现-1" class="headerlink" title="基于原生指令的实现"></a>基于原生指令的实现</h5><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">tag = random.nextint()</span><br><span class="line">if redis.set(key, tag, nx= True, ex=5):</span><br><span class="line">	do_something()</span><br><span class="line">	redis.delifequals(key, tag)</span><br></pre></td></tr></table></figure>

<p>但是注意，Redis 并没有提供语义为 delete if equals 的原子指令，这样的话问题并不能被彻底解决。如果在第一个线程判断 tag 是否和 value 相等之后，第二个线程刚好获得了锁，然后第一个线程因为匹配成功执行删除 key 操作，仍然将导致第二个线程获得的锁被第一个线程错误释放。</p>
<img src="/2023/11/13/simple-implementation-of-distributed-lock-based-on-Redis/Pasted%20image%2020231110193919.png" class="" title="错误释放其他线程的锁">

<h5 id="基于-Lua-脚本的实现-1"><a href="#基于-Lua-脚本的实现-1" class="headerlink" title="基于 Lua 脚本的实现"></a>基于 Lua 脚本的实现</h5><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h3><p>可重入性是指线程在已经持有锁的情况下再次请求加锁，如果一个锁支持同一个线程多次加锁，那么就称这个锁是可重入的，类似 Java 的 ReentrantLock。</p>
<h4 id="使用-ThreadLocal-实现锁计数"><a href="#使用-ThreadLocal-实现锁计数" class="headerlink" title="使用 ThreadLocal 实现锁计数"></a>使用 ThreadLocal 实现锁计数</h4><p>Redis 分布式锁如果要支持可重入，可以使用线程的 ThreadLocal 变量存储当前持有的锁计数。但是在多次获得锁后，过期时间并没有得到延长，后续获得锁后持有锁的时间其实比设置的时间更短。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ThreadLocal&lt;Integer&gt; lockCount = ThreadLocal.withInitial(() -&gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> lockCount.get();  </span><br><span class="line">    <span class="keyword">if</span> (count != <span class="literal">null</span> &amp;&amp; count &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">        lockCount.set(count + <span class="number">1</span>);   </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;    </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> commands.set(lockKey, lockValue.get(), SetArgs.Builder.nx().px(RedisLockManager.LOCK_EXPIRE));  </span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;OK&quot;</span>.equals(result)) &#123;  </span><br><span class="line">        lockCount.set(<span class="number">1</span>);  </span><br><span class="line">        scheduleRenewal();  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;    </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用-Redis-hash-实现锁计数"><a href="#使用-Redis-hash-实现锁计数" class="headerlink" title="使用 Redis hash 实现锁计数"></a>使用 Redis hash 实现锁计数</h4><p>还可以使用 Redis 的 hash 数据结构实现锁计数，支持重新获取锁后重置过期时间。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;exists&#x27;</span>, KEYS[<span class="number">1</span>]) == <span class="number">0</span>) <span class="keyword">then</span> </span><br><span class="line">	redis.call(<span class="string">&#x27;hset&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>], <span class="number">1</span>);</span><br><span class="line">	redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;hexists&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>]) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">	redis.call(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>], <span class="number">1</span>);</span><br><span class="line">	redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">return</span> redis.call(<span class="string">&#x27;pttl&#x27;</span>, KEYS[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<p>书的作者<strong>不推荐使用可重入锁</strong>，他提出可重入锁会加重客户端的复杂度，如果在编写代码时注意在逻辑结构上进行调整，完全可以避免使用可重入锁。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><a href="https://github.com/moralok/redis-lock">redis-lock</a></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li>《Redis 深度历险，核心原理与应用实践》</li>
</ul>
]]></content>
      <tags>
        <tag>lock</tag>
        <tag>distributed lock</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Grafana 和 Prometheus 搭建监控</title>
    <url>/2023/11/18/setup-monitoring-using-grafana-and-prometheus/</url>
    <content><![CDATA[<p>本文介绍如何通过 <code>Dockers Compose</code> 安装 <code>Grafana</code> 和 <code>Prometheus</code> 在局域网中配合各类 <code>exporter</code> 为主机和诸多内部服务搭建监控。</p>
<span id="more"></span>

<h3 id="Grafana"><a href="#Grafana" class="headerlink" title="Grafana"></a>Grafana</h3><h4 id="docker-compose-部署"><a href="#docker-compose-部署" class="headerlink" title="docker-compose 部署"></a>docker-compose 部署</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;1.0&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">grafana:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">grafana/grafana:9.5.6</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">grafana</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3000</span><span class="string">:3000</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">grafana-storage:/var/lib/grafana</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my-network</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">grafana-storage:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">my-network:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h4><p><strong>在通过 <code>nginx</code> 代理 <code>Grafana</code> 后，出现 <code>&quot;Origin not allowed&quot;</code> 报错信息</strong>。</p>
<div style="width:80%;margin:auto"><img src="/2023/11/18/setup-monitoring-using-grafana-and-prometheus/Snipaste_2023-12-15_17-15-46.png" class="" title="Origin not allowed 报错信息"></div>

<p>问题的原因参考官方社区：<a href="https://community.grafana.com/t/after-update-to-8-3-5-origin-not-allowed-behind-proxy/60598">After update to 8.3.5: ‘Origin not allowed’ behind proxy</a></p>
<p>在 <code>nginx</code> 配置文件的 <code>proxy</code> 配置上方添加 <code>proxy_set_header Host $http_host</code>，然后重启 <code>nginx</code> 恢复正常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    proxy_set_header Host $http_host;</span><br><span class="line">    proxy_pass http://grafana:3000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h3><h4 id="docker-compose-部署-1"><a href="#docker-compose-部署-1" class="headerlink" title="docker-compose 部署"></a>docker-compose 部署</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;1.0&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">prometheus:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">bitnami/prometheus:2.45.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">prometheus</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">19090</span><span class="string">:9090</span></span><br><span class="line">    <span class="attr">volumes:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">prometheus-data:/opt/bitnami/prometheus/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$PWD/conf/prometheus.yml:/opt/bitnami/prometheus/conf/prometheus.yml</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my-network</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">prometheus-data:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">my-network:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="配置文件-prometheus-yml"><a href="#配置文件-prometheus-yml" class="headerlink" title="配置文件 prometheus.yml"></a>配置文件 prometheus.yml</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="attr">scrape_interval:</span> <span class="string">15s</span></span><br><span class="line"></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line"><span class="comment"># Ubuntu</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">node</span></span><br><span class="line">  <span class="attr">static_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;192.168.46.135:9100&#x27;</span>]</span><br><span class="line"><span class="comment"># Windows</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">windows</span></span><br><span class="line">  <span class="attr">static_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;192.168.46.1:9182&#x27;</span>]</span><br><span class="line"><span class="comment"># Redis</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">redis-exporter</span></span><br><span class="line">  <span class="attr">static_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;redis-exporter:9121&#x27;</span>]</span><br><span class="line"><span class="comment"># MySQL</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">mysqld-exporter</span></span><br><span class="line">  <span class="attr">static_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;mysqld-exporter:9104&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Ubuntu-监控"><a href="#Ubuntu-监控" class="headerlink" title="Ubuntu 监控"></a>Ubuntu 监控</h3><h4 id="node-exporter"><a href="#node-exporter" class="headerlink" title="node_exporter"></a>node_exporter</h4><p><code>node_exporter</code> 被设计为监控主机系统，因为它需要访问主机系统，所以不推荐使用 <code>Docker</code> 容器部署。</p>
<ul>
<li><a href="https://github.com/prometheus/node_exporter">node_exporter Github 仓库</a></li>
<li><a href="https://prometheus.io/download/#node_exporter">node_exporter 下载地址</a></li>
<li><a href="https://prometheus.io/docs/guides/node-exporter/">node_exporter 使用指南</a></li>
</ul>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li>下载解压得到 <code>node_exporter</code> 二进制可执行文件。</li>
<li>修改权限，<code>chmod u+x node_exporter</code></li>
<li><code>./node_exporter</code> 启动</li>
<li><code>Prometheus</code> 配置文件<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="attr">scrape_interval:</span> <span class="string">15s</span></span><br><span class="line"></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">node</span></span><br><span class="line">  <span class="attr">static_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;localhost:9100&#x27;</span>]</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="设置-node-exporter-自启动"><a href="#设置-node-exporter-自启动" class="headerlink" title="设置 node_exporter 自启动"></a>设置 node_exporter 自启动</h4><ol>
<li>路径 <code>/etc/systemd/system</code></li>
<li>创建 <code>node_exporter.service</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=node_exporter</span><br><span class="line">After=network-online.target</span><br><span class="line"> </span><br><span class="line">[Service]</span><br><span class="line">Restart=on-failure</span><br><span class="line">ExecStart=/opt/node_exporter</span><br><span class="line"> </span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></li>
</ol>
<div style="width:80%;margin:auto"><img src="/2023/11/18/setup-monitoring-using-grafana-and-prometheus/Snipaste_2023-11-19_01-11-22.png" class="" title="Ubuntu 监控"></div>

<h3 id="Windows-监控"><a href="#Windows-监控" class="headerlink" title="Windows 监控"></a>Windows 监控</h3><h4 id="windows-exporter"><a href="#windows-exporter" class="headerlink" title="windows_exporter"></a>windows_exporter</h4><ul>
<li><a href="https://github.com/prometheus-community/windows_exporter">windows_exporter Github 仓库</a></li>
<li><a href="https://github.com/prometheus-community/windows_exporter/releases">windows_exporter 下载地址</a></li>
<li><a href="https://prometheus.io/docs/guides/node-exporter/">windows_exporter 使用指南</a></li>
</ul>
<h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li>下载得到 <code>windows_exporter-0.24.0-amd64.msi</code> 安装程序。</li>
<li>以默认方式安装</li>
<li><code>Prometheus</code> 配置文件<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="attr">scrape_interval:</span> <span class="string">15s</span></span><br><span class="line"></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">windows</span></span><br><span class="line"><span class="comment"># Windows</span></span><br><span class="line">  <span class="attr">static_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;192.168.46.1:9182&#x27;</span>]</span><br></pre></td></tr></table></figure></li>
</ol>
<div style="width:80%;margin:auto"><img src="/2023/11/18/setup-monitoring-using-grafana-and-prometheus/Snipaste_2023-11-19_01-16-05.png" class="" title="Windows 监控"></div>

<h3 id="Redis-监控"><a href="#Redis-监控" class="headerlink" title="Redis 监控"></a>Redis 监控</h3><h4 id="redis-exporter"><a href="#redis-exporter" class="headerlink" title="redis_exporter"></a>redis_exporter</h4><ul>
<li><a href="https://github.com/oliver006/redis_exporter">redis_exporter Github 仓库</a></li>
<li><a href="https://hub.docker.com/r/oliver006/redis_exporter/">redis_exporter Docker 官方镜像</a></li>
<li><a href="https://hub.docker.com/r/oliver006/redis_exporter/">redis_exporter Docker bitnami 镜像</a></li>
</ul>
<h4 id="docker-compose-部署-2"><a href="#docker-compose-部署-2" class="headerlink" title="docker-compose 部署"></a>docker-compose 部署</h4><p>使用 <code>bitnami</code> 提供的镜像代替官方镜像并没有特殊考量。使用环境变量 <code>REDIS_ADDR</code> 指定目标 <code>Redis</code>。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&#x27;redis:4.0&#x27;</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">6379</span><span class="string">:6379</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis-data:/data</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my-network</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">  <span class="attr">redis-exporter:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">bitnami/redis-exporter:1.55.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis-exporter</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my-network</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REDIS_ADDR=redis://redis:6379</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">redis-data:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">my-network:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<div style="width:80%;margin:auto"><img src="/2023/11/18/setup-monitoring-using-grafana-and-prometheus/Snipaste_2023-11-19_01-16-54.png" class="" title="Redis 监控"></div>

<h3 id="MySQL-监控"><a href="#MySQL-监控" class="headerlink" title="MySQL 监控"></a>MySQL 监控</h3><h4 id="mysqld-exporter"><a href="#mysqld-exporter" class="headerlink" title="mysqld_exporter"></a>mysqld_exporter</h4><ul>
<li><a href="https://github.com/prometheus/mysqld_exporter">mysqld_exporter Github 仓库</a></li>
<li><a href="https://registry.hub.docker.com/r/prom/mysqld-exporter/">mysqld_exporter Docker 官方镜像</a></li>
</ul>
<h4 id="docker-compose-部署-3"><a href="#docker-compose-部署-3" class="headerlink" title="docker-compose 部署"></a>docker-compose 部署</h4><ol>
<li>使用 <code>volume</code> 将配置文件 <code>.my.cnf</code> 挂载到容器中</li>
<li>使用 <code>command</code> 指定启动时的参数</li>
</ol>
<blockquote>
<p><strong>坑！！！</strong>在文档中找配置文件的默认挂载路径或者如何配置启动时的配置文件，找了好久都没找到。搭配上后来的坑，直接迷失数小时。</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;1.0&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql_57:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql_57</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">13306</span><span class="string">:3306</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_ROOT_PASSWORD=123456</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/mysql_5.7/data:/var/lib/mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/mysql_5.7/conf/my.cnf:/etc/my.cnf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./sql:/docker-entrypoint-initdb.d</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my-network</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">  <span class="attr">mysqld-exporter:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">prom/mysqld-exporter:v0.15.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysqld-exporter</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">19104</span><span class="string">:9104</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./exporter/.my.cnf:/cfg/.my.cnf</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my-network</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">command:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">--config.my-cnf=/cfg/.my.cnf</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_57</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">my-network:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="mysqld-exporter-配置文件"><a href="#mysqld-exporter-配置文件" class="headerlink" title="mysqld_exporter 配置文件"></a>mysqld_exporter 配置文件</h4><p>创建一个专用的 <code>MySQL</code> 用户。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE USER &#x27;exporter&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;XXXXXXXX&#x27; WITH MAX_USER_CONNECTIONS 3;</span><br><span class="line">GRANT PROCESS, REPLICATION CLIENT, SELECT ON *.* TO &#x27;exporter&#x27;@&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line">host=mysql_57</span><br><span class="line">port=3306</span><br><span class="line">user=exporter</span><br><span class="line">password=123456</span><br></pre></td></tr></table></figure>

<p><strong>坑！！！</strong>根据 <a href="https://github.com/prometheus/mysqld_exporter/releases/tag/v0.15.0">0.15.0 CHANGE LOG</a>，不再支持使用环境变量 <code>DATA_SOURCE_NAME</code> 设置 <code>MySQL</code> 的信息。<code>Docker</code> 镜像的文档未及时更新。需使用 <code>.my.cnf</code> 或命令行参数进行配置。 <strong><code>Docker</code> 镜像文档更新不及时</strong>。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Error parsing host config&quot; file=.my.cnf err=&quot;no configuration found</span><br></pre></td></tr></table></figure>

<p><strong>坑！！！</strong>带字符的复杂密码不能被正确解析。<code>MySQL</code> 使用了随机生成的复杂密码，怎么都连接不上。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">caller=exporter.go:152 level=error msg=&quot;Error pinging mysqld&quot; err=&quot;Error 1045 (28000): Access denied for user &#x27;exporter&#x27;@&#x27;172.19.0.13&#x27; (using password: YES)&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>数坑并发，搜遍全网，折腾半夜，痛不欲生。</p>
</blockquote>
<div style="width:80%;margin:auto"><img src="/2023/11/18/setup-monitoring-using-grafana-and-prometheus/Snipaste_2023-11-19_01-17-25.png" class="" title="MySQL 监控"></div>]]></content>
      <tags>
        <tag>grafana</tag>
        <tag>prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK 动态代理和 CGLib</title>
    <url>/2023/11/19/JDK-dynamic-proxy-and-CGLib/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h3><p>Java 标准库提供了动态代理功能，允许程序在运行期动态创建指定接口的实例。</p>
<h3 id="CGLib-动态代理"><a href="#CGLib-动态代理" class="headerlink" title="CGLib 动态代理"></a>CGLib 动态代理</h3><p>使用 ASM 框架，加载代理对象的 Class 文件，通过修改其字节码生成子类。</p>
<p><a href="https://github.com/cglib/cglib">cglib Github 仓库</a></p>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li>JDK 动态代理适用于实现接口的类，对未实现接口的类无能为力。</li>
<li>CGLib 不要求类实现接口，但对 final 方法无能为力。</li>
</ul>
<h3 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h3><ul>
<li>在 JDK 8 以前，CGLib 性能更好</li>
<li>从 JDK 8 开始，JDK 动态代理性能更好</li>
</ul>
<blockquote>
<p>根据 README.md 的提醒，cglib 已经不再维护，且在较新版本的 JDK 尤其是 JDK 17+ 中表现不佳，官方推荐可以考虑迁移到 <a href="https://bytebuddy.net/">ByteBuddy</a>。在如今越来越多的项目迁移到 JDK 17 的背景下，值得注意。</p>
</blockquote>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="代理对象的类和接口"><a href="#代理对象的类和接口" class="headerlink" title="代理对象的类和接口"></a>代理对象的类和接口</h3><p>代理对象的类和实现的接口：</p>
<ul>
<li><p>HelloService.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>HelloService.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;name can not be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="JDK-动态代理示例"><a href="#JDK-动态代理示例" class="headerlink" title="JDK 动态代理示例"></a>JDK 动态代理示例</h3><ul>
<li>自定义 InvocationHandler<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;do sth. before invocation&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">            System.out.println(<span class="string">&quot;do sth. after invocation&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;do sth. when exception occurs&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;do sth. finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>测试类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkProxyTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HelloService</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloServiceImpl</span>();</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> target.getClass().getClassLoader();</span><br><span class="line">        Class&lt;?&gt;[] interfaces = target.getClass().getInterfaces();</span><br><span class="line">        <span class="type">UserServiceInvocationHandler</span> <span class="variable">invocationHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceInvocationHandler</span>(target);</span><br><span class="line"></span><br><span class="line">        <span class="type">HelloService</span> <span class="variable">proxy</span> <span class="operator">=</span> (HelloService) Proxy.newProxyInstance(classLoader, interfaces, invocationHandler);</span><br><span class="line">        proxy.sayHello(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;=================&quot;</span>);</span><br><span class="line">        proxy.sayHello(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>结果<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">do sth. before invocation</span><br><span class="line">Hello Tom</span><br><span class="line">do sth. after invocation</span><br><span class="line">do sth. finally</span><br><span class="line">=================</span><br><span class="line">do sth. before invocation</span><br><span class="line">do sth. when exception occurs</span><br><span class="line">do sth. finally</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.reflect.UndeclaredThrowableException</span><br><span class="line">	at com.sun.proxy.$Proxy0.sayHello(Unknown Source)</span><br><span class="line">	at com.moralok.proxy.jdk.JdkProxyTest.main(JdkProxyTest.java:19)</span><br><span class="line">Caused by: java.lang.reflect.InvocationTargetException</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">	at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">	at com.moralok.proxy.jdk.UserServiceInvocationHandler.invoke(UserServiceInvocationHandler.java:18)</span><br><span class="line">	... 2 more</span><br><span class="line">Caused by: java.lang.IllegalArgumentException: name can not be null</span><br><span class="line">	at com.moralok.proxy.HelloServiceImpl.sayHello(HelloServiceImpl.java:8)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="CGLib-动态代理示例"><a href="#CGLib-动态代理示例" class="headerlink" title="CGLib 动态代理示例"></a>CGLib 动态代理示例</h3><ul>
<li>引入依赖<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>自定义 MethodInterceptor<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceMethodInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;do sth. before invocation&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> proxy.invokeSuper(obj, args);</span><br><span class="line">            System.out.println(<span class="string">&quot;do sth. after invocation&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;do sth. when exception occurs&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;do sth. finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>测试类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserServiceMethodInterceptor</span> <span class="variable">methodInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceMethodInterceptor</span>();</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(HelloServiceImpl.class);</span><br><span class="line">        enhancer.setCallback(methodInterceptor);</span><br><span class="line"></span><br><span class="line">        <span class="type">HelloService</span> <span class="variable">proxy</span> <span class="operator">=</span> (HelloService) enhancer.create();</span><br><span class="line">        proxy.sayHello(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;=================&quot;</span>);</span><br><span class="line">        proxy.sayHello(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>结果<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">do sth. before invocation</span><br><span class="line">Hello Tom</span><br><span class="line">do sth. after invocation</span><br><span class="line">do sth. finally</span><br><span class="line">=================</span><br><span class="line">do sth. before invocation</span><br><span class="line">do sth. when exception occurs</span><br><span class="line">do sth. finally</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: name can not be null</span><br><span class="line">	at com.moralok.proxy.HelloServiceImpl.sayHello(HelloServiceImpl.java:8)</span><br><span class="line">	at com.moralok.proxy.HelloServiceImpl$$EnhancerByCGLIB$$c51b2c31.CGLIB$sayHello$0(&lt;generated&gt;)</span><br><span class="line">	at com.moralok.proxy.HelloServiceImpl$$EnhancerByCGLIB$$c51b2c31$$FastClassByCGLIB$$c068b511.invoke(&lt;generated&gt;)</span><br><span class="line">	at net.sf.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:228)</span><br><span class="line">	at com.moralok.proxy.cglib.UserServiceMethodInterceptor.intercept(UserServiceMethodInterceptor.java:14)</span><br><span class="line">	at com.moralok.proxy.HelloServiceImpl$$EnhancerByCGLIB$$c51b2c31.sayHello(&lt;generated&gt;)</span><br><span class="line">	at com.moralok.proxy.cglib.CglibTest.main(CglibTest.java:18)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="查看-JDK-生成的代理类"><a href="#查看-JDK-生成的代理类" class="headerlink" title="查看 JDK 生成的代理类"></a>查看 JDK 生成的代理类</h2><p>使用以下语句，将在工作目录下生成代理类的 Class 文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.setProperty(<span class="string">&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="comment">// 将 InvocationHandler 传递给父类 Proxy</span></span><br><span class="line">        <span class="built_in">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m1, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代理方法调用 InvocationHandler 的 invoke 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String var1)</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m3, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m2, (Object[])<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m0, (Object[])<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态代码块，初始化 Method 属性。</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>));</span><br><span class="line">            m3 = Class.forName(<span class="string">&quot;com.moralok.proxy.HelloService&quot;</span>).getMethod(<span class="string">&quot;sayHello&quot;</span>, Class.forName(<span class="string">&quot;java.lang.String&quot;</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodError</span>(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoClassDefFoundError</span>(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查看-CGLib-生成的子类"><a href="#查看-CGLib-生成的子类" class="headerlink" title="查看 CGLib 生成的子类"></a>查看 CGLib 生成的子类</h2><p>使用以下语句，将 CGLib 生成的子类的 Class 文件输出到指定目录，会发现出现了 3 个 Class 文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, <span class="string">&quot;C:\\Users\\username\\Class&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>HelloServiceImpl$$EnhancerByCGLIB$$c51b2c31.class，代理类</li>
<li>HelloServiceImpl$$FastClassByCGLIB$$a5654167.class，被代理类的 FastClass</li>
<li>HelloServiceImpl$$EnhancerByCGLIB$$c51b2c31$$FastClassByCGLIB$$c068b511.class，代理类的 FastClass</li>
</ul>
<img src="/2023/11/19/JDK-dynamic-proxy-and-CGLib/Snipaste_2023-11-28_02-01-40.png" class="" title="CGLib 生成的子类的 Class 文件">

<h3 id="代理类定义"><a href="#代理类定义" class="headerlink" title="代理类定义"></a>代理类定义</h3><p>继承了被代理类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServiceImpl$$EnhancerByCGLIB$$c51b2c31</span> <span class="keyword">extends</span> <span class="title class_">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 调用静态钩子方法</span></span><br><span class="line">    CGLIB$STATICHOOK1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> CGLIB$STATICHOOK1() &#123;</span><br><span class="line">    CGLIB$THREAD_CALLBACKS = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();</span><br><span class="line">    CGLIB$emptyArgs = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="type">Class</span> <span class="variable">var0</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.moralok.proxy.HelloServiceImpl$$EnhancerByCGLIB$$c51b2c31&quot;</span>);</span><br><span class="line">    Class var1;</span><br><span class="line">    <span class="comment">// 获取 Object 类的 equals、toString、hashCode、clone 这几个特定方法的 Method 对象</span></span><br><span class="line">    Method[] var10000 = ReflectUtils.findMethods(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;equals&quot;</span>, <span class="string">&quot;(Ljava/lang/Object;)Z&quot;</span>, <span class="string">&quot;toString&quot;</span>, <span class="string">&quot;()Ljava/lang/String;&quot;</span>, <span class="string">&quot;hashCode&quot;</span>, <span class="string">&quot;()I&quot;</span>, <span class="string">&quot;clone&quot;</span>, <span class="string">&quot;()Ljava/lang/Object;&quot;</span>&#125;, (var1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>)).getDeclaredMethods());</span><br><span class="line">    <span class="comment">// 还生成了相对应的 Method 属性保存（为了减少一次寻址吗？）</span></span><br><span class="line">    CGLIB$equals$<span class="number">1</span>$Method = var10000[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 为每一个 Method 创建一个 MethodProxy</span></span><br><span class="line">    CGLIB$equals$<span class="number">1</span>$Proxy = MethodProxy.create(var1, var0, <span class="string">&quot;(Ljava/lang/Object;)Z&quot;</span>, <span class="string">&quot;equals&quot;</span>, <span class="string">&quot;CGLIB$equals$1&quot;</span>);</span><br><span class="line">    CGLIB$toString$<span class="number">2</span>$Method = var10000[<span class="number">1</span>];</span><br><span class="line">    CGLIB$toString$<span class="number">2</span>$Proxy = MethodProxy.create(var1, var0, <span class="string">&quot;()Ljava/lang/String;&quot;</span>, <span class="string">&quot;toString&quot;</span>, <span class="string">&quot;CGLIB$toString$2&quot;</span>);</span><br><span class="line">    CGLIB$hashCode$<span class="number">3</span>$Method = var10000[<span class="number">2</span>];</span><br><span class="line">    CGLIB$hashCode$<span class="number">3</span>$Proxy = MethodProxy.create(var1, var0, <span class="string">&quot;()I&quot;</span>, <span class="string">&quot;hashCode&quot;</span>, <span class="string">&quot;CGLIB$hashCode$3&quot;</span>);</span><br><span class="line">    CGLIB$clone$<span class="number">4</span>$Method = var10000[<span class="number">3</span>];</span><br><span class="line">    CGLIB$clone$<span class="number">4</span>$Proxy = MethodProxy.create(var1, var0, <span class="string">&quot;()Ljava/lang/Object;&quot;</span>, <span class="string">&quot;clone&quot;</span>, <span class="string">&quot;CGLIB$clone$4&quot;</span>);</span><br><span class="line">    <span class="comment">// 被代理类的方法也做相同处理</span></span><br><span class="line">    CGLIB$sayHello$<span class="number">0</span>$Method = ReflectUtils.findMethods(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;sayHello&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>&#125;, (var1 = Class.forName(<span class="string">&quot;com.moralok.proxy.HelloServiceImpl&quot;</span>)).getDeclaredMethods())[<span class="number">0</span>];</span><br><span class="line">    CGLIB$sayHello$<span class="number">0</span>$Proxy = MethodProxy.create(var1, var0, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="string">&quot;sayHello&quot;</span>, <span class="string">&quot;CGLIB$sayHello$0&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MethodProxy 稍后再做介绍。</p>
<h3 id="构造器方法"><a href="#构造器方法" class="headerlink" title="构造器方法"></a>构造器方法</h3><p>构造器方法内，调用了绑定回调（Callbacks）方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> HelloServiceImpl$$EnhancerByCGLIB$$c51b2c31() &#123;</span><br><span class="line">    CGLIB$BIND_CALLBACKS(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标识是否已经绑定过回调</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> CGLIB$BOUND;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> CGLIB$BIND_CALLBACKS(Object var0) &#123;</span><br><span class="line">    <span class="type">HelloServiceImpl$$EnhancerByCGLIB$$c51b2c31</span> <span class="variable">var1</span> <span class="operator">=</span> (HelloServiceImpl$$EnhancerByCGLIB$$c51b2c31)var0;</span><br><span class="line">    <span class="keyword">if</span> (!var1.CGLIB$BOUND) &#123;</span><br><span class="line">        <span class="comment">// 未绑定过回调则进行绑定，更新标识</span></span><br><span class="line">        var1.CGLIB$BOUND = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 先获取 THREAD_CALLBACKS</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">var10000</span> <span class="operator">=</span> CGLIB$THREAD_CALLBACKS.get();</span><br><span class="line">        <span class="keyword">if</span> (var10000 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果为 null，再获取 STATIC_CALLBACKS</span></span><br><span class="line">            var10000 = CGLIB$STATIC_CALLBACKS;</span><br><span class="line">            <span class="keyword">if</span> (var10000 == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果仍然为 null，直接返回</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每一个 Callback （像之前的 Method 一样）都有专门的属性保存</span></span><br><span class="line">        var1.CGLIB$CALLBACK_0 = (MethodInterceptor)((Callback[])var10000)[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="生成的代理方法"><a href="#生成的代理方法" class="headerlink" title="生成的代理方法"></a>生成的代理方法</h3><p>CGLib 会为每一个代理方法生成两个对应的方法，一个直接调用父类方法，一个则调用回调（拦截器）的 intercept 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> CGLIB$sayHello$<span class="number">0</span>(String var1) &#123;</span><br><span class="line">    <span class="built_in">super</span>.sayHello(var1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String var1)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取回调（拦截器）</span></span><br><span class="line">    <span class="type">MethodInterceptor</span> <span class="variable">var10000</span> <span class="operator">=</span> <span class="built_in">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">    <span class="keyword">if</span> (var10000 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果为 null，先进行回调绑定</span></span><br><span class="line">        CGLIB$BIND_CALLBACKS(<span class="built_in">this</span>);</span><br><span class="line">        var10000 = <span class="built_in">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (var10000 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果回调（拦截器）不为 null，则调用 intercept 方法</span></span><br><span class="line">        var10000.intercept(<span class="built_in">this</span>, CGLIB$sayHello$<span class="number">0</span>$Method, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;var1&#125;, CGLIB$sayHello$<span class="number">0</span>$Proxy);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则直接调用父类方法</span></span><br><span class="line">        <span class="built_in">super</span>.sayHello(var1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CGLib 通过继承实现动态代理的过程，在查看生成的子类的 Class 后，是非常容易理解的。拦截器的参数有代理对象、Method、方法参数和 MethodProxy 对象。</p>
<h2 id="分析-MethodProxy"><a href="#分析-MethodProxy" class="headerlink" title="分析 MethodProxy"></a>分析 MethodProxy</h2><p>如何在拦截器中调用被代理的方法呢？就是通过 MethodProxy 实现的。</p>
<h3 id="创建-MethodProxy"><a href="#创建-MethodProxy" class="headerlink" title="创建 MethodProxy"></a>创建 MethodProxy</h3><p>MethodProxy 是 CGLib 为每一个代理方法创建的方法代理，当调用拦截的方法时，它被传递给 MethodInterceptor 对象的 intercept 方法。它可以用于调用原始方法，或对同一类型的不同对象调用相同方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CGLIB$sayHello$<span class="number">0</span>$Proxy = MethodProxy.create(var1, var0, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="string">&quot;sayHello&quot;</span>, <span class="string">&quot;CGLIB$sayHello$0&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> MethodProxy <span class="title function_">create</span><span class="params">(Class c1, Class c2, String desc, String name1, String name2)</span> &#123;</span><br><span class="line">    <span class="type">MethodProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodProxy</span>();</span><br><span class="line">    <span class="comment">// sayHello 方法签名</span></span><br><span class="line">    proxy.sig1 = <span class="keyword">new</span> <span class="title class_">Signature</span>(name1, desc);</span><br><span class="line">    <span class="comment">// CGLIB$sayHello$0 方法签名</span></span><br><span class="line">    proxy.sig2 = <span class="keyword">new</span> <span class="title class_">Signature</span>(name2, desc);</span><br><span class="line">    <span class="comment">// 被代理类和代理类</span></span><br><span class="line">    proxy.createInfo = <span class="keyword">new</span> <span class="title class_">CreateInfo</span>(c1, c2);</span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CreateInfo 静态内部类，保存被代理类和代理类以及其他一些信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CreateInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 被代理类</span></span><br><span class="line">    Class c1;</span><br><span class="line">    <span class="comment">// 代理类</span></span><br><span class="line">    Class c2;</span><br><span class="line">    NamingPolicy namingPolicy;</span><br><span class="line">    GeneratorStrategy strategy;</span><br><span class="line">    <span class="type">boolean</span> attemptLoad;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CreateInfo</span><span class="params">(Class c1, Class c2)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.c1 = c1;</span><br><span class="line">        <span class="built_in">this</span>.c2 = c2;</span><br><span class="line">        <span class="type">AbstractClassGenerator</span> <span class="variable">fromEnhancer</span> <span class="operator">=</span> AbstractClassGenerator.getCurrent();</span><br><span class="line">        <span class="keyword">if</span> (fromEnhancer != <span class="literal">null</span>) &#123;</span><br><span class="line">            namingPolicy = fromEnhancer.getNamingPolicy();</span><br><span class="line">            strategy = fromEnhancer.getStrategy();</span><br><span class="line">            attemptLoad = fromEnhancer.getAttemptLoad();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FastClass-和方法索引对"><a href="#FastClass-和方法索引对" class="headerlink" title="FastClass 和方法索引对"></a>FastClass 和方法索引对</h3><h4 id="调用原始方法-invokeSuper"><a href="#调用原始方法-invokeSuper" class="headerlink" title="调用原始方法 invokeSuper"></a>调用原始方法 invokeSuper</h4><p>MethodProxy 通过 invokeSuper 调用原始方法（父类方法）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// invoke 方法的代码相似</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invokeSuper</span><span class="params">(Object obj, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化，生成 FastClassInfo</span></span><br><span class="line">        init();</span><br><span class="line">        <span class="type">FastClassInfo</span> <span class="variable">fci</span> <span class="operator">=</span> fastClassInfo;</span><br><span class="line">        <span class="comment">// 调用原始（父类）方法</span></span><br><span class="line">        <span class="keyword">return</span> fci.f2.invoke(fci.i2, obj, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.getTargetException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="生成-FastClass-信息"><a href="#生成-FastClass-信息" class="headerlink" title="生成 FastClass 信息"></a>生成 FastClass 信息</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 双重校验锁，生成 FastClass 和方法索引对</span></span><br><span class="line">    <span class="keyword">if</span> (fastClassInfo == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (initLock)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (fastClassInfo == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">CreateInfo</span> <span class="variable">ci</span> <span class="operator">=</span> createInfo;</span><br><span class="line"></span><br><span class="line">                <span class="type">FastClassInfo</span> <span class="variable">fci</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FastClassInfo</span>();</span><br><span class="line">                <span class="comment">// 生成 FastClass</span></span><br><span class="line">                fci.f1 = helper(ci, ci.c1);</span><br><span class="line">                fci.f2 = helper(ci, ci.c2);</span><br><span class="line">                <span class="comment">// 获取方法索引</span></span><br><span class="line">                fci.i1 = fci.f1.getIndex(sig1);</span><br><span class="line">                fci.i2 = fci.f2.getIndex(sig2);</span><br><span class="line">                fastClassInfo = fci;</span><br><span class="line">                createInfo = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="FastClass-信息"><a href="#FastClass-信息" class="headerlink" title="FastClass 信息"></a>FastClass 信息</h4><ul>
<li>f1 是被代理类的 FastClass 对象，i1 是 <code>CGLIB$sayHello$0</code> 方法在生成的 FastClass 中的索引。</li>
<li>f2 是代理类的 FastClass 对象，i2 是 <code>sayHello</code> 方法在生成的 FastClass 中的索引。</li>
</ul>
<p>invoke 方法根据传入的方法索引，快速定位要调用对象 obj 的哪个方法。</p>
<blockquote>
<p>CGLib 完全有能力获得 <code>CGLIB$sayHello$0</code> 的 Method 对象，通过反射实现调用，这样处理逻辑更加清楚。但是早期 Java 反射的性能并不好，通过 FastClass 机制避免使用反射从而提升了性能。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">FastClassInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    FastClass f1;</span><br><span class="line">    FastClass f2;</span><br><span class="line">    <span class="type">int</span> i1;</span><br><span class="line">    <span class="type">int</span> i2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FastClass-的-invoke-方法"><a href="#FastClass-的-invoke-方法" class="headerlink" title="FastClass 的 invoke 方法"></a>FastClass 的 invoke 方法</h3><p>以代理类的 FastClass <code>HelloServiceImpl$$EnhancerByCGLIB$$c51b2c31$$FastClassByCGLIB$$c068b511</code> 为例，当传入的方法索引为 16 时，就会调用 <code>CGLIB$sayHello$0</code> 方法。</p>
<ol>
<li>获取代理对象</li>
<li>根据传入的方法索引，调用</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(<span class="type">int</span> var1, Object var2, Object[] var3)</span> <span class="keyword">throws</span> InvocationTargetException &#123;</span><br><span class="line">    HelloServiceImpl..EnhancerByCGLIB..<span class="type">c51b2c31</span> <span class="variable">var10000</span> <span class="operator">=</span> (HelloServiceImpl..EnhancerByCGLIB..c51b2c31)var2;</span><br><span class="line">    <span class="type">int</span> <span class="variable">var10001</span> <span class="operator">=</span> var1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (var10001) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(var10000.equals(var3[<span class="number">0</span>]));</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line">                var10000.CGLIB$sayHello$<span class="number">0</span>((String)var3[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvocationTargetException</span>(var4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Cannot find matching method/constructor&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取方法索引"><a href="#获取方法索引" class="headerlink" title="获取方法索引"></a>获取方法索引</h4><p>怎么知道方法的索引呢？在初始化 FastClass 信息时，不仅生成了 FastClass，还通过 getIndex 获取方法的索引。</p>
<blockquote>
<p>在 JDK 7 之后，switch 不仅可以支持 int、enum，还能支持 String，CGLib 这样实现是出于兼容性的考虑还是说有什么性能提升？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(Signature var1)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">var10000</span> <span class="operator">=</span> var1.toString();</span><br><span class="line">    <span class="keyword">switch</span> (var10000.hashCode()) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">case</span> -<span class="number">1721191351</span>:</span><br><span class="line">            <span class="keyword">if</span> (var10000.equals(<span class="string">&quot;CGLIB$sayHello$0(Ljava/lang/String;)V&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">16</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结和思考"><a href="#总结和思考" class="headerlink" title="总结和思考"></a>总结和思考</h2><p>两者在使用上是相仿的。</p>
<ul>
<li>对于两者的源码，读得不多。有时候会感慨，看这么多年前的代码，还是感觉吃力。有时候想，如果不好好看源码，心里不踏实；如果花很多时间理清楚了，但是发现更多只是知道了一些细节，于整体理解的提升不大，又会感觉不值得。</li>
<li>但也提醒自己，不要太在意，用得本就不多，涉及源码的机会更是没有，如果方方面面都要细究，人生太短，智商不够，等涉足相关问题再回头研究。</li>
<li>基础的用法和概念应该了解，不然看到 Spring AOP 源码时，分不清 Spring 封装的边界在哪里。</li>
</ul>
<blockquote>
<p>借着梳理 Spring 的机会回头再看，又感觉轻松不少。</p>
</blockquote>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>jdk proxy</tag>
        <tag>cglib</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring AOP 如何创建代理 beans</title>
    <url>/2023/11/19/how-does-Spring-AOP-create-proxy-beans/</url>
    <content><![CDATA[<p>Spring AOP 是基于代理实现的，它既支持 JDK 动态代理也支持 CGLib。</p>
<ul>
<li>在什么时候创建代理对象的？</li>
<li>怎么创建代理对象的？</li>
</ul>
<h2 id="过程简单图解"><a href="#过程简单图解" class="headerlink" title="过程简单图解"></a>过程简单图解</h2><img src="/2023/11/19/how-does-Spring-AOP-create-proxy-beans/Pasted%20image%2020231120223506.png" class="" title="Spring AOP 创建代理的过程">

<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li>引入依赖<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>目标对象类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathCalculator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i / j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>切面类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspects</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(public int com.moralok.aop.MathCalculator.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointCut</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logStart</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        System.out.println(joinPoint.getSignature().getName() + <span class="string">&quot;除法运行@Before。。。参数列表为 &quot;</span> + Arrays.asList(joinPoint.getArgs()) + <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logEnd</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        System.out.println(joinPoint.getSignature().getName() + <span class="string">&quot;除法结束@After。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;pointCut()&quot;, returning = &quot;result&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logReturn</span><span class="params">(JoinPoint joinPoint, Object result)</span> &#123;</span><br><span class="line">        System.out.println(joinPoint.getSignature().getName() + <span class="string">&quot;除法正常返回@AfterReturning。。。运行结果 &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;pointCut()&quot;, throwing = &quot;e&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logException</span><span class="params">(JoinPoint joinPoint, Exception e)</span> &#123;</span><br><span class="line">        System.out.println(joinPoint.getSignature().getName() + <span class="string">&quot;除法异常@AfterThrowing。。。异常信息 &quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(value = &quot;execution(public String com.moralok.bean.Car.getName(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">logAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(joinPoint.getSignature().getName() + <span class="string">&quot; @Around开始&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> joinPoint.proceed();</span><br><span class="line">        System.out.println(joinPoint.getSignature().getName() + <span class="string">&quot; @Around结束&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>配置类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AopConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MathCalculator <span class="title function_">mathCalculator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MathCalculator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> LogAspects <span class="title function_">logAspects</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LogAspects</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>测试类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AopTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">aopTest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AopConfig.class);</span><br><span class="line">        <span class="type">MathCalculator</span> <span class="variable">mathCalculator</span> <span class="operator">=</span> ac.getBean(MathCalculator.class);</span><br><span class="line">        mathCalculator.div(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        mathCalculator.div(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        ac.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Debug 断点的判断条件（可选）<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">beanName.equals(&quot;mathCalculator&quot;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="创建代理-Bean-和创建普通-Bean-的区别"><a href="#创建代理-Bean-和创建普通-Bean-的区别" class="headerlink" title="创建代理 Bean 和创建普通 Bean 的区别"></a>创建代理 Bean 和创建普通 Bean 的区别</h2><p>其实创建代理 Bean 的过程和<a href="/2023/08/10/how-does-Spring-load-beans/" title="Spring Bean 加载过程">创建普通 Bean 的过程</a>直到进行初始化处理（initializeBean）前都是一样的。更具体地说，如很多资料所言，Spring 创建代理对象的工作，是在应用后置处理器阶段完成的。</p>
<h3 id="常规的入口-getBean"><a href="#常规的入口-getBean" class="headerlink" title="常规的入口 getBean"></a>常规的入口 getBean</h3><p>mathCalculator 以 getBean 方法为起点，开始创建的过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="comment">// ...（mathCalculator）</span></span><br><span class="line">    getBean(beanName);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="应用后置处理器"><a href="#应用后置处理器" class="headerlink" title="应用后置处理器"></a>应用后置处理器</h3><p>在正常地实例化 Bean 后，初始化 Bean 时，会对 Bean 实例应用后置处理器。</p>
<p>可是，<strong>究竟是哪一个后置处理器做的呢</strong>？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, RootBeanDefinition mbd)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">    <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AnnotationAwareAspectJAutoProxyCreator"><a href="#AnnotationAwareAspectJAutoProxyCreator" class="headerlink" title="AnnotationAwareAspectJAutoProxyCreator"></a>AnnotationAwareAspectJAutoProxyCreator</h3><p>在本示例中，创建代理的后置处理器就是 AnnotationAwareAspectJAutoProxyCreator，它继承自 AbstractAutoProxyCreator，AbstractAutoProxyCreator 实现了 BeanPostProcessor 接口。</p>
<p>那么，<strong>它是什么时候，怎么加入到 beanFactory 中呢</strong>？</p>
<p>PS: 显然，还有其他继承自 AbstractAutoProxyCreator 的后置处理器，暂时不谈。</p>
<h4 id="BeanPostProcessor-的方法"><a href="#BeanPostProcessor-的方法" class="headerlink" title="BeanPostProcessor 的方法"></a>BeanPostProcessor 的方法</h4><p>postProcessBeforeInitialization 和 postProcessAfterInitialization 方法，前者什么都没做，后者在必要时对 Bean 进行包装。</p>
<ul>
<li><strong><code>AbstractAutoProxyCreator#postProcessAfterInitialization</code> 就是创建代理对象的入口。</strong></li>
<li><strong>wrapIfNecessary 就是将 Bean 包装成代理 Bean 的入口方法</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title class_">ProxyProcessorSupport</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">SmartInstantiationAwareBeanPostProcessor</span>, BeanFactoryAware &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> &#123;</span><br><span class="line">        <span class="comment">// 什么都没做</span></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">this</span>.earlyProxyReferences.contains(cacheKey)) &#123;</span><br><span class="line">                <span class="comment">// 如有必要，将 bean 包装成代理对象</span></span><br><span class="line">                <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建代理-Bean-的过程"><a href="#创建代理-Bean-的过程" class="headerlink" title="创建代理 Bean 的过程"></a>创建代理 Bean 的过程</h2><h3 id="按需包装成代理-wrapIfNecessary"><a href="#按需包装成代理-wrapIfNecessary" class="headerlink" title="按需包装成代理 wrapIfNecessary"></a>按需包装成代理 wrapIfNecessary</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否直接返回 bean</span></span><br><span class="line">    <span class="keyword">if</span> (beanName != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Boolean.FALSE.equals(<span class="built_in">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有适用于当前 bean 的 advise 则为其创建代理</span></span><br><span class="line">    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">        <span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> createProxy(</span><br><span class="line">                bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> <span class="title class_">SingletonTargetSource</span>(bean));</span><br><span class="line">        <span class="built_in">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AbstractAutoProxyCreator-视角，创建代理"><a href="#AbstractAutoProxyCreator-视角，创建代理" class="headerlink" title="AbstractAutoProxyCreator 视角，创建代理"></a>AbstractAutoProxyCreator 视角，创建代理</h3><p>AbstractAutoProxyCreator#createProxy，创建一个 ProxyFactory，将工作交给它处理。</p>
<ol>
<li>创建一个代理工厂 ProxyFactory</li>
<li>设置相关信息</li>
<li>通过 ProxyFactory 获取代理</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createProxy</span><span class="params">(</span></span><br><span class="line"><span class="params">        Class&lt;?&gt; beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">        AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="built_in">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ProxyFactory</span> <span class="variable">proxyFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">    proxyFactory.copyFrom(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">            proxyFactory.setProxyTargetClass(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">    proxyFactory.addAdvisors(advisors);</span><br><span class="line">    proxyFactory.setTargetSource(targetSource);</span><br><span class="line">    customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">    proxyFactory.setFrozen(<span class="built_in">this</span>.freezeProxy);</span><br><span class="line">    <span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">        proxyFactory.setPreFiltered(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ProxyFactory-视角，获取代理"><a href="#ProxyFactory-视角，获取代理" class="headerlink" title="ProxyFactory 视角，获取代理"></a>ProxyFactory 视角，获取代理</h3><p>ProxyFactory#getProxy，创建一个 AopProxy 并委托它实现 getProxy。</p>
<blockquote>
<p>AopProxy 的含义与职责从字面上有点不好理解。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">(ClassLoader classLoader)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> createAopProxy().getProxy(classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ProxyFactor视角，创建-AopProxy"><a href="#ProxyFactor视角，创建-AopProxy" class="headerlink" title="ProxyFactor视角，创建 AopProxy"></a>ProxyFactor视角，创建 AopProxy</h4><p>ProxyFactory#createAopProxy，获取一个 AopProxyFactory 创建 AopProxy。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> AopProxy <span class="title function_">createAopProxy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.active) &#123;</span><br><span class="line">        activate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取 AopProxy 工厂并创建一个 AopProxy</span></span><br><span class="line">    <span class="keyword">return</span> getAopProxyFactory().createAopProxy(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AopProxyFactory视角，创建-AopProxy"><a href="#AopProxyFactory视角，创建-AopProxy" class="headerlink" title="AopProxyFactory视角，创建 AopProxy"></a>AopProxyFactory视角，创建 AopProxy</h4><p>AopProxyFactory#createAopProxy。</p>
<ul>
<li>AopProxyFactory 有且仅有一个默认实现 DefaultAopProxyFactory。</li>
<li>createAopProxy 方法会根据配置信息，返回具体实现：开箱即用的有 JdkDynamicAopProxy 或者 ObjenesisCglibAopProxy。</li>
</ul>
<p>这里的处理，决定了 Spring AOP 会使用哪一种动态代理实现。比如 Spring AOP 默认使用 JDK 动态代理，如果目标对象实现了接口 Spring 会使用 JDK 动态代理，这些结论的依据就在于此。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultAopProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">AopProxyFactory</span>, Serializable &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> AopProxy <span class="title function_">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException &#123;</span><br><span class="line">		<span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">			Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">			<span class="keyword">if</span> (targetClass == <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AopConfigException</span>(<span class="string">&quot;TargetSource cannot determine target class: &quot;</span> +</span><br><span class="line">						<span class="string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ObjenesisCglibAopProxy</span>(config);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取代理-AopProxy-getProxy"><a href="#获取代理-AopProxy-getProxy" class="headerlink" title="获取代理 AopProxy#getProxy"></a>获取代理 AopProxy#getProxy</h3><p>AopProxy 视角，获取代理。</p>
<h4 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h4><p>JdkDynamicAopProxy。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">(ClassLoader classLoader)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// JDK 动态代理，已经和 Spring 无关</span></span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="InvocationHandler-的-invoke-方法"><a href="#InvocationHandler-的-invoke-方法" class="headerlink" title="InvocationHandler 的 invoke 方法"></a>InvocationHandler 的 invoke 方法</h5><p>根据 <code>Proxy.newProxyInstance(classLoader, proxiedInterfaces, this)</code> 可知，this 也就是 JdkDynamicAopProxy 同时也是一个 InvocationHandler，它必然实现了 invoke 方法，当代理对象调用方法时，就会进入到 invoke 方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CGLib-动态代理"><a href="#CGLib-动态代理" class="headerlink" title="CGLib 动态代理"></a>CGLib 动态代理</h4><p>ObjenesisCglibAopProxy。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">(ClassLoader classLoader)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// CGLib 动态代理，已经和 Spring 无关</span></span><br><span class="line">    <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> createEnhancer();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> createProxyClassAndInstance(enhancer, callbacks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="为什么-Spring-中没有依赖-CGLib"><a href="#为什么-Spring-中没有依赖-CGLib" class="headerlink" title="为什么 Spring 中没有依赖 CGLib"></a>为什么 Spring 中没有依赖 CGLib</h5><p>你可能会注意到 Spring 中并没有直接依赖 CGLib，像 Enhancer 所在的包是 <code>org.springframework.cglib.proxy</code>。根据文档：</p>
<blockquote>
<p>从 spring 3.2 开始，不再需要将 cglib 添加到类路径中，因为 cglib 类在 org.springframework 下重新打包并分布在 spring-core jar 中。 这样做既是为了方便，也是为了避免与使用不同版本 cglib 的其他项目发生潜在冲突。</p>
</blockquote>
<h2 id="创建代理前的准备"><a href="#创建代理前的准备" class="headerlink" title="创建代理前的准备"></a>创建代理前的准备</h2><p>在前面预留了一些问题，当初我在看网上的资料时就有这些困惑。</p>
<h3 id="Bean-后置处理器-AspectJAwareAdvisorAutoProxyCreator-在什么时候，怎么加入到-beanFactory-中的？"><a href="#Bean-后置处理器-AspectJAwareAdvisorAutoProxyCreator-在什么时候，怎么加入到-beanFactory-中的？" class="headerlink" title="Bean 后置处理器 AspectJAwareAdvisorAutoProxyCreator 在什么时候，怎么加入到 beanFactory 中的？"></a>Bean 后置处理器 AspectJAwareAdvisorAutoProxyCreator 在什么时候，怎么加入到 beanFactory 中的？</h3><p>Debug 停留在 Spring 上下文刷新方法中的 finishBeanFactoryInitialization。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 beanFatory 的 beanDefinitionMap 可以观察到，配置类 AopConfig 中的 MathCalculator 和 LogAspect 的信息已经就位。</p>
<img src="/2023/11/19/how-does-Spring-AOP-create-proxy-beans/Snipaste_2023-11-20_15-51-48.png" class="" title="初始化 beanFactory 时的 beanDefinitionMap">

<p>从 beanFactory 的 beanProcessor 可以观察到，AnnotationAwareAspectJAutoProxyCreator 已经就位。</p>
<img src="/2023/11/19/how-does-Spring-AOP-create-proxy-beans/Snipaste_2023-11-20_15-56-15.png" class="" title="初始化 beanFactory 时的 beanPostProcessor">

<h4 id="EnableXXX-的魔法"><a href="#EnableXXX-的魔法" class="headerlink" title="@EnableXXX 的魔法"></a>@EnableXXX 的魔法</h4><p>注解 @EnableXXX 往往伴随着注解 @Import，在 invokeBeanFactoryPostProcessors(beanFactory) 中，工厂后置处理器 ConfigurationClassPostProcessor 会处理它。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(AspectJAutoProxyRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAspectJAutoProxy &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">exposeProxy</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 ConfigurationClassPostProcessor 的处理中，因为 AspectJAutoProxyRegistrar 实现了 ImportBeanDefinitionRegistrar，registerBeanDefinitions 方法会被调用，AnnotationAwareAspectJAutoProxyCreator 的 beanDefinition 随之被注册到 beanFactory，因 AnnotationAwareAspectJAutoProxyCreator 实现了 BeanPostProcessor 被提前创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AspectJAutoProxyRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(</span></span><br><span class="line"><span class="params">            AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 如有必要注册 AspectJAnnotationAutoProxyCreator</span></span><br><span class="line">        AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</span><br><span class="line">        <span class="comment">// 根据配置设置一些属性</span></span><br><span class="line">        <span class="type">AnnotationAttributes</span> <span class="variable">enableAspectJAutoProxy</span> <span class="operator">=</span></span><br><span class="line">                AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);</span><br><span class="line">        <span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">&quot;proxyTargetClass&quot;</span>)) &#123;</span><br><span class="line">            AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">&quot;exposeProxy&quot;</span>)) &#123;</span><br><span class="line">            AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BeanDefinition <span class="title function_">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="params">(BeanDefinitionRegistry registry, Object source)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="切面类-LogAspect-的解析是在什么时候？"><a href="#切面类-LogAspect-的解析是在什么时候？" class="headerlink" title="切面类 LogAspect 的解析是在什么时候？"></a>切面类 LogAspect 的解析是在什么时候？</h3><p>进入创建 Bean 的方法 createBean 后，除了 doCreateBean，应额外留意 resolveBeforeInstantiation 方法。</p>
<ol>
<li><code>Object bean = resolveBeforeInstantiation(beanName, mbdToUse)</code>，在实例化前进行解析。</li>
<li><code>Object beanInstance = doCreateBean(beanName, mbdToUse, args)</code>，创建 Bean 的具体过程。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> <span class="keyword">throws</span> BeanCreationException &#123; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">beanInstance</span> <span class="operator">=</span> doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="入口方法-resolveBeforeInstantiation"><a href="#入口方法-resolveBeforeInstantiation" class="headerlink" title="入口方法 resolveBeforeInstantiation"></a>入口方法 resolveBeforeInstantiation</h4><p>根据注释，该方法给 BeanPostProcessors 一个机会提前返回一个代理对象。在本示例中，返回 null，但是方法在第一次执行后已经提前解析得到 advisors 并缓存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">resolveBeforeInstantiation</span><span class="params">(String beanName, RootBeanDefinition mbd)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">            Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);</span><br><span class="line">            <span class="keyword">if</span> (targetType != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 注意，应用的是实例化前的处理</span></span><br><span class="line">                bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);</span><br><span class="line">                <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 注意，应用的是初始化后的处理</span></span><br><span class="line">                    bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mbd.beforeInstantiationResolved = (bean != <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="InstantiationAwareBeanPostProcessor"><a href="#InstantiationAwareBeanPostProcessor" class="headerlink" title="InstantiationAwareBeanPostProcessor"></a>InstantiationAwareBeanPostProcessor</h4><p>应用 InstantiationAwareBeanPostProcessor 的 postProcessBeforeInstantiation。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">applyBeanPostProcessorsBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">            <span class="type">InstantiationAwareBeanPostProcessor</span> <span class="variable">ibp</span> <span class="operator">=</span> (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">            <span class="comment">// 循环依次处理</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> ibp.postProcessBeforeInstantiation(beanClass, beanName);</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AnnotationAwareAspectJAutoProxyCreator 不仅仅是一个 BeanPostProcessor，它还是一个 InstantiationAwareBeanPostProcessor。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(beanClass, beanName);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (beanName == <span class="literal">null</span> || !<span class="built_in">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.advisedBeans.containsKey(cacheKey)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (beanName != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">TargetSource</span> <span class="variable">targetSource</span> <span class="operator">=</span> getCustomTargetSource(beanClass, beanName);</span><br><span class="line">        <span class="keyword">if</span> (targetSource != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.targetSourcedBeans.add(beanName);</span><br><span class="line">            Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> createProxy(beanClass, beanName, specificInterceptors, targetSource);</span><br><span class="line">            <span class="built_in">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">            <span class="keyword">return</span> proxy;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和 wrapIfNecessary 方法对比，容易发现两者有不少相似的处理。</p>
<img src="/2023/11/19/how-does-Spring-AOP-create-proxy-beans/Snipaste_2023-11-20_21-33-34.png" class="" title="实例化前后创建代理的对比">

<blockquote>
<p><strong>注意：以下方法应注意是否被子类重写</strong>。</p>
</blockquote>
<p>org.springframework.aop.aspectj.autoproxy.AspectJAwareAdvisorAutoProxyCreator#shouldSkip</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">shouldSkip</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> &#123;</span><br><span class="line">    <span class="comment">// 查找并缓存 advisors</span></span><br><span class="line">    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator#getAdvicesAndAdvisorsForBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object[] getAdvicesAndAdvisorsForBean(Class&lt;?&gt; beanClass, String beanName, TargetSource targetSource) &#123;</span><br><span class="line">    List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator#findEligibleAdvisors</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title function_">findEligibleAdvisors</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> &#123;</span><br><span class="line">    <span class="comment">// 查找并缓存 advisors</span></span><br><span class="line">    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>容易注意到两者在创建代理前，<strong>都会调用 findCandidateAdvisors 方法查找候选的 advisors</strong>，其实这也是我们想要找的对切面类的解析处理所在。</p>
<h4 id="查找并缓存-advisors"><a href="#查找并缓存-advisors" class="headerlink" title="查找并缓存 advisors"></a>查找并缓存 advisors</h4><p>org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator#findCandidateAdvisors</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title function_">findCandidateAdvisors</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Advisor&gt; advisors = <span class="built_in">super</span>.findCandidateAdvisors();</span><br><span class="line">    advisors.addAll(<span class="built_in">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());</span><br><span class="line">    <span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>org.springframework.aop.aspectj.annotation.BeanFactoryAspectJAdvisorsBuilder#buildAspectJAdvisors</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title function_">buildAspectJAdvisors</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; aspectNames = <span class="built_in">this</span>.aspectBeanNames;  </span><br><span class="line">    <span class="keyword">if</span> (aspectNames == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 第一次进入，没有缓存</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            aspectNames = <span class="built_in">this</span>.aspectBeanNames;</span><br><span class="line">            <span class="keyword">if</span> (aspectNames == <span class="literal">null</span>) &#123;</span><br><span class="line">                List&lt;Advisor&gt; advisors = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Advisor&gt;();</span><br><span class="line">                aspectNames = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line">                String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">                        <span class="built_in">this</span>.beanFactory, Object.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">                    <span class="comment">// ...</span></span><br><span class="line">                    <span class="comment">// 如果是切面，解析得到 advisors</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">this</span>.advisorFactory.isAspect(beanType)) &#123;</span><br><span class="line">                        aspectNames.add(beanName);</span><br><span class="line">                        <span class="comment">// ...</span></span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line">                            <span class="built_in">this</span>.advisorsCache.put(beanName, classAdvisors);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="built_in">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">this</span>.aspectBeanNames = aspectNames;</span><br><span class="line">                <span class="keyword">return</span> advisors;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (aspectNames.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以后进来读缓存</span></span><br><span class="line">    List&lt;Advisor&gt; advisors = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Advisor&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String aspectName : aspectNames) &#123;</span><br><span class="line">        List&lt;Advisor&gt; cachedAdvisors = <span class="built_in">this</span>.advisorsCache.get(aspectName);</span><br><span class="line">        <span class="keyword">if</span> (cachedAdvisors != <span class="literal">null</span>) &#123;</span><br><span class="line">            advisors.addAll(cachedAdvisors);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">MetadataAwareAspectInstanceFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="built_in">this</span>.aspectFactoryCache.get(aspectName);</span><br><span class="line">            advisors.addAll(<span class="built_in">this</span>.advisorFactory.getAdvisors(factory));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过 <code>beanFactory-&gt;beanPostProcessors-&gt;aspectJAdvisorsBuilder-&gt;advisorsCache</code> 观察 advisors 的查找情况。</p>
<img src="/2023/11/19/how-does-Spring-AOP-create-proxy-beans/Snipaste_2023-11-20_20-50-04.png" class="" title="观察 advisors">]]></content>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>aop</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 中的循环依赖</title>
    <url>/2023/11/22/circular-dependencies-in-Spring/</url>
    <content><![CDATA[<p><code>Spring</code> 中的循环依赖是一个“大名鼎鼎”的问题，本文从原始的问题出发分析应当如何正确地看待和处理循环依赖现象，同时也会回归到源码详细介绍 <code>Spring</code> 的具体处理过程，并在最后给出笔者的个人思考。</p>
<span id="more"></span>

<h2 id="循环依赖的介绍和讨论"><a href="#循环依赖的介绍和讨论" class="headerlink" title="循环依赖的介绍和讨论"></a>循环依赖的介绍和讨论</h2><h3 id="什么是循环依赖？"><a href="#什么是循环依赖？" class="headerlink" title="什么是循环依赖？"></a>什么是循环依赖？</h3><p>当 <code>Bean A</code> 依赖另一个 <code>Bean B</code>，<code>Bean B</code> 也依赖了 <code>Bean A</code>，我们就称之为循环依赖：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Bean A -&gt; Bean B -&gt; Bean A</span><br></pre></td></tr></table></figure>

<p>首先，我们应该将循环依赖和 “<code>Spring</code> 中的循环依赖问题”分开看待。循环依赖是一个正常的现象，一个 employee 依赖他的 department，department 拥有许多 employee。先实例化 employee 后实例化 department，然后先后为它们设置依赖，这样并不会发生什么问题。</p>
<h3 id="Spring-中的循环依赖问题"><a href="#Spring-中的循环依赖问题" class="headerlink" title="Spring 中的循环依赖问题"></a>Spring 中的循环依赖问题</h3><h4 id="常规的循环依赖问题"><a href="#常规的循环依赖问题" class="headerlink" title="常规的循环依赖问题"></a>常规的循环依赖问题</h4><p>当 <code>Spring</code> 加载所有的 <code>Bean</code> 时，会进行<strong>依赖注入</strong>处理。<code>Spring</code> 并不是先将所有的 <code>Bean</code> 实例化，再去进行依赖注入，而是实例化一个 <code>Bean</code> 后，立即对它进行依赖注入，为此它会递归地实例化 <code>Bean</code> 的依赖。仔细思考，即使在存在循环依赖问题的时候，以上的过程同样并不会产生什么大问题，在<strong>实例化和依赖注入分成两个阶段</strong>的情况下，你可以<strong>轻而易举地保存和获取已经实例化的 <code>Bean</code></strong> 。唯一的问题是，获取的已经实例化的 <code>Bean</code> 可能尚未初始化完毕（比如它的依赖尚未全部注入），那么你只需要确保它在初始化完毕前不被使用即可。<br>按照上述思路，你可以使用两个 <code>map</code>，一个保存已经初始化完毕、可以使用的完成品 <code>Bean</code>，一个保存尚未初始化完毕、不可以被使用的半成品 <code>Bean</code>。</p>
<blockquote>
<p>在一些资料中，你会看到有人特地强调如果只是解决常规的循环引用问题，那么只需要两个缓存。</p>
</blockquote>
<img src="/2023/11/22/circular-dependencies-in-Spring/Pasted%20image%2020231122210105.png" class="" title="循环引用-常规情况的解决方案">

<p>但是问题并不总是那么简单，如果实例化和依赖注入不能分为两个阶段，如果 B 依赖的不再是简单的 A 对象，而是 A 的代理，那么上述方案就不再适用了。</p>
<h4 id="构造器方法的循环依赖"><a href="#构造器方法的循环依赖" class="headerlink" title="构造器方法的循环依赖"></a>构造器方法的循环依赖</h4><p>如果 A 的构造器方法需要 B，B 的构造器方法需要 A，那么在 A 的实例化阶段就需要 B 的实例，B 的实例化阶段又需要 A，这就陷入了死循环。虽然我们常说 <code>Spring</code> 解决了循环依赖问题，但实际上，<code>Spring</code> 并没有解决所有情形的循环依赖问题。</p>
<ul>
<li>要应对构造器方法的循环依赖，需要人为地介入，使用 <code>@Lazy</code> 注解告诉 <code>Spring</code>，延迟 <code>Bean</code> 的初始化。在这时候，被标注的参数注入的不是一个立即创建的实例，而是一个代理对象。</li>
<li>此外，如果是 <code>prototype</code> 类型的 <code>Bean</code> 发生循环依赖，<code>Spring</code> 会抛出异常，因为每次都创建新的 <code>Bean</code> 必然会导致无限循环。</li>
</ul>
<h4 id="循环依赖中出现代理"><a href="#循环依赖中出现代理" class="headerlink" title="循环依赖中出现代理"></a>循环依赖中出现代理</h4><p><code>Spring</code> 鼎鼎大名的核心功能，除了 <code>IOC</code>，还有 <code>AOP</code>。在 <code>AOP</code> 的场景中，<code>Bean A</code> 的完成品不是简单的 A 对象，而是一个 A 的代理。这时候又该如何应对呢？似乎不能再简单地将保存的 A 的实例交给 B，否则 B 持有的就不是最终的 A 的代理。</p>
<p>如果你没有被 <code>Spring</code> 影响思路的话，其实并不难。既然需要 A 的代理，那么在获取 B 依赖的 A 时，直接根据已有的半成品 A 创建代理就好了。</p>
<h4 id="解决方案的思路小结"><a href="#解决方案的思路小结" class="headerlink" title="解决方案的思路小结"></a>解决方案的思路小结</h4><p>当我们脱离 <code>Spring</code> 的具体方案和代码讨论循环依赖问题，我们会发现解决的思路是简单、清晰和理所当然的。事实上 <code>Spring</code> 的解决方案也是如此，当然其中会有很多值得深思的细节。回顾循环依赖问题的解决思路，你会发现：</p>
<ol>
<li>循环依赖本身是普通的，一个手动可解决的问题</li>
<li><code>Spring</code> 依赖注入时，虽然 <code>Bean B</code> 依赖的 <code>Bean A</code> 尚未初始化完毕，但是已经实例化，可以用来赋值</li>
<li>在 <code>Spring AOP</code> 中，既然 <code>Bean B</code> 依赖的 <code>Bean A</code> 需要是 A 对象的代理，那么就在那时候创建代理，用来赋值即可</li>
</ol>
<h2 id="流程图和测试用例"><a href="#流程图和测试用例" class="headerlink" title="流程图和测试用例"></a>流程图和测试用例</h2><p>在开始之前我们先放一张循环引用的处理流程图，用于在后续分析过程中进行对照。</p>
<div style="width:70%;margin:auto"><img src="/2023/11/22/circular-dependencies-in-Spring/Pasted%20image%2020231122233750.png" class="" title="循环引用-流程图"></div>

<p>以下是测试用例的代码：</p>
<ul>
<li><code>CircularA</code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircularA</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CircularB circularB;</span><br><span class="line">    <span class="keyword">public</span> CircularB <span class="title function_">getCircularB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> circularB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCircularB</span><span class="params">(CircularB circularB)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.circularB = circularB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>CircularB</code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircularB</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CircularA circularA;</span><br><span class="line">    <span class="keyword">public</span> CircularA <span class="title function_">getCircularA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> circularA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCircularA</span><span class="params">(CircularA circularA)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.circularA = circularA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>circular-reference-test.xml</code><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;circularA&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.moralok.bean.CircularA&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;circularB&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;circularB&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;circularB&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.moralok.bean.CircularB&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;circularA&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;circularA&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>测试类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircularReferenceTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRegular</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;circular-reference-test.xml&quot;</span>);</span><br><span class="line">        <span class="type">CircularA</span> <span class="variable">circularA</span> <span class="operator">=</span> (CircularA) applicationContext.getBean(<span class="string">&quot;circularA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="第一次获取-circularA"><a href="#第一次获取-circularA" class="headerlink" title="第一次获取 circularA"></a>第一次获取 circularA</h2><p>调用 <code>doGetBean(circularA)</code> 方法第一次获取：</p>
<ol>
<li>从缓存中获取 <code>circularA</code>（先不看方法内的具体代码，在第一次进入该方法时，必定返回 <code>null</code>）</li>
<li>因缓存中不存在，就创建 <code>circularA</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> String name, <span class="keyword">final</span> Class&lt;T&gt; requiredType, <span class="keyword">final</span> Object[] args, <span class="type">boolean</span> typeCheckOnly)</span></span><br><span class="line">        <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="comment">// 尝试从缓存中获取 circularA，第一次结果必定为 null</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 再次从缓存中获取 circularA（双重校验），如果为 null，就创建</span></span><br><span class="line">    sharedInstance = getSingleton(beanName, <span class="keyword">new</span> <span class="title class_">ObjectFactory</span>&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="标记-bean-是否正在创建中"><a href="#标记-bean-是否正在创建中" class="headerlink" title="标记 bean 是否正在创建中"></a>标记 bean 是否正在创建中</h3><p>在真正创建 <code>circularA</code> 之前，会调用 <code>getSingleton(String, ObjectFactory)</code> 再次尝试从缓存中获取（构成双重校验），这个方法内部通过 <code>ObjectFactory</code> 调用创建 <code>Bean</code> 的方法，并且在一前一后分别添加和移除 “<code>Bean</code> 是否正在创建中”的标志。在后续 <code>circularB</code> 获取 <code>circularA</code> 时就是依据该标志判断 <code>circularA</code> 正在创建中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">isSingletonCurrentlyInCreation(beanName)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的“是否正在创建中”，并不是狭义地指一个 <code>Bean</code> 是否已经实例化，而是指一个 <code>Bean</code> 是否已经实例化和初始化。<code>circular A</code> 在初始化阶段，去获取 <code>circularB</code>，在 <code>circularB</code> 视角中，<code>circular A</code> 仍处于正在创建中。示意图如下。</p>
</blockquote>
<div style="width:70%;margin:auto"><img src="/2023/11/22/circular-dependencies-in-Spring/Pasted%20image%2020231122210026.png" class="" title="循环引用-是否正在创建中"></div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 标记为正在创建中</span></span><br><span class="line">    beforeSingletonCreation(beanName);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">newSingleton</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Bean</span></span><br><span class="line">        singletonObject = singletonFactory.getObject();</span><br><span class="line">        newSingleton = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 从正在创建中的集合移除</span></span><br><span class="line">    afterSingletonCreation(beanName);</span><br><span class="line">    <span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">        addSingleton(beanName, singletonObject);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建-circularA"><a href="#创建-circularA" class="headerlink" title="创建 circularA"></a>创建 circularA</h3><p><code>createBean</code> 方法被包装在 <code>ObjectFactory</code> 中。创建的工作分为两个部分：</p>
<ol>
<li>实例化 <code>circularA</code></li>
<li>初始化 <code>circularA</code><ul>
<li>对 <code>circularA</code> 进行依赖注入时：<code>getBean(circularB)</code></li>
</ul>
</li>
</ol>
<p>很重要的是，在实例化 <code>circularA</code> 之后，尚未进行初始化工作之前，如果 <code>circularA</code> <strong>满足早期暴露的条件</strong>，将会被包装为 <code>ObjectFactory</code> 缓存到 <code>singletonFactory</code>（三级缓存） 中。</p>
<p>值得注意的是：</p>
<ul>
<li>如果 <code>circularA</code> 最终不需要早期暴露，那么这个 <code>ObjectFactory</code> 是会被直接抛弃的</li>
<li>如果 <code>circularA</code> 需要早期暴露，即它依赖的 <code>circularB</code> 同时依赖它，到时候将调用 <code>getEarlyBeanReference</code> 方法获得 <code>circularA</code> 的<strong>早期 <code>Bean</code> 引用</strong>。</li>
</ul>
<blockquote>
<p>刚开始看 <code>ObjectFactory</code> 匿名类的用法可能有点不适应，可以多读几次，帮助理解 <code>getObject</code> 和 <code>getEarlyBeanReference</code> 的语义。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 实例化 bean</span></span><br><span class="line">    instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 如果单例允许提前暴露的话，就将实例包装为 ObjectFactory 保存在 map singletonFactories 中</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">            isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        addSingletonFactory(beanName, <span class="keyword">new</span> <span class="title class_">ObjectFactory</span>&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">                <span class="keyword">return</span> getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化 bean，对 bean 的属性进行依赖注入</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="keyword">if</span> (exposedObject != <span class="literal">null</span>) &#123;</span><br><span class="line">            exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="依赖注入时获取-circularB"><a href="#依赖注入时获取-circularB" class="headerlink" title="依赖注入时获取 circularB"></a>依赖注入时获取 circularB</h2><h3 id="填充-Bean-属性"><a href="#填充-Bean-属性" class="headerlink" title="填充 Bean 属性"></a>填充 Bean 属性</h3><p>填充 <code>Bean</code> 属性的 <code>populateBean</code> 方法很复杂，我们只关注对 <code>circularA</code> 的依赖注入将间接地调用 <code>getBean(circularB)</code> 进入获取 <code>circularB</code> 的过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, BeanWrapper bw)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 应用属性值</span></span><br><span class="line">    applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">applyPropertyValues</span><span class="params">(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 如果有必要解析 value</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">resolvedValue</span> <span class="operator">=</span> valueResolver.resolveValueIfNecessary(pv, originalValue);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    bw.setPropertyValues(<span class="keyword">new</span> <span class="title class_">MutablePropertyValues</span>(deepCopy));</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">resolveValueIfNecessary</span><span class="params">(Object argName, Object value)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 如果是 RuntimeBeanReference 类型，就解析引用</span></span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> RuntimeBeanReference) &#123;</span><br><span class="line">        <span class="type">RuntimeBeanReference</span> <span class="variable">ref</span> <span class="operator">=</span> (RuntimeBeanReference) value;</span><br><span class="line">        <span class="keyword">return</span> resolveReference(argName, ref);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">resolveReference</span><span class="params">(Object argName, RuntimeBeanReference ref)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 解析引用将调用 getBean</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="built_in">this</span>.beanFactory.getBean(refName);</span><br><span class="line">    <span class="built_in">this</span>.beanFactory.registerDependentBean(refName, <span class="built_in">this</span>.beanName);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取-circularB"><a href="#获取-circularB" class="headerlink" title="获取 circularB"></a>获取 circularB</h3><p><code>AbstractBeanFactory#doGetBean(circularB)</code> 获取 <code>circularB</code> 将经过和 <code>circularA</code> 一样的流程，进入 <code>populateBean(circularB)</code> 方法进行依赖注入，进而再次去获取 <code>circularA</code>。</p>
<h2 id="第二次获取-circularA"><a href="#第二次获取-circularA" class="headerlink" title="第二次获取 circularA"></a>第二次获取 circularA</h2><p>调用 <code>doGetBean(circularA)</code> 方法第二次获取 <code>circularA</code> 时，仍然先尝试从缓存中获取，这次将从缓存中得到先前创建的 <code>circularA</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> String name, <span class="keyword">final</span> Class&lt;T&gt; requiredType, <span class="keyword">final</span> Object[] args, <span class="type">boolean</span> typeCheckOnly)</span></span><br><span class="line">        <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 尝试从缓存中获取 circularA，结果不再为 null</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 <code>getSingleton</code> 方法正是在第一次获取 <code>circularA</code> 时我们跳过没有查看的方法。方法中代码的逻辑并不复杂，但是要理解为什么这么做，却需要回过头来反复品味和思考。这里也是经常被拿来说的“三级缓存”问题的核心。</p>
<h3 id="从缓存中获取-circularA"><a href="#从缓存中获取-circularA" class="headerlink" title="从缓存中获取 circularA"></a>从缓存中获取 circularA</h3><ol>
<li>先从 <code>singletonObjects</code>（一级缓存） 获取 <code>circularA</code>，不存在</li>
<li>判断 <code>circularA</code> 是正在创建中，从 <code>earlySingletonObjects</code>（二级缓存） 获取，仍然不存在</li>
<li><code>allowEarlyReference</code> 为真，从 <code>singletonFactories</code>（三级缓存） 获取 <code>ObjectFactory</code></li>
<li>调用 <code>getObject</code> 间接调用 <code>getEarlyBeanReference</code> 获得早期 <code>Bean</code> 引用</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="comment">// 如果 singletonObjects 中不存在，且 bean 正在创建过程中（满足）</span></span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">// 从 earlySingletonObjects 获取（不存在）</span></span><br><span class="line">            singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                <span class="comment">// 如果 earlySingletonObjects 中不存在，且允许早期引用，就从 singletonFactories 中获取</span></span><br><span class="line">                ObjectFactory&lt;?&gt; singletonFactory = <span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 间接调用 getEarlyBeanReference</span></span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    <span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                    <span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取早期-Bean-引用"><a href="#获取早期-Bean-引用" class="headerlink" title="获取早期 Bean 引用"></a>获取早期 Bean 引用</h3><p>请注意这次在调用 <code>getObject</code> 方法时，并不是直接返回 <code>Bean</code> 的实例，而是间接调用 <code>getEarlyBeanReference</code> 方法，顾名思义是获取早期 <code>Bean</code> 引用。处理逻辑是如果存在 <code>SmartInstantiationAwareBeanPostProcessor</code>，将使用这些后处理器处理以获得早期 <code>Bean</code> 引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">    <span class="keyword">if</span> (bean != <span class="literal">null</span> &amp;&amp; !mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="comment">// 如果存在 InstantiationAwareBeanPostProcessors</span></span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                <span class="comment">// 如果 bp 是 SmartInstantiationAwareBeanPostProcessor 类型</span></span><br><span class="line">                <span class="type">SmartInstantiationAwareBeanPostProcessor</span> <span class="variable">ibp</span> <span class="operator">=</span> (SmartInstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                <span class="comment">// 尝试创建代理</span></span><br><span class="line">                exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">                <span class="keyword">if</span> (exposedObject == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于创建代理的分析请参考<a href="/2023/11/19/how-does-Spring-AOP-create-proxy-beans/" title="Spring AOP 如何创建代理 beans">Spring AOP 如何创建代理 beans</a>。</p>
</blockquote>
<p>通过后处理器的 <code>getEarlyBeanReference</code> 方法获取早期 <code>Bean</code> 引用时，可能返回的就是 <code>circularA</code> 对象，但是如果 <code>circularA</code> 需要创建代理，就会在这时候为它创建代理，而在之后 <code>BeanPostProcessor</code> 处理时就不会再创建代理了。</p>
<p>以 <code>AbstractAutoProxyCreator</code> 为例，它是自动代理创建者的抽象类，同时实现了 <code>SmartInstantiationAwareBeanPostProcessor</code> 和 <code>BeanPostProcessor</code> 接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.earlyProxyReferences.contains(cacheKey)) &#123;</span><br><span class="line">        <span class="comment">// 添加到早期代理引用的缓存中，用于后续在常规创建代理阶段判断是否需要创建代理</span></span><br><span class="line">        <span class="built_in">this</span>.earlyProxyReferences.add(cacheKey);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如有必要，包装为代理</span></span><br><span class="line">    <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果已经在获取 <code>circularA</code> 的早期引用时就将其包装为代理，则不再创建代理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);</span><br><span class="line">        <span class="comment">// 判断早期代理引用中是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.earlyProxyReferences.contains(cacheKey)) &#123;</span><br><span class="line">            <span class="comment">// 如有必要，包装为代理</span></span><br><span class="line">            <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="再思-Spring-bean-的三级缓存"><a href="#再思-Spring-bean-的三级缓存" class="headerlink" title="再思 Spring bean 的三级缓存"></a>再思 Spring bean 的三级缓存</h2><h3 id="三级缓存-or-三个缓存"><a href="#三级缓存-or-三个缓存" class="headerlink" title="三级缓存 or 三个缓存"></a>三级缓存 or 三个缓存</h3><p>著名的“三级缓存”，实际上就是三个存放 <code>Bean</code> 的 <code>map</code>：</p>
<ul>
<li><code>singletonObjects</code></li>
<li><code>earlySingletonObjects</code></li>
<li><code>singletonFactories</code></li>
</ul>
<p>在很多网上的资料中，都称 <strong><code>Spring</code> 通过使用三级缓存的设计解决了循环引用问题</strong>。同时我也看到有人反思，这样翻译对学习者造成了很大的困扰，代码中并没有多级 <code>cache</code> 的意味，称之为“三个缓存”比“三级缓存”更合理也更容易理解。三个存放 <code>Bean</code> 的 <code>map</code> 事实上是相互独立的，甚至它们是互斥的，<strong>一个 Bean 在同一时间最多只能存在于其中一个 <code>map</code> 中</strong>。</p>
<p>对我个人而言，我对反对者的观点深有同感，如果我没有看过面经，即使我熟读并理解代码，我可能都无法回答 Spring 中的三级缓存是什么。甚至我会被三级缓存这个名词所震慑，在了解它之前在心里放大它的复杂性。<br>但是在不断阅读的过程中（可能也有已有记忆的加持），我也会感受到称之为“三级缓存”的合理性。这里的分级含义更多体现的是 Bean 的“晋升”过程。</p>
<h3 id="缓存中的添加和删除"><a href="#缓存中的添加和删除" class="headerlink" title="缓存中的添加和删除"></a>缓存中的添加和删除</h3><p>网上很多资料在讨论 <code>Bean</code> 在缓存中的添加和删除时，大多一笔带过，并没有谈到细节。但是 <code>Bean</code> 并不是在这三个缓存中依次晋级，甚至有时候，添加和移除的都不是一个对象，比如三级缓存中的 <code>ObjectFactory</code> 可能被直接抛弃。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line">    <span class="comment">// 实例化</span></span><br><span class="line">    instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例+允许循环引用+当前正在被创建=可能需要提前暴露</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">            isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        addSingletonFactory(beanName, <span class="keyword">new</span> <span class="title class_">ObjectFactory</span>&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">                <span class="keyword">return</span> getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这里面会进行依赖注入</span></span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="keyword">if</span> (exposedObject != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里面会尝试创建代理</span></span><br><span class="line">            exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="comment">// 如果允许早期暴露，尝试获取早期 Bean 引用</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">earlySingletonReference</span> <span class="operator">=</span> getSingleton(beanName, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 如果为 null 说明没有早期暴露，返回的其实还是最初的 exposedObject</span></span><br><span class="line">        <span class="comment">// 三级缓存里的 ObjectFactory 完全没用上，会在 exposedObject 添加到一级缓存时直接删除</span></span><br><span class="line">        <span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果不为 null，说明确实早期暴露过</span></span><br><span class="line">            <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">                <span class="comment">// 如果早期暴露过，常规情况下，exposedObject 不会再创建代理，应 == bean</span></span><br><span class="line">                <span class="comment">// 如果没有代理，exposedObject == bean == earlySingletonReference</span></span><br><span class="line">                <span class="comment">// 如果创建过代理，earlySingletonReference 才是包装过的代理</span></span><br><span class="line">                exposedObject = earlySingletonReference;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">                <span class="comment">// 如果 exposedObject 在 initializeBean 中再次被创建代理</span></span><br><span class="line">                <span class="comment">// 但是存在 Bean 依赖了这个 Bean（由于拿到的是早期引用），它们拿到的和最终的是不同的对象</span></span><br><span class="line">                <span class="comment">// 如果不允许尽管会被包装仍然注入原始类型，就需要抛出异常</span></span><br><span class="line">                String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">                Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;String&gt;(dependentBeans.length);</span><br><span class="line">                <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                        actualDependentBeans.add(dependentBean);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// 抛异常</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在无需早期暴露的情况下，二级缓存没有用到，虽然三级缓存中保存了一个 <code>ObjectFactory</code>，但是也是没有用到的。<code>Bean</code> 直接保存到一级缓存中。</li>
<li>在需要早期暴露但无需代理的情况下，尽管获取早期引用后保存在二级缓存中，以供重复使用，但是二级缓存中和原始的 <code>Bean</code> 仍然是同一个对象，<code>Bean</code> 仍然是直接保存到一级缓存，再删掉二级缓存。</li>
<li>在需要早期暴露和需要代理的情况下，二级缓存中保存的是代理对象，需要从二级缓存中获取再保存到一级缓存中，然后再删除二级缓存。</li>
</ul>
<img src="/2023/11/22/circular-dependencies-in-Spring/Pasted%20image%2020231123013242.png" class="" title="循环引用-三级缓存添加和删除">

<h3 id="必须要三个缓存吗"><a href="#必须要三个缓存吗" class="headerlink" title="必须要三个缓存吗"></a>必须要三个缓存吗</h3><p>网上有很多资料在分析为什么需要三个缓存，才能解决在需要创建代理的情况下发生的循环依赖问题。但是个人觉得有些分析缺乏逻辑，也有点违和感。将当前的解决方案套到只有两个缓存的情况下去分析不太合理，就像你把四轮机动车卸掉一个轮子，说机动车必须要四个轮子才可以，不然不平衡，事实上三个轮子的机动车设计是存在且可行的。</p>
<p>在分析两个缓存如何解决在需要创建代理的情况下发生的循环依赖问题时，应该抛开现有的处理逻辑，回归本质问题：既然 <code>circularA</code> 需要创建代理，如果 <code>circularA</code> 依赖的 <code>circularB</code> 也依赖了 <code>circular A</code>，在为它获取依赖 <code>circularA</code> 时立即创建代理即可。<br>一个 <code>map</code> 必须用于存放完成品，另一个 <code>map</code> 用于存放半成品。创建的代理作为升级版的半成品，完全可以覆盖原始的半成品继续存放在第二个 <code>map</code> 中。为了避免重复创建代理，只要能够标识半成品是已经经过代理包装的即可。<code>BeanDefinition</code>、<code>Bean</code> 自身、创建代理的地方，都有能力实现标识一个 <code>Bean</code> 的半成品是否经过包装，最不济使用一个 <code>map</code> 存放标识（但是这也就等同于使用三个 <code>map</code> 了）。你甚至可以将半成品 <code>circularA</code> 直接尝试包装成代理再存放入半成品 <code>map</code> 中，这个方案本质上是将创建代理的步骤从初始化 <code>Bean</code> 中分离到初始化 <code>Bean</code> 之前。</p>
<p>综上，使用两个 <code>map</code> 解决在技术上是没有问题的，很多分析中考虑的问题相当于把 <code>Spring</code> 现有的处理逻辑当成枷锁限制了自己。既然你都在问不这么打地基可不可以，我难道不得考虑挪一挪上面的砖墙吗？当然我不能保证这么设计不会破坏 <code>Spring</code> 现有全部功能的兼容性和扩展性，但是这并不是代理为循环依赖引入的问题。</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo SPI 的工作原理</title>
    <url>/2023/11/28/how-does-Dubbo-SPI-works/</url>
    <content><![CDATA[<p><code>SPI</code> 作为一种服务发现机制，允许程序在运行时动态地加载具体实现类。因其强大的可拓展性，<code>SPI</code> 被广泛应用于各类技术框架中，例如 <code>JDBC</code> 驱动、<code>Spring</code> 和 <code>Dubbo</code> 等等。<code>Dubbo</code> 并未使用原生的 <code>Java SPI</code>，而是重新实现了一套更加强大的 <strong><code>Dubbo SPI</code><strong>。本文将简单介绍 <code>SPI</code> 的设计理念，通过示例带你体会 <code>SPI</code> 的作用，通过 <strong><code>Dubbo</code> 获取拓展的流程图</strong>和</strong>源码分析</strong>带你理解 <code>Dubbo SPI</code> 的工作原理。深入了解 <code>Dubbo SPI</code>，你将能更好地利用这一机制为你的程序提供灵活的拓展功能。</p>
<span id="more"></span>

<h2 id="SPI-简介"><a href="#SPI-简介" class="headerlink" title="SPI 简介"></a>SPI 简介</h2><p><code>SPI</code> 的全称是 <code>Service Provider Interface</code>，是一种服务发现机制。一般情况下，一项服务的接口和具体实现，都是服务提供者编写的。在 <code>SPI</code> 机制中，一项服务的接口是服务使用者编写的，不同的服务提供者编写不同的具体实现。在程序运行时，服务加载器动态地为接口加载具体实现类。因为 <code>SPI</code> 具备“动态加载”的特性，我们很容易通过它为程序提供拓展功能。以 <code>Java</code> 的 <code>JDBC</code> 驱动为例，JDK 提供了 <code>java.sql.Driver</code> 接口，各个数据库厂商，例如 <code>MySQL</code>、<code>Oracle</code> 提供具体的实现。</p>
<img src="/2023/11/28/how-does-Dubbo-SPI-works/Pasted%20image%2020231129010505.png" class="" title="SPI 机制">

<p>目前 <strong>SPI 的实现方式</strong>大多是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类：</p>
<ul>
<li>Java SPI：<code>META-INF/services/full.qualified.interface.name</code></li>
<li>Dubbo SPI：<code>META-INF/dubbo/full.qualified.interface.name</code>（还有其他目录可供选择）</li>
<li>Spring SPI: <code>META-INF/spring.factories</code></li>
</ul>
<h2 id="SPI-示例"><a href="#SPI-示例" class="headerlink" title="SPI 示例"></a>SPI 示例</h2><h3 id="Java-SPI-示例"><a href="#Java-SPI-示例" class="headerlink" title="Java SPI 示例"></a>Java SPI 示例</h3><p>定义一个接口 <code>Animal</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义两个实现类 <code>Dog</code> 和 <code>Cat</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog bark...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cat bark...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <strong><code>META-INF/services</code></strong> 文件夹下创建一个文件，名称为 <code>Animal</code> 的全限定名 <code>com.moralok.dubbo.spi.test.Animal</code>，文件内容为实现类的全限定名，实现类的全限定名之间用换行符分隔。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com.moralok.dubbo.spi.test.Dog</span><br><span class="line">com.moralok.dubbo.spi.test.Cat</span><br></pre></td></tr></table></figure>

<p>进行测试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaSPITest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Java SPI&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;============&quot;</span>);</span><br><span class="line">        ServiceLoader&lt;Animal&gt; serviceLoader = ServiceLoader.load(Animal.class);</span><br><span class="line">        serviceLoader.forEach(Animal::bark);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Java SPI</span><br><span class="line">============</span><br><span class="line">Dog bark...</span><br><span class="line">Cat bark...</span><br></pre></td></tr></table></figure>

<h3 id="Dubbo-SPI-示例"><a href="#Dubbo-SPI-示例" class="headerlink" title="Dubbo SPI 示例"></a>Dubbo SPI 示例</h3><p><code>Dubbo</code> 并未使用原生的 <code>Java SPI</code>，而是重新实现了一套功能更加强大的 <code>SPI</code> 机制。<code>Dubbo SPI</code> 的配置文件放在 <strong><code>META-INF/dubbo</code></strong> 文件夹下，名称仍然是接口的全限定名，但是内容是“名称-&gt;实现类的全限定名”的键值对，另外接口需要标注 <code>SPI</code> 注解。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dog = com.moralok.dubbo.spi.test.Dog</span><br><span class="line">cat = com.moralok.dubbo.spi.test.Cat</span><br></pre></td></tr></table></figure>

<p>进行测试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DubboSPITest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dubbo SPI&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;============&quot;</span>);</span><br><span class="line">        ExtensionLoader&lt;Animal&gt; extensionLoader = ExtensionLoader.getExtensionLoader(Animal.class);</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">dog</span> <span class="operator">=</span> extensionLoader.getExtension(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">        dog.bark();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">cat</span> <span class="operator">=</span> extensionLoader.getExtension(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">        cat.bark();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Dubbo SPI</span><br><span class="line">============</span><br><span class="line">Dog bark...</span><br><span class="line">Cat bark...</span><br></pre></td></tr></table></figure>

<h2 id="Dubbo-获取扩展流程图"><a href="#Dubbo-获取扩展流程图" class="headerlink" title="Dubbo 获取扩展流程图"></a>Dubbo 获取扩展流程图</h2><img src="/2023/11/28/how-does-Dubbo-SPI-works/Pasted%20image%2020231129204920.png" class="" title="Dubbo 获取扩展流程图">

<h2 id="Dubbo-SPI-源码分析"><a href="#Dubbo-SPI-源码分析" class="headerlink" title="Dubbo SPI 源码分析"></a>Dubbo SPI 源码分析</h2><h3 id="获取-ExtensionLoader"><a href="#获取-ExtensionLoader" class="headerlink" title="获取 ExtensionLoader"></a>获取 ExtensionLoader</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt; EXTENSION_LOADERS = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ExtensionLoader&lt;T&gt; <span class="title function_">getExtensionLoader</span><span class="params">(Class&lt;T&gt; type)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Extension type == null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!type.isInterface()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Extension type (&quot;</span> + type + <span class="string">&quot;) is not an interface!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!withExtensionAnnotation(type)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Extension type (&quot;</span> + type +</span><br><span class="line">                <span class="string">&quot;) is not an extension, because it is NOT annotated with @&quot;</span> + SPI.class.getSimpleName() + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从缓存中获取，如果缓存未命中，则创建，保存到缓存并返回</span></span><br><span class="line">    ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">    <span class="keyword">if</span> (loader == <span class="literal">null</span>) &#123;</span><br><span class="line">        EXTENSION_LOADERS.putIfAbsent(type, <span class="keyword">new</span> <span class="title class_">ExtensionLoader</span>&lt;T&gt;(type));</span><br><span class="line">        loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法包含了如下步骤：</p>
<ol>
<li>参数校验。</li>
<li>从缓存 <code>EXTENSION_LOADERS</code> 中获取与拓展类对应的 <code>ExtensionLoader</code>，如果缓存未命中，则创建一个新的实例，保存到缓存并返回。</li>
</ol>
<blockquote>
<p>“<strong>从缓存中获取，如果缓存未命中，则创建，保存到缓存并返回</strong>”，类似的 <code>getOrCreate</code> 的处理模式在 <code>Dubbo</code> 的源码中经常出现。</p>
</blockquote>
<p><code>EXTENSION_LOADERS</code> 是 <code>ExtensionLoader</code> 的静态变量，保存了“拓展类-&gt;<code>ExtensionLoader</code>”的映射关系。</p>
<h3 id="根据-name-获取-Extension"><a href="#根据-name-获取-Extension" class="headerlink" title="根据 name 获取 Extension"></a>根据 name 获取 Extension</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">getExtension</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getExtension(name, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">getExtension</span><span class="params">(String name, <span class="type">boolean</span> wrap)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(name)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Extension name == null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;true&quot;</span>.equals(name)) &#123;</span><br><span class="line">        <span class="comment">// 获取默认的拓展实现</span></span><br><span class="line">        <span class="keyword">return</span> getDefaultExtension();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Holder，用于持有目标对象</span></span><br><span class="line">    <span class="keyword">final</span> Holder&lt;Object&gt; holder = getOrCreateHolder(name);</span><br><span class="line">    <span class="comment">// 双重检查</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> holder.get();</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (holder) &#123;</span><br><span class="line">            instance = holder.get();</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 创建拓展实例，设置到 holder 中。</span></span><br><span class="line">                instance = createExtension(name, wrap);</span><br><span class="line">                holder.set(instance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, Holder&lt;Object&gt;&gt; cachedInstances = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Holder&lt;Object&gt; <span class="title function_">getOrCreateHolder</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    Holder&lt;Object&gt; holder = cachedInstances.get(name);</span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="literal">null</span>) &#123;</span><br><span class="line">        cachedInstances.putIfAbsent(name, <span class="keyword">new</span> <span class="title class_">Holder</span>&lt;&gt;());</span><br><span class="line">        holder = cachedInstances.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> holder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法中获取 <code>Holder</code> 和获取拓展实例都是使用 <code>getOrCreate</code> 的模式。</p>
<p><code>Holder</code> 用于持有拓展实例。<code>cachedInstances</code> 是 <code>ExtensionLoader</code> 的成员变量，保存了“<code>name-&gt;Holder</code>(拓展实例)”的映射关系。</p>
<h3 id="创建-Extension"><a href="#创建-Extension" class="headerlink" title="创建 Extension"></a>创建 Extension</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> T <span class="title function_">createExtension</span><span class="params">(String name, <span class="type">boolean</span> wrap)</span> &#123;</span><br><span class="line">    <span class="comment">// 从配置文件中加载所有的拓展类，可得到“name-&gt;拓展实现类”的映射关系表</span></span><br><span class="line">    Class&lt;?&gt; clazz = getExtensionClasses().get(name);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="literal">null</span> || unacceptableExceptions.contains(name)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> findException(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 getOrCreate 模式获取拓展实例</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">instance</span> <span class="operator">=</span> (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.getDeclaredConstructor().newInstance());</span><br><span class="line">            instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 向拓展实例中注入依赖</span></span><br><span class="line">        injectExtension(instance);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否包装默认为 true</span></span><br><span class="line">        <span class="keyword">if</span> (wrap) &#123;</span><br><span class="line"></span><br><span class="line">            List&lt;Class&lt;?&gt;&gt; wrapperClassesList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">if</span> (cachedWrapperClasses != <span class="literal">null</span>) &#123;</span><br><span class="line">                wrapperClassesList.addAll(cachedWrapperClasses);</span><br><span class="line">                wrapperClassesList.sort(WrapperComparator.COMPARATOR);</span><br><span class="line">                Collections.reverse(wrapperClassesList);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isNotEmpty(wrapperClassesList)) &#123;</span><br><span class="line">                <span class="comment">// 遍历包装类</span></span><br><span class="line">                <span class="keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClassesList) &#123;</span><br><span class="line">                    <span class="type">Wrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> wrapperClass.getAnnotation(Wrapper.class);</span><br><span class="line">                    <span class="comment">// 区别于旧版本：支持使用 Wrapper 注解进行匹配</span></span><br><span class="line">                    <span class="keyword">if</span> (wrapper == <span class="literal">null</span></span><br><span class="line">                            || (ArrayUtils.contains(wrapper.matches(), name) &amp;&amp; !ArrayUtils.contains(wrapper.mismatches(), name))) &#123;</span><br><span class="line">                        <span class="comment">// 如果有匹配的包装类，包装拓展实例</span></span><br><span class="line">                        instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化拓展实例</span></span><br><span class="line">        initExtension(instance);</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Extension instance (name: &quot;</span> + name + <span class="string">&quot;, class: &quot;</span> +</span><br><span class="line">                type + <span class="string">&quot;) couldn&#x27;t be instantiated: &quot;</span> + t.getMessage(), t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法包含如下步骤：</p>
<ol>
<li>通过 <code>getExtensionClasses</code> 获取所有拓展类</li>
<li>通过反射创建拓展实例</li>
<li>向拓展实例中注入依赖</li>
<li>将拓展实例包装在适配的 <code>Wrapper</code> 对象中</li>
<li>初始化拓展实例</li>
</ol>
<p>第一步是加载拓展类的关键，第三步和第四步是 <strong><code>Dubbo IOC</code></strong> 和 <strong><code>AOP</code></strong> 的具体实现。</p>
<p>最后拓展实例的结构如下图。</p>
<img src="/2023/11/28/how-does-Dubbo-SPI-works/Pasted%20image%2020231129024723.png" class="" title="拓展实例被包装后的结构图">

<h3 id="加载-Extension-Class"><a href="#加载-Extension-Class" class="headerlink" title="加载 Extension Class"></a>加载 Extension Class</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() &#123;</span><br><span class="line">    <span class="comment">// 使用 getOrCreate 模式获取所有拓展类</span></span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();</span><br><span class="line">    <span class="keyword">if</span> (classes == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (cachedClasses) &#123;</span><br><span class="line">            classes = cachedClasses.get();</span><br><span class="line">            <span class="keyword">if</span> (classes == <span class="literal">null</span>) &#123;</span><br><span class="line">                classes = loadExtensionClasses();</span><br><span class="line">                cachedClasses.set(classes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> classes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() &#123;</span><br><span class="line">    <span class="comment">// 1. 缓存默认拓展名</span></span><br><span class="line">    cacheDefaultExtensionName();</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历加载策略，加载各个策略的目录下的配置文件，获取拓展类</span></span><br><span class="line">    <span class="keyword">for</span> (LoadingStrategy strategy : strategies) &#123;</span><br><span class="line">        loadDirectory(extensionClasses, strategy.directory(), type.getName(), strategy.preferExtensionClassLoader(),</span><br><span class="line">                strategy.overridden(), strategy.excludedPackages());</span><br><span class="line">        loadDirectory(extensionClasses, strategy.directory(), type.getName().replace(<span class="string">&quot;org.apache&quot;</span>, <span class="string">&quot;com.alibaba&quot;</span>),</span><br><span class="line">                strategy.preferExtensionClassLoader(), strategy.overridden(), strategy.excludedPackages());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> extensionClasses;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果存在默认拓展名，提取并缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cacheDefaultExtensionName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取 SPI 注解</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">SPI</span> <span class="variable">defaultAnnotation</span> <span class="operator">=</span> type.getAnnotation(SPI.class);</span><br><span class="line">    <span class="keyword">if</span> (defaultAnnotation == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> defaultAnnotation.value();</span><br><span class="line">    <span class="keyword">if</span> ((value = value.trim()).length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 对 SPI 的 value 内容进行切分</span></span><br><span class="line">        String[] names = NAME_SEPARATOR.split(value);</span><br><span class="line">        <span class="comment">// 检测 name 是否合法</span></span><br><span class="line">        <span class="keyword">if</span> (names.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;More than 1 default extension name on extension &quot;</span> + type.getName()</span><br><span class="line">                    + <span class="string">&quot;: &quot;</span> + Arrays.toString(names));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (names.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 缓存默认拓展名，用于 getDefaultExtension</span></span><br><span class="line">            cachedDefaultName = names[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="依次处理特定目录"><a href="#依次处理特定目录" class="headerlink" title="依次处理特定目录"></a>依次处理特定目录</h4><p>代码参考旧版本更容易理解。处理过程在本质上就是依次加载 <code>META-INF/dubbo/internal/</code>、<code>META-INF/dubbo/</code>、<code>META-INF/services/</code> 三个目录下的配置文件，获取拓展类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY);</span><br><span class="line">loadDirectory(extensionClasses, DUBBO_DIRECTORY);</span><br><span class="line">loadDirectory(extensionClasses, SERVICES_DIRECTORY);</span><br></pre></td></tr></table></figure>

<p>新版本使用原生的 <code>Java SPI</code> 加载 <code>LoadingStrategy</code>，允许用户自定义加载策略。</p>
<ol>
<li><code>DubboInternalLoadingStrategy</code>，目录 <code>META-INF/dubbo/internal/</code>，优先级最高</li>
<li><code>DubboLoadingStrategy</code>，目录 <code>META-INF/dubbo/</code>，优先级普通</li>
<li><code>ServicesLoadingStrategy</code>，目录 <code>META-INF/services/</code>，优先级最低</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LoadingStrategy[] strategies = loadLoadingStrategies();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> LoadingStrategy[] loadLoadingStrategies() &#123;</span><br><span class="line">    <span class="comment">// 通过 Java SPI 加载 LoadingStrategy </span></span><br><span class="line">    <span class="keyword">return</span> stream(load(LoadingStrategy.class).spliterator(), <span class="literal">false</span>)</span><br><span class="line">            .sorted()</span><br><span class="line">            .toArray(LoadingStrategy[]::<span class="keyword">new</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>LoadingStrategy</code> 的 <code>Java SPI</code> 配置文件</p>
<img src="/2023/11/28/how-does-Dubbo-SPI-works/Snipaste_2023-11-29_03-25-54.png" class="" title="LoadingStrategy 的 Java SPI 配置文件">

<h4 id="loadDirectory-方法"><a href="#loadDirectory-方法" class="headerlink" title="loadDirectory 方法"></a>loadDirectory 方法</h4><p><code>loadDirectory</code> 方法先通过 <code>classLoader</code> 获取所有的资源链接，然后再通过 <code>loadResource</code> 方法加载资源。</p>
<p>新版本中 <code>extensionLoaderClassLoaderFirst</code> 可以设置是否优先使用 <code>ExtensionLoader&#39;s ClassLoader</code> 获取资源链接。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadDirectory</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, String dir, String type,</span></span><br><span class="line"><span class="params">                            <span class="type">boolean</span> extensionLoaderClassLoaderFirst, <span class="type">boolean</span> overridden, String... excludedPackages)</span> &#123;</span><br><span class="line">    <span class="comment">// filename = 文件夹路径 + type 的全限定名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> dir + type;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Enumeration&lt;java.net.URL&gt; urls = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> findClassLoader();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 区别于旧版本：先从 ExtensionLoader&#x27;s ClassLoader 获取资源链接，默认为 false</span></span><br><span class="line">        <span class="keyword">if</span> (extensionLoaderClassLoaderFirst) &#123;</span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">extensionLoaderClassLoader</span> <span class="operator">=</span> ExtensionLoader.class.getClassLoader();</span><br><span class="line">            <span class="keyword">if</span> (ClassLoader.getSystemClassLoader() != extensionLoaderClassLoader) &#123;</span><br><span class="line">                urls = extensionLoaderClassLoader.getResources(fileName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据文件名加载所有同名文件</span></span><br><span class="line">        <span class="keyword">if</span> (urls == <span class="literal">null</span> || !urls.hasMoreElements()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (classLoader != <span class="literal">null</span>) &#123;</span><br><span class="line">                urls = classLoader.getResources(fileName);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                urls = ClassLoader.getSystemResources(fileName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (urls != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">                java.net.<span class="type">URL</span> <span class="variable">resourceURL</span> <span class="operator">=</span> urls.nextElement();</span><br><span class="line">                <span class="comment">// 加载资源</span></span><br><span class="line">                loadResource(extensionClasses, classLoader, resourceURL, overridden, excludedPackages);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Exception occurred when loading extension class (interface: &quot;</span> +</span><br><span class="line">                type + <span class="string">&quot;, description file: &quot;</span> + fileName + <span class="string">&quot;).&quot;</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="loadResource-方法"><a href="#loadResource-方法" class="headerlink" title="loadResource 方法"></a>loadResource 方法</h4><p><code>loadResource</code> 方法用于读取和解析配置文件，并通过反射加载类，最后调用 <code>loadClass</code> 方法进行其他操作。<code>loadClass</code> 方法用于操作缓存。</p>
<p>新版本中 <code>excludedPackages</code> 可以设置将指定包内的类都排除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadResource</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, ClassLoader classLoader,</span></span><br><span class="line"><span class="params">                            java.net.URL resourceURL, <span class="type">boolean</span> overridden, String... excludedPackages)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(resourceURL.openStream(), StandardCharsets.UTF_8))) &#123;</span><br><span class="line">            String line;</span><br><span class="line">            <span class="type">String</span> <span class="variable">clazz</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 按行读取配置内容</span></span><br><span class="line">            <span class="keyword">while</span> ((line = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 定位 # 字符，截取 # 字符之前的内容，# 字符之后的内容为注释，需要忽略</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ci</span> <span class="operator">=</span> line.indexOf(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span> (ci &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    line = line.substring(<span class="number">0</span>, ci);</span><br><span class="line">                &#125;</span><br><span class="line">                line = line.trim();</span><br><span class="line">                <span class="keyword">if</span> (line.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                        <span class="comment">// 定位 = 字符，以 = 字符为界，截取键值对</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> line.indexOf(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">                        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            name = line.substring(<span class="number">0</span>, i).trim();</span><br><span class="line">                            clazz = line.substring(i + <span class="number">1</span>).trim();</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            clazz = line;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (StringUtils.isNotEmpty(clazz) &amp;&amp; !isExcluded(clazz, excludedPackages)) &#123;</span><br><span class="line">                            <span class="comment">// 加载类，并通过 loadClass 进行缓存</span></span><br><span class="line">                            <span class="comment">// 区别于旧版本：根据 excludedPackages 判断是否排除</span></span><br><span class="line">                            loadClass(extensionClasses, resourceURL, Class.forName(clazz, <span class="literal">true</span>, classLoader), name, overridden);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                        <span class="type">IllegalStateException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                                <span class="string">&quot;Failed to load extension class (interface: &quot;</span> + type + <span class="string">&quot;, class line: &quot;</span> + line + <span class="string">&quot;) in &quot;</span> + resourceURL +</span><br><span class="line">                                        <span class="string">&quot;, cause: &quot;</span> + t.getMessage(), t);</span><br><span class="line">                        exceptions.put(line, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Exception occurred when loading extension class (interface: &quot;</span> +</span><br><span class="line">                type + <span class="string">&quot;, class file: &quot;</span> + resourceURL + <span class="string">&quot;) in &quot;</span> + resourceURL, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="loadClass-方法"><a href="#loadClass-方法" class="headerlink" title="loadClass 方法"></a>loadClass 方法</h4><p><code>loadClass</code> 方法设置了多个缓存，比如 <code>cachedAdaptiveClass</code>、<code>cachedWrapperClasses</code>、<code>cachedNames</code> 和 <code>cachedClasses</code>。</p>
<p>新版本中 <code>overridden</code> 可以设置是否覆盖 <code>cachedAdaptiveClass</code>、<code>cachedClasses</code> 的 <code>name-&gt;clazz</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadClass</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, java.net.URL resourceURL, Class&lt;?&gt; clazz, String name,</span></span><br><span class="line"><span class="params">                        <span class="type">boolean</span> overridden)</span> <span class="keyword">throws</span> NoSuchMethodException &#123;</span><br><span class="line">    <span class="comment">// 检测 clazz 是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (!type.isAssignableFrom(clazz)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Error occurred when loading extension class (interface: &quot;</span> +</span><br><span class="line">                type + <span class="string">&quot;, class line: &quot;</span> + clazz.getName() + <span class="string">&quot;), class &quot;</span></span><br><span class="line">                + clazz.getName() + <span class="string">&quot; is not subtype of interface.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (clazz.isAnnotationPresent(Adaptive.class)) &#123;</span><br><span class="line">        <span class="comment">// 检测 clazz 是否有 Adaptive 注解，有则设置 cachedAdaptiveClass 缓存</span></span><br><span class="line">        <span class="comment">// 区别于旧版本：根据 overriden 判断是否可覆盖</span></span><br><span class="line">        cacheAdaptiveClass(clazz, overridden);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isWrapperClass(clazz)) &#123;</span><br><span class="line">        <span class="comment">// 检测 clazz 是否是 Wrapper 类型，是则添加到 cachedWrapperClasses 缓存</span></span><br><span class="line">        cacheWrapperClass(clazz);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 检测 clazz 是否有默认的构造器方法，如果没有，则抛出异常</span></span><br><span class="line">        clazz.getConstructor();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(name)) &#123;</span><br><span class="line">            <span class="comment">// 如果 name 为空，则尝试从 Extension 注解中获取 name，或者使用小写的类名（可能截取 type 后缀）作为 name</span></span><br><span class="line">            name = findAnnotationName(clazz);</span><br><span class="line">            <span class="keyword">if</span> (name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                        <span class="string">&quot;No such extension name for the class &quot;</span> + clazz.getName() + <span class="string">&quot; in the config &quot;</span> + resourceURL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 切分 name</span></span><br><span class="line">        String[] names = NAME_SEPARATOR.split(name);</span><br><span class="line">        <span class="keyword">if</span> (ArrayUtils.isNotEmpty(names)) &#123;</span><br><span class="line">            <span class="comment">// 如果 clazz 有 Activate 注解，则缓存 names[0]-&gt;Activate 的映射关系</span></span><br><span class="line">            cacheActivateClass(clazz, names[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">for</span> (String n : names) &#123;</span><br><span class="line">                <span class="comment">// 缓存 clazz-&gt;n 的映射关系</span></span><br><span class="line">                cacheName(clazz, n);</span><br><span class="line">                <span class="comment">// 缓存 n-&gt;clazz 的映射关系，传递到最后，终于轮到 extensionClasses</span></span><br><span class="line">                <span class="comment">// 区别于旧版本：根据 overriden 判断是否可覆盖</span></span><br><span class="line">                saveInExtensionClass(extensionClasses, clazz, n, overridden);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cacheAdaptiveClass</span><span class="params">(Class&lt;?&gt; clazz, <span class="type">boolean</span> overridden)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cachedAdaptiveClass == <span class="literal">null</span> || overridden) &#123;</span><br><span class="line">        <span class="comment">// 可以设置是否覆盖</span></span><br><span class="line">        cachedAdaptiveClass = clazz;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!cachedAdaptiveClass.equals(clazz)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;More than 1 adaptive class found: &quot;</span></span><br><span class="line">                + cachedAdaptiveClass.getName()</span><br><span class="line">                + <span class="string">&quot;, &quot;</span> + clazz.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cacheWrapperClass</span><span class="params">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cachedWrapperClasses == <span class="literal">null</span>) &#123;</span><br><span class="line">        cachedWrapperClasses = <span class="keyword">new</span> <span class="title class_">ConcurrentHashSet</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    cachedWrapperClasses.add(clazz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cacheActivateClass</span><span class="params">(Class&lt;?&gt; clazz, String name)</span> &#123;</span><br><span class="line">    <span class="type">Activate</span> <span class="variable">activate</span> <span class="operator">=</span> clazz.getAnnotation(Activate.class);</span><br><span class="line">    <span class="keyword">if</span> (activate != <span class="literal">null</span>) &#123;</span><br><span class="line">        cachedActivates.put(name, activate);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// support com.alibaba.dubbo.common.extension.Activate</span></span><br><span class="line">        com.alibaba.dubbo.common.extension.<span class="type">Activate</span> <span class="variable">oldActivate</span> <span class="operator">=</span></span><br><span class="line">                clazz.getAnnotation(com.alibaba.dubbo.common.extension.Activate.class);</span><br><span class="line">        <span class="keyword">if</span> (oldActivate != <span class="literal">null</span>) &#123;</span><br><span class="line">            cachedActivates.put(name, oldActivate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Dubbo-IOC"><a href="#Dubbo-IOC" class="headerlink" title="Dubbo IOC"></a>Dubbo IOC</h3><p><code>Dubbo IOC</code> 是通过 <code>setter</code> 方法注入依赖。<code>Dubbo</code> 首先通过反射获取目标类的所有方法，然后遍历方法列表，检测方法名是否具有 <code>setter</code> 方法特征并满足条件，若有，则通过 <code>objectFactory</code> 获取依赖对象，最后通过反射调用 <code>setter</code> 方法将依赖设置到目标对象中。</p>
<blockquote>
<p>与 <code>Spring IOC</code> 相比，<code>Dubbo IOC</code> 实现的依赖注入功能更加简单，代码也更加容易理解。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> T <span class="title function_">injectExtension</span><span class="params">(T instance)</span> &#123;</span><br><span class="line">    <span class="comment">// 检测是否有 objectFactory</span></span><br><span class="line">    <span class="keyword">if</span> (objectFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历目标类的所有方法</span></span><br><span class="line">        <span class="comment">// 区别于旧版本：增加了对 DisbaleInject、Inject 注解的处理</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : instance.getClass().getMethods()) &#123;</span><br><span class="line">            <span class="comment">// 检测是否是 setter 方法</span></span><br><span class="line">            <span class="keyword">if</span> (!isSetter(method)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检测是否标注 DisableInject 注解</span></span><br><span class="line">            <span class="keyword">if</span> (method.getAnnotation(DisableInject.class) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检测参数类型是否是原始类型</span></span><br><span class="line">            Class&lt;?&gt; pt = method.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (ReflectUtils.isPrimitives(pt)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取属性名</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">property</span> <span class="operator">=</span> getSetterProperty(method);</span><br><span class="line">            <span class="comment">// 检测是否标注 Inject 注解</span></span><br><span class="line">            <span class="type">Inject</span> <span class="variable">inject</span> <span class="operator">=</span> method.getAnnotation(Inject.class);</span><br><span class="line">            <span class="keyword">if</span> (inject == <span class="literal">null</span>) &#123;</span><br><span class="line">                injectValue(instance, method, pt, property);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 检测 Inject 是否启动、是否按照类型注入</span></span><br><span class="line">                <span class="keyword">if</span> (!inject.enable()) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (inject.type() == Inject.InjectType.ByType) &#123;</span><br><span class="line">                    injectValue(instance, method, pt, <span class="literal">null</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    injectValue(instance, method, pt, property);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取属性名</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">getSetterProperty</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> method.getName().length() &gt; <span class="number">3</span> ? method.getName().substring(<span class="number">3</span>, <span class="number">4</span>).toLowerCase() + method.getName().substring(<span class="number">4</span>) : <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// public、set 开头、只有一个参数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSetter</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> method.getName().startsWith(<span class="string">&quot;set&quot;</span>)</span><br><span class="line">            &amp;&amp; method.getParameterTypes().length == <span class="number">1</span></span><br><span class="line">            &amp;&amp; Modifier.isPublic(method.getModifiers());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">injectValue</span><span class="params">(T instance, Method method, Class&lt;?&gt; pt, String property)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 从 ObjectFactory 中获取依赖对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> objectFactory.getExtension(pt, property);</span><br><span class="line">        <span class="keyword">if</span> (object != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 通过反射调用 setter 方法设置依赖</span></span><br><span class="line">            method.invoke(instance, object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Failed to inject via method &quot;</span> + method.getName()</span><br><span class="line">                + <span class="string">&quot; of interface &quot;</span> + type.getName() + <span class="string">&quot;: &quot;</span> + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>objectFactory</code> 是 <code>ExtensionFactory</code> 的自适应拓展，通过它获取依赖对象，本质上是根据目标拓展类获取 <code>ExtensionLoader</code>，然后获取其自适应拓展，过程代码如下。具体我们不再深入分析，可以参考<a href="/2023/11/29/how-does-Dubbo-SPI-adaptive-extension-works/" title="Dubbo SPI 自适应拓展的工作原理">Dubbo SPI 自适应拓展的工作原理</a>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getExtension</span><span class="params">(Class&lt;T&gt; type, String name)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (type.isInterface() &amp;&amp; type.isAnnotationPresent(SPI.class)) &#123;</span><br><span class="line">        ExtensionLoader&lt;T&gt; loader = ExtensionLoader.getExtensionLoader(type);</span><br><span class="line">        <span class="keyword">if</span> (!loader.getSupportedExtensions().isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> loader.getAdaptiveExtension();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://cn.dubbo.apache.org/zh-cn/docsv2.7/dev/source/dubbo-spi/">Dubbo SPI</a></li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>dubbo</tag>
        <tag>spi</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo SPI 自适应拓展的工作原理</title>
    <url>/2023/11/29/how-does-Dubbo-SPI-adaptive-extension-works/</url>
    <content><![CDATA[<p>直接展示一个具体的 <code>Dubbo SPI</code> 自适应拓展是什么样子，是一种非常好的表现其作用的方式。正如官方博客中所说的，它让人对自适应拓展有更加感性的认识，避免读者一开始就陷入复杂的代码生成逻辑。本文在此基础上，从更原始的使用方式上展现“动态加载”技术对“按需加载”的天然倾向，从更普遍的角度解释自适应拓展的本质目的，在介绍 <code>Dubbo</code> 的具体实现是如何约束自身从而规避缺点之后，详细梳理了 <code>Dubbo SPI</code> 自适应拓展的相关源码和工作原理。</p>
<span id="more"></span>

<blockquote>
<p>站在现有设计回头看的视角更偏向于展现为什么这样设计很好，却并不好展现如果不这样设计会有什么问题，以至于有时候会有种这个设计很妙，但妙在哪里体会不够深的感觉。思考一项技术如何从最初发展到现在，解决以及试图解决哪些问题，因此可能引入哪些问题，也许脑补的并不完全符合历史事实，但仍然会让人更加深刻地认识这项技术本身，体会设计中的巧思，并避免一直陷在庞杂的细节处理中。</p>
</blockquote>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在 <code>Dubbo</code> 中，很多拓展都是通过 <code>SPI</code> 机制动态加载的，比如 <code>Protocol</code>、<code>Cluster</code> 和 <code>LoadBalance</code> 等。有些拓展我们并不想在框架启动阶段被加载，而是希望在拓展方法被调用时，根据运行时参数进行加载。为了让大家对自适应拓展有一个感性的认识，下面我们通过一个实例进行演示。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>定义一个接口 <code>Animal</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义两个实现类 <code>Dog</code> 和 <code>Cat</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog bark...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cat bark...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在运行时根据参数动态地加载拓展。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">(String type)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;type == null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过 SPI 动态地加载具体的 Animal</span></span><br><span class="line">    <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> ExtensionLoader.getExtensionLoader(Animal.class).getExtension(type);</span><br><span class="line">    <span class="comment">// 调用目标方法</span></span><br><span class="line">    animal.bark();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>是不是感觉平平无奇？没错，当你拥有动态加载的能力后，按需加载是自然而然会产生的想法，并不是什么高大上的设计。两者甚至不仅仅是天性相合，可能更像是你中有我，我中有你。在正常场景中，这样一段代码也并不需要进一步被抽象和重构，它本身就很简洁。现在设想一下，你的应用中，有大量的拓展需要动态加载，你可能需要在很多地方写很多根据运行时参数动态加载拓展并调用方法的代码，就像下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> ExtensionLoader.getExtensionLoader(Animal.class).getExtension(type);</span><br><span class="line">animal.bark();</span><br><span class="line"></span><br><span class="line"><span class="type">WeelMaker</span> <span class="variable">weelMaker</span> <span class="operator">=</span> ExtensionLoader.getExtensionLoader(WeelMaker.class).getExtension(weelMakerName);</span><br><span class="line">weelMaker.makeWeel();</span><br><span class="line"></span><br><span class="line"><span class="type">LoadBalance</span> <span class="variable">loadBalance</span> <span class="operator">=</span> ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(invocation.getLoadBalanceType());</span><br><span class="line">loadBalance.select();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>这会带来一些小问题，总是需要写 <code>ExtensionLoader.getExtensionLoader(XXX.class).getExtension(parameter)</code> 这样重复的代码；引入了 <code>ExtensionLoader</code> 这个“中介”，不能直面拓展本身。后者可能有点难以体会，以动物园 <code>Zoo</code> 和 动物 <code>Animal</code> 举例。</p>
<p>在非动态加载情况下，我们可能会这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zoo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Animal&gt; animals;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Animal animal : animals) &#123;</span><br><span class="line">            <span class="keyword">if</span> (type.equals(animal.name)) &#123;</span><br><span class="line">                animal.bark();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在动态加载情况下，我们可能会这样写。在这种情况下，<code>Zoo</code> 没有合适的方式直接持有 <code>Animal</code>，而是通过 <code>ExtensionLoader</code> 间接地持有。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zoo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ExtensionLoader&lt;Animal&gt; extensionLoader = ExtensionLoader.getExtensionLoader(Animal.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> extensionLoader.getExtension(type);</span><br><span class="line">        animal.bark();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们更想要以下这种直接持有 <code>Animal</code> 的方式，在运行时 <code>animal</code> 可以是 <code>Dog</code>，也可以是 <code>Cat</code>，还可以是其他的动物。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zoo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Animal animal;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        animal.bark();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Dubbo</code> 采用了一种称为“自适应拓展”的巧妙设计，通过代理的方式，将动态加载拓展的代码整合到代理类（具体实现类）中。使用方调用代理对象，代理对象根据参数动态加载拓展并调用。例如 <code>Animal</code> 的自适应拓展，就像下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdaptiveAnimal</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;type == null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> ExtensionLoader.getExtensionLoader(Animal.class).getExtension(type);</span><br><span class="line">        animal.bark();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AdaptiveAnimal</span>();</span><br><span class="line">animal.bark(type);</span><br></pre></td></tr></table></figure>

<p>当然，我们不希望需要手动地为每一个拓展编写 <code>Adaptive</code> 代理类，事实上，我们以往接触到的代理方案，大都是自动生成代理的，应该也不会有人会接受完全手写的方式。然而你可能会注意到一个不够和谐的缺点，<code>bark</code> 方法的参数列表中新增了 <code>type</code> 类型，这不太符合面向对象的设计原则。想象一个更奇怪的场景，我们要为一个方法引入与它本身格格不入的参数用于获取拓展。另外，我们可能需要通过一些标记或约定来告诉代理生成器，方法参数列表中哪一个参数是用于获取拓展的。事实上，<code>Dubbo</code> 的另一个设计规避了这一缺点，<code>Dubbo</code> 在<a href="https://cn.dubbo.apache.org/zh-cn/docsv2.7/dev/contract/">公共契约</a>中提到：<strong>所有扩展点参数都包含 <code>URL</code> 参数，<code>URL</code> 作为上下文信息贯穿整个扩展点设计体系</strong>。因此围绕着 <code>Dubbo</code> 以 <code>URL</code> 为中心的拓展体系，你很难设计出 <code>Animal.bark(URL url)</code> 这样不和谐的方法签名，也不用担心参数列表千奇百怪的情况。同时 <code>Dubbo</code> 并未完全抛弃手工编写自适应拓展的方式，而是予以保留。</p>
<h3 id="手工编码的自适应拓展"><a href="#手工编码的自适应拓展" class="headerlink" title="手工编码的自适应拓展"></a>手工编码的自适应拓展</h3><p>在在 <code>Dubbo</code> 中，尽管很少但仍然存在手工编码的自适应拓展，<strong>这类拓展允许你不使用 <code>URL</code> 作为参数</strong>，查看它们的代码可以帮助我们更好地理解自适应拓展是如何在真实的应用场景中发挥作用的。以下是 <code>ExtensionFactory</code> 的自适应拓展，当你调用它的 <code>getExtension</code> 方法时，它就是将工作全权委托给 <code>factory.getExtension(type, name)</code> 完成的，而 <code>factories</code> 在创建 <code>AdaptiveExtensionFactory</code> 时就已经获取了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Adaptive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdaptiveExtensionFactory</span> <span class="keyword">implements</span> <span class="title class_">ExtensionFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ExtensionFactory&gt; factories;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AdaptiveExtensionFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取 ExtensionFactory 的 ExtensionLoader</span></span><br><span class="line">        ExtensionLoader&lt;ExtensionFactory&gt; loader = ExtensionLoader.getExtensionLoader(ExtensionFactory.class);</span><br><span class="line">        List&lt;ExtensionFactory&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ExtensionFactory&gt;();</span><br><span class="line">        <span class="comment">// 获取全部支持的（不包含自适应拓展）拓展名称，依次获取拓展加入 factories</span></span><br><span class="line">        <span class="keyword">for</span> (String name : loader.getSupportedExtensions()) &#123;</span><br><span class="line">            list.add(loader.getExtension(name));</span><br><span class="line">        &#125;</span><br><span class="line">        factories = Collections.unmodifiableList(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getExtension</span><span class="params">(Class&lt;T&gt; type, String name)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (ExtensionFactory factory : factories) &#123;</span><br><span class="line">            <span class="comment">// 委托给其他 ExtensionFactory 拓展获取，比如 SpiExtensionFactory</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">extension</span> <span class="operator">=</span> factory.getExtension(type, name);</span><br><span class="line">            <span class="keyword">if</span> (extension != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> extension;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们提到了按需加载是具备动态加载能力后自然的倾向，介绍了在拥有大量拓展情况下演变而来的自适应拓展设计，它的缺点和 Dubbo 是如何规避的。接下来，我们将进入源码分析部分。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="Adaptive-注解"><a href="#Adaptive-注解" class="headerlink" title="Adaptive 注解"></a>Adaptive 注解</h3><p><code>Adaptive</code> 注解是一个与自适应拓展息息相关的注解，该定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Adaptive &#123;</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据 <code>Target</code> 注解的 <code>value</code> 可知，<code>Adaptive</code> 注解可标注在类或者方法上。当 <code>Adaptive</code> 注解标注在类上时，<code>Dubbo</code> 不会为该类生成代理类。当 <code>Adaptive</code> 注解标注在接口方法上时，<code>Dubbo</code> 则会为该方法生成代理逻辑。<code>Adaptive</code> 注解在类上的情况很少，在 <code>Dubbo</code> 中，仅有两个类被 <code>Adaptive</code> 注解标注，分别是 <code>AdaptiveCompiler</code> 和 <code>AdaptiveExtensionFactory</code>。在这种情况下，拓展的加载逻辑由人工编码完成。在更多时候，<code>Adaptive</code> 注解是标注在接口方法上的，这表示拓展的加载逻辑需由框架自动生成。</p>
<h3 id="获取自适应拓展"><a href="#获取自适应拓展" class="headerlink" title="获取自适应拓展"></a>获取自适应拓展</h3><p>获取自适应拓展的入口方法是 <code>getAdaptiveExtension</code>，使用 <code>getOrCreate</code> 的模式获取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">getAdaptiveExtension</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 双重检查</span></span><br><span class="line">    <span class="comment">// 从缓存中获取自适应拓展</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> cachedAdaptiveInstance.get();</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建自适应拓展失败的结果也会被缓存，避免重复尝试</span></span><br><span class="line">        <span class="keyword">if</span> (createAdaptiveInstanceError != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Failed to create adaptive instance: &quot;</span> +</span><br><span class="line">                    createAdaptiveInstanceError.toString(),</span><br><span class="line">                    createAdaptiveInstanceError);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (cachedAdaptiveInstance) &#123;</span><br><span class="line">            instance = cachedAdaptiveInstance.get();</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 创建自适应拓展</span></span><br><span class="line">                    instance = createAdaptiveExtension();</span><br><span class="line">                    <span class="comment">// 将自适应拓展设置到缓存中</span></span><br><span class="line">                    cachedAdaptiveInstance.set(instance);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    createAdaptiveInstanceError = t;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Failed to create adaptive instance: &quot;</span> + t.toString(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建自适应拓展"><a href="#创建自适应拓展" class="headerlink" title="创建自适应拓展"></a>创建自适应拓展</h3><p>当缓存为空时，就会通过 <code>createAdaptiveExtension</code> 方法创建。方法包含以下三个处理逻辑：</p>
<ol>
<li>调用 <code>getAdaptiveExtensionClass</code> 方法获取自适应拓展的 <code>Class</code> 对象。</li>
<li>通过反射进行实例化。</li>
<li>调用 <code>injectExtension</code> 方法对拓展实例进行依赖注入。</li>
</ol>
<blockquote>
<p><strong>手工编码的自适应拓展可能依赖其他拓展，但是框架生成的自适应拓展并不依赖其他拓展</strong>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> T <span class="title function_">createAdaptiveExtension</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> injectExtension((T) getAdaptiveExtensionClass().newInstance());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Can&#x27;t create adaptive extension &quot;</span> + type + <span class="string">&quot;, cause: &quot;</span> + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取自适应拓展类"><a href="#获取自适应拓展类" class="headerlink" title="获取自适应拓展类"></a>获取自适应拓展类</h3><p>获取自适应拓展类的 <code>getAdaptiveExtensionClass</code> 方法包含以下三个处理逻辑：</p>
<ol>
<li>通过 <code>getExtensionClasses</code> 方法获取所有拓展类。</li>
<li>检查缓存 <code>cachedAdaptiveClass</code>，如果不为 <code>null</code>，则返回缓存。</li>
<li>如果缓存为 <code>null</code>，则调用 <code>createAdaptiveExtensionClass</code> 创建自适应拓展类（代理类）。</li>
</ol>
<p>在<a href="/2023/11/28/how-does-Dubbo-SPI-works/" title="Dubbo SPI 的工作原理">Dubbo SPI 的工作原理</a>中我们分析过 <code>getExtensionClasses</code> 方法，在获取拓展的所有实现类时，如果某个实现类被 <code>Adaptive</code> 注解标注了，那么该类就会被赋值给 <code>cachedAdaptiveClass</code> 变量。“原理”部分介绍的 <code>AdaptiveExtensionFactory</code> 就属于这种情况，我们不再细谈。按前文所说，在绝大多数情况下，<code>Adaptive</code> 注解都是用于标注方法而非标注具体的实现类，因此在大多数情况下程序都会走第三个步骤，由框架自动生成自适应拓展类（代理类）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; getAdaptiveExtensionClass() &#123;</span><br><span class="line">    getExtensionClasses();</span><br><span class="line">    <span class="keyword">if</span> (cachedAdaptiveClass != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cachedAdaptiveClass;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">return</span> <span class="variable">cachedAdaptiveClass</span> <span class="operator">=</span> createAdaptiveExtensionClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>到目前为止，<strong>获取自适应拓展的过程和获取普通拓展的过程是非常相似的</strong>，使用 <code>getOrCreate</code> 的模式获取拓展，如果缓存为空则创建，创建的时候会先加载全部的拓展实现类，从中获取目标类，通过反射进行实例化，最后进行依赖注入。区别在于获取目标类时，在自适应拓展情况下，返回的可能是一个生成的代理类。生成的过程非常复杂，是我们接下来关注的重点。</p>
</blockquote>
<h3 id="生成自适应拓展类"><a href="#生成自适应拓展类" class="headerlink" title="生成自适应拓展类"></a>生成自适应拓展类</h3><p>生成自适应拓展类的方式相比于以往接触的生成代理类的方式更加“直观且容易理解”，但是相应的，拼接字符串部分的代码并不容易阅读。</p>
<ol>
<li>通过拼接字符串得到代理类的源码。</li>
<li>使用编译器编译得到 <code>Class</code> 对象。</li>
</ol>
<blockquote>
<p>在新版本中，这部分代码的可读性有了非常大的提升，原先冗长的处理逻辑被抽象为多个命名含义清晰的方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; createAdaptiveExtensionClass() &#123;</span><br><span class="line">    <span class="comment">// 区别于旧版本：新版本抽象出一个 AdaptiveClassCodeGenerator 用于生成代码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AdaptiveClassCodeGenerator</span>(type, cachedDefaultName).generate();</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> findClassLoader();</span><br><span class="line">    <span class="comment">// 获取编译器拓展</span></span><br><span class="line">    org.apache.dubbo.common.compiler.<span class="type">Compiler</span> <span class="variable">compiler</span> <span class="operator">=</span></span><br><span class="line">            ExtensionLoader.getExtensionLoader(org.apache.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();</span><br><span class="line">    <span class="comment">// 编译代码，生成 Class 对象</span></span><br><span class="line">    <span class="keyword">return</span> compiler.compile(code, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>为了更直观地了解代码生成的效果及其实现的功能，以 <code>Protocol</code> 为例，生成的完整代码（已经经过格式化）展示如下</em>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.dubbo.rpc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.common.extension.ExtensionLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Protocol$Adaptive</span> <span class="keyword">implements</span> <span class="title class_">org</span>.apache.dubbo.rpc.Protocol &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(</span><br><span class="line">                <span class="string">&quot;The method public abstract void org.apache.dubbo.rpc.Protocol.destroy() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDefaultPort</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(</span><br><span class="line">                <span class="string">&quot;The method public abstract int org.apache.dubbo.rpc.Protocol.getDefaultPort() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> org.apache.dubbo.rpc.Invoker <span class="title function_">refer</span><span class="params">(java.lang.Class arg0, org.apache.dubbo.common.URL arg1)</span></span><br><span class="line">            <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException &#123;</span><br><span class="line">        <span class="keyword">if</span> (arg1 == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;url == null&quot;</span>);</span><br><span class="line">        org.apache.dubbo.common.<span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> arg1;</span><br><span class="line">        <span class="type">String</span> <span class="variable">extName</span> <span class="operator">=</span> (url.getProtocol() == <span class="literal">null</span> ? <span class="string">&quot;dubbo&quot;</span> : url.getProtocol());</span><br><span class="line">        <span class="keyword">if</span> (extName == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Failed to get extension (org.apache.dubbo.rpc.Protocol) name from url (&quot;</span></span><br><span class="line">                    + url.toString() + <span class="string">&quot;) use keys([protocol])&quot;</span>);</span><br><span class="line">        org.apache.dubbo.rpc.<span class="type">Protocol</span> <span class="variable">extension</span> <span class="operator">=</span> (org.apache.dubbo.rpc.Protocol) ExtensionLoader</span><br><span class="line">                .getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.refer(arg0, arg1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> java.util.List <span class="title function_">getServers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(</span><br><span class="line">                <span class="string">&quot;The method public default java.util.List org.apache.dubbo.rpc.Protocol.getServers() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> org.apache.dubbo.rpc.Exporter <span class="title function_">export</span><span class="params">(org.apache.dubbo.rpc.Invoker arg0)</span></span><br><span class="line">            <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException &#123;</span><br><span class="line">        <span class="keyword">if</span> (arg0 == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;org.apache.dubbo.rpc.Invoker argument == null&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (arg0.getUrl() == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;org.apache.dubbo.rpc.Invoker argument getUrl() == null&quot;</span>);</span><br><span class="line">        org.apache.dubbo.common.<span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> arg0.getUrl();</span><br><span class="line">        <span class="type">String</span> <span class="variable">extName</span> <span class="operator">=</span> (url.getProtocol() == <span class="literal">null</span> ? <span class="string">&quot;dubbo&quot;</span> : url.getProtocol());</span><br><span class="line">        <span class="keyword">if</span> (extName == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Failed to get extension (org.apache.dubbo.rpc.Protocol) name from url (&quot;</span></span><br><span class="line">                    + url.toString() + <span class="string">&quot;) use keys([protocol])&quot;</span>);</span><br><span class="line">        org.apache.dubbo.rpc.<span class="type">Protocol</span> <span class="variable">extension</span> <span class="operator">=</span> (org.apache.dubbo.rpc.Protocol) ExtensionLoader</span><br><span class="line">                .getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.export(arg0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成的代理类需完成以下功能：</p>
<ol>
<li>非 <code>adaptive</code> 方法，直接抛出异常。</li>
<li><code>adaptive</code> 方法：<ul>
<li>准备工作：在参数判空校验之后，从中获取到 <code>URL</code> 对象，结合 <code>URL</code> 对象和默认拓展名得到最终的拓展名 <code>extName</code>。</li>
<li>核心功能：先获取拓展的 <code>ExtensionLoader</code>，再根据拓展名 <code>extName</code> 获取拓展，最后调用拓展的同名方法。</li>
</ul>
</li>
</ol>
<p>以上的功能在表面上看来并不复杂，事实上，想要实现的目标处理逻辑也并不复杂，只在为了提供足够的可扩展性，具体实现变得很复杂。复杂的处理逻辑主要集中在如何为“准备工作”部分生成相应的代码，大概可以总结为：在获取拓展前，<code>Dubbo</code> 会直接或间接地从参数列表中查找 <code>URL</code> 对象，所谓直接就是 <code>URL</code> 对象直接在参数列表中，所谓间接就是 <code>URL</code> 对象是其中一个参数的属性。在得到 <code>URL</code> 对象后，<code>Dubbo</code> 会尝试以 <code>Adaptive</code> 注解的 <code>value</code> 为 <code>key</code>，从 <code>URL</code> 中获取值作为拓展名，如果获取不到则使用默认拓展名 <code>defaultExtName</code>。实际的实现更加复杂，需要耐心阅读和测试。</p>
<h3 id="自适应拓展类代码生成器"><a href="#自适应拓展类代码生成器" class="headerlink" title="自适应拓展类代码生成器"></a>自适应拓展类代码生成器</h3><p>新版本将代码生成的逻辑抽象到自适应拓展类代码生成器中，注意参数只有 <code>type</code> 和 <code>defaultExtName</code>，从这里也可以看出如何确定最终加载的拓展，取决于这两个参数和被调用方法的入参。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AdaptiveClassCodeGenerator</span><span class="params">(Class&lt;?&gt; type, String defaultExtName)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.type = type;</span><br><span class="line">    <span class="built_in">this</span>.defaultExtName = defaultExtName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">generate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 检测是否至少存在一个方法标注了 Adaptive 注解</span></span><br><span class="line">    <span class="keyword">if</span> (!hasAdaptiveMethod()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No adaptive method exist on extension &quot;</span> + type.getName() + <span class="string">&quot;, refuse to create the adaptive class!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 区别于旧版本：抽象为几个命名含义清晰的方法，提升了可读性</span></span><br><span class="line">    <span class="comment">// 生成类：包名、导入、类声明</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">code</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    code.append(generatePackageInfo());</span><br><span class="line">    code.append(generateImports());</span><br><span class="line">    code.append(generateClassDeclaration());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成方法</span></span><br><span class="line">    Method[] methods = type.getMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        code.append(generateMethod(method));</span><br><span class="line">    &#125;</span><br><span class="line">    code.append(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(code.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> code.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="检测-Adaptive-注解"><a href="#检测-Adaptive-注解" class="headerlink" title="检测 Adaptive 注解"></a>检测 Adaptive 注解</h4><p>在生成代理类源码之前，<code>generate</code> 方法会先通过反射检测接口方法中是否至少有一个标注了 <code>Adaptive</code> 注解，若不满足，就会抛出异常。</p>
<blockquote>
<p>流式编程使用得当的话很有可读性啊。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasAdaptiveMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(type.getMethods()).anyMatch(m -&gt; m.isAnnotationPresent(Adaptive.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="生成类"><a href="#生成类" class="headerlink" title="生成类"></a>生成类</h4><p>生成代理类源码的顺序和普通 <code>Java</code> 类文件中内容的顺序一致：</p>
<ul>
<li>package</li>
<li>import</li>
<li>类声明</li>
</ul>
<p>先忽略“生成方法”的部分，以 <code>Dubbo</code> 的 <code>Protocol</code> 拓展为例，生成的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.dubbo.rpc;</span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.common.extension.ExtensionLoader;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Protocol$Adaptive</span> <span class="keyword">implements</span> <span class="title class_">org</span>.apache.dubbo.rpc.Protocol &#123;</span><br><span class="line">    <span class="comment">// 省略方法代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="生成方法"><a href="#生成方法" class="headerlink" title="生成方法"></a>生成方法</h4><p>生成方法的过程同样被抽象为几个命名含义清晰的方法，包含以下五个部分：</p>
<ul>
<li>返回值</li>
<li>方法名</li>
<li><strong>方法内容</strong></li>
<li>方法参数</li>
<li>方法抛出的异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">generateMethod</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodReturnType</span> <span class="operator">=</span> method.getReturnType().getCanonicalName();</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> method.getName();</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodContent</span> <span class="operator">=</span> generateMethodContent(method);</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodArgs</span> <span class="operator">=</span> generateMethodArguments(method);</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodThrows</span> <span class="operator">=</span> generateMethodThrows(method);</span><br><span class="line">    <span class="keyword">return</span> String.format(CODE_METHOD_DECLARATION, methodReturnType, methodName, methodArgs, methodThrows, methodContent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了最重要的“方法内容”部分，其他部分都是复制原方法的信息，并不复杂。生成“方法内容”部分，分为是否被 <code>Adaptive</code> 注解标注。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">generateMethodContent</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">    <span class="type">Adaptive</span> <span class="variable">adaptiveAnnotation</span> <span class="operator">=</span> method.getAnnotation(Adaptive.class);</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">code</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">512</span>);</span><br><span class="line">    <span class="comment">// 检测方法是否被 Adaptive 注解标注</span></span><br><span class="line">    <span class="keyword">if</span> (adaptiveAnnotation == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> generateUnsupported(method);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> code.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="无-Adaptive-注解标注的方法"><a href="#无-Adaptive-注解标注的方法" class="headerlink" title="无 Adaptive 注解标注的方法"></a>无 Adaptive 注解标注的方法</h5><p>对于无 <code>Adaptive</code> 注解标注的方法，生成逻辑很简单，就是生成抛出异常的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">generateUnsupported</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> String.format(CODE_UNSUPPORTED, method, type.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>以 <code>Protocol</code> 接口的 <code>destroy</code> 方法为例，生成的内容如下</em>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;The method public abstract void org.apache.dubbo.rpc.Protocol.destroy() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="有-Adaptive-注解标注的方法"><a href="#有-Adaptive-注解标注的方法" class="headerlink" title="有 Adaptive 注解标注的方法"></a>有 Adaptive 注解标注的方法</h5><p>对于有 Adaptive 注解标注的方法，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找 URL 类型的参数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">urlTypeIndex</span> <span class="operator">=</span> getUrlTypeIndex(method);</span><br><span class="line"><span class="keyword">if</span> (urlTypeIndex != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 生成 URL 判空检查和赋值的代码</span></span><br><span class="line">    code.append(generateUrlNullCheck(urlTypeIndex));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果参数中没有直接出现 URL 类型，生成间接情况下的 URL 判空和赋值代码</span></span><br><span class="line">    code.append(generateUrlAssignmentIndirectly(method));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取方法的 Adaptive 注解的 value</span></span><br><span class="line">String[] value = getMethodAdaptiveValue(adaptiveAnnotation);</span><br><span class="line"><span class="comment">// 检测是否有 Invocation 类型的参数</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">hasInvocation</span> <span class="operator">=</span> hasInvocationArgument(method);</span><br><span class="line"><span class="comment">// 生成 Invocation 判空检查代码</span></span><br><span class="line">code.append(generateInvocationArgumentNullCheck(method));</span><br><span class="line"><span class="comment">// 生成拓展名赋值代码</span></span><br><span class="line">code.append(generateExtNameAssignment(value, hasInvocation));</span><br><span class="line"><span class="comment">// 生成拓展名判空检查代码</span></span><br><span class="line">code.append(generateExtNameNullCheck(value));</span><br><span class="line"><span class="comment">// 生成获取拓展和赋值代码</span></span><br><span class="line">code.append(generateExtensionAssignment());</span><br><span class="line"><span class="comment">// 生成调用和返回代码</span></span><br><span class="line">code.append(generateReturnAndInvocation(method));</span><br></pre></td></tr></table></figure>

<h5 id="查找-URL-类型的参数"><a href="#查找-URL-类型的参数" class="headerlink" title="查找 URL 类型的参数"></a>查找 URL 类型的参数</h5><p><strong>直接</strong>从方法的参数类型列表中查找<strong>第一个</strong> <code>URL</code> 类型的参数，返回其索引。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getUrlTypeIndex</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">urlTypeIndex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 遍历方法的参数类型列表</span></span><br><span class="line">    Class&lt;?&gt;[] pts = method.getParameterTypes();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pts.length; ++i) &#123;</span><br><span class="line">        <span class="comment">// 查找第一个 URL 类型的参数</span></span><br><span class="line">        <span class="keyword">if</span> (pts[i].equals(URL.class)) &#123;</span><br><span class="line">            urlTypeIndex = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> urlTypeIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成 URL 参数判空检查和赋值代码</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">generateUrlNullCheck</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> String.format(CODE_URL_NULL_CHECK, index, URL.class.getName(), index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>间接</strong>从方法的参数类型列表中，查找 <code>URL</code> 类型的参数，并生成判空检查和赋值代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">generateUrlAssignmentIndirectly</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">    Class&lt;?&gt;[] pts = method.getParameterTypes();</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Integer&gt; getterReturnUrl = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 遍历方法的参数类型列表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pts.length; ++i) &#123;</span><br><span class="line">        <span class="comment">// 遍历某一个参数类型的全部方法，查找可以返回 URL 类型的 “getter” 方法</span></span><br><span class="line">        <span class="keyword">for</span> (Method m : pts[i].getMethods()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> m.getName();</span><br><span class="line">            <span class="comment">// 1. 方法名以 get 开头，或者方法名大于 3 个字符</span></span><br><span class="line">            <span class="comment">// 2. 方法的访问权限为 public</span></span><br><span class="line">            <span class="comment">// 3. 非静态方法</span></span><br><span class="line">            <span class="comment">// 4. 方法参数数量为 0</span></span><br><span class="line">            <span class="comment">// 5. 方法返回值类型为 URL</span></span><br><span class="line">            <span class="keyword">if</span> ((name.startsWith(<span class="string">&quot;get&quot;</span>) || name.length() &gt; <span class="number">3</span>)</span><br><span class="line">                    &amp;&amp; Modifier.isPublic(m.getModifiers())</span><br><span class="line">                    &amp;&amp; !Modifier.isStatic(m.getModifiers())</span><br><span class="line">                    &amp;&amp; m.getParameterTypes().length == <span class="number">0</span></span><br><span class="line">                    &amp;&amp; m.getReturnType() == URL.class) &#123;</span><br><span class="line">                <span class="comment">// 保存方法名-&gt;索引的映射</span></span><br><span class="line">                getterReturnUrl.put(name, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getterReturnUrl.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果没有找到 “getter” 方法，抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Failed to create adaptive class for interface &quot;</span> + type.getName()</span><br><span class="line">                + <span class="string">&quot;: not found url parameter or url attribute in parameters of method &quot;</span> + method.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优先选择方法名为 getUrl 的方法，如果没有则选第一个</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">index</span> <span class="operator">=</span> getterReturnUrl.get(<span class="string">&quot;getUrl&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (index != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> generateGetUrlNullCheck(index, pts[index], <span class="string">&quot;getUrl&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Map.Entry&lt;String, Integer&gt; entry = getterReturnUrl.entrySet().iterator().next();</span><br><span class="line">        <span class="keyword">return</span> generateGetUrlNullCheck(entry.getValue(), pts[entry.getValue()], entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成 URL 参数判空检查和赋值代码</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">generateGetUrlNullCheck</span><span class="params">(<span class="type">int</span> index, Class&lt;?&gt; type, String method)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">code</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    code.append(String.format(<span class="string">&quot;if (arg%d == null) throw new IllegalArgumentException(\&quot;%s argument == null\&quot;);\n&quot;</span>,</span><br><span class="line">            index, type.getName()));</span><br><span class="line">    code.append(String.format(<span class="string">&quot;if (arg%d.%s() == null) throw new IllegalArgumentException(\&quot;%s argument %s() == null\&quot;);\n&quot;</span>,</span><br><span class="line">            index, method, type.getName(), method));</span><br><span class="line"></span><br><span class="line">    code.append(String.format(<span class="string">&quot;%s url = arg%d.%s();\n&quot;</span>, URL.class.getName(), index, method));</span><br><span class="line">    <span class="keyword">return</span> code.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>以 <code>Protocol</code> 的 <code>refer</code> 和 <code>export</code> 方法为例，生成的内容如下</em>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// refer</span></span><br><span class="line"><span class="keyword">if</span> (arg1 == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;url == null&quot;</span>);</span><br><span class="line">org.apache.dubbo.common.<span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> arg1;</span><br><span class="line"><span class="comment">// export</span></span><br><span class="line"><span class="keyword">if</span> (arg0 == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;org.apache.dubbo.rpc.Invoker argument == null&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (arg0.getUrl() == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;org.apache.dubbo.rpc.Invoker argument getUrl() == null&quot;</span>);</span><br><span class="line">org.apache.dubbo.common.<span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> arg0.getUrl();</span><br></pre></td></tr></table></figure>

<h5 id="获取-Adaptive-注解的-value"><a href="#获取-Adaptive-注解的-value" class="headerlink" title="获取 Adaptive 注解的 value"></a>获取 Adaptive 注解的 value</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String[] getMethodAdaptiveValue(Adaptive adaptiveAnnotation) &#123;</span><br><span class="line">    String[] value = adaptiveAnnotation.value();</span><br><span class="line">    <span class="comment">// 如果 value 为空，使用类名生成 value</span></span><br><span class="line">    <span class="comment">// 效果：LoadBalance -&gt; load.balance</span></span><br><span class="line">    <span class="keyword">if</span> (value.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">splitName</span> <span class="operator">=</span> StringUtils.camelToSplitName(type.getSimpleName(), <span class="string">&quot;.&quot;</span>);</span><br><span class="line">        value = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;splitName&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="检测-Invocation-类型的参数"><a href="#检测-Invocation-类型的参数" class="headerlink" title="检测 Invocation 类型的参数"></a>检测 Invocation 类型的参数</h5><p>检测是否有 <code>Invocation</code> 类型的参数，并生成判空检查代码和赋值代码。从 <code>Invocation</code> 可以获得 <code>methodName</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasInvocationArgument</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">    Class&lt;?&gt;[] pts = method.getParameterTypes();</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(pts).anyMatch(p -&gt; CLASSNAME_INVOCATION.equals(p.getName()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">generateInvocationArgumentNullCheck</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">    Class&lt;?&gt;[] pts = method.getParameterTypes();</span><br><span class="line">    <span class="keyword">return</span> IntStream.range(<span class="number">0</span>, pts.length).filter(i -&gt; CLASSNAME_INVOCATION.equals(pts[i].getName()))</span><br><span class="line">                    .mapToObj(i -&gt; String.format(CODE_INVOCATION_ARGUMENT_NULL_CHECK, i, i))</span><br><span class="line">                    .findFirst().orElse(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以 <code>LoadBalance</code> 的 <code>select</code> 方法为例，生成的内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (arg2 == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;invocation == null&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> arg2.getMethodName();</span><br></pre></td></tr></table></figure>

<h5 id="获取拓展名"><a href="#获取拓展名" class="headerlink" title="获取拓展名"></a>获取拓展名</h5><p>本方法用于根据 <code>SPI</code> 和 <code>Adaptive</code> 注解的 <code>value</code> 生成“获取拓展名”的代码，同时生成逻辑还受 <code>Invocation</code> 影响，因此相对复杂。总结的规则如下：</p>
<ol>
<li>正常情况下，使用 url.getParameter(value[i]) 获取</li>
<li>如果默认拓展名非空，使用 url.getParameter(value[i], defaultExtName) 获取</li>
<li>如果存在 Invocation，不论默认拓展名是否为空，总是使用 url.getMethodParameter(methodName, value[i], defaultExtName) 获取</li>
<li>因为 protocol 是 url 的一部分，所以可以直接通过 getProtocol 获取。是否使用默认拓展名的方式就退化为原始的三元表达式。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">generateExtNameAssignment</span><span class="params">(String[] value, <span class="type">boolean</span> hasInvocation)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> refactor it</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">getNameCode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 逆序遍历 value（Adaptive 的 value）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> value.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="comment">// 当 i 为最后一个元素的索引（因为是逆序遍历，第一轮就进入本分支）</span></span><br><span class="line">        <span class="keyword">if</span> (i == value.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 默认拓展名非空</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != defaultExtName) &#123;</span><br><span class="line">                <span class="comment">// protocol 是 url 的一部分，可以通过 getProtocol 方法获取，其他的则必须从 URL 参数中获取</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="string">&quot;protocol&quot;</span>.equals(value[i])) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (hasInvocation) &#123;</span><br><span class="line">                        <span class="comment">// 如果有 Invocation，则使用 url.getMethodParameter 获取</span></span><br><span class="line">                        <span class="comment">// url.getMethodParameter(methodName, value[i], defaultExtName)</span></span><br><span class="line">                        getNameCode = String.format(<span class="string">&quot;url.getMethodParameter(methodName, \&quot;%s\&quot;, \&quot;%s\&quot;)&quot;</span>, value[i], defaultExtName);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// url.getParameter(value[i], defaultExtName)</span></span><br><span class="line">                        getNameCode = String.format(<span class="string">&quot;url.getParameter(\&quot;%s\&quot;, \&quot;%s\&quot;)&quot;</span>, value[i], defaultExtName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// ( url.getProtocol() == null ? defaultExtName : url.getProtocol() )</span></span><br><span class="line">                    getNameCode = String.format(<span class="string">&quot;( url.getProtocol() == null ? \&quot;%s\&quot; : url.getProtocol() )&quot;</span>, defaultExtName);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">// 默认拓展名为空</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="string">&quot;protocol&quot;</span>.equals(value[i])) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (hasInvocation) &#123;</span><br><span class="line">                        <span class="comment">// url.getMethodParameter(methodName, value[i], defaultExtName)</span></span><br><span class="line">                        getNameCode = String.format(<span class="string">&quot;url.getMethodParameter(methodName, \&quot;%s\&quot;, \&quot;%s\&quot;)&quot;</span>, value[i], defaultExtName);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// url.getParameter(value[i])</span></span><br><span class="line">                        getNameCode = String.format(<span class="string">&quot;url.getParameter(\&quot;%s\&quot;)&quot;</span>, value[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// url.getProtocol()</span></span><br><span class="line">                    getNameCode = <span class="string">&quot;url.getProtocol()&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="string">&quot;protocol&quot;</span>.equals(value[i])) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hasInvocation) &#123;</span><br><span class="line">                    <span class="comment">// url.getMethodParameter(methodName, value[i], defaultExtName)</span></span><br><span class="line">                    getNameCode = String.format(<span class="string">&quot;url.getMethodParameter(methodName, \&quot;%s\&quot;, \&quot;%s\&quot;)&quot;</span>, value[i], defaultExtName);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// url.getParameter(value[i], getNameCode)</span></span><br><span class="line">                    getNameCode = String.format(<span class="string">&quot;url.getParameter(\&quot;%s\&quot;, %s)&quot;</span>, value[i], getNameCode);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// url.getProtocol() == null ? &quot;dubbo&quot; : url.getProtocol()</span></span><br><span class="line">                getNameCode = String.format(<span class="string">&quot;url.getProtocol() == null ? (%s) : url.getProtocol()&quot;</span>, getNameCode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> String.format(CODE_EXT_NAME_ASSIGNMENT, getNameCode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="加载拓展"><a href="#加载拓展" class="headerlink" title="加载拓展"></a>加载拓展</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">generateExtensionAssignment</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> String.format(CODE_EXTENSION_ASSIGNMENT, type.getName(), ExtensionLoader.class.getSimpleName(), type.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以 <code>Protocol</code> 接口的 <code>refer</code> 方法为例，生成的内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.apache.dubbo.rpc.<span class="type">Protocol</span> <span class="variable">extension</span> <span class="operator">=</span> (org.apache.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);</span><br></pre></td></tr></table></figure>

<h5 id="调用与返回"><a href="#调用与返回" class="headerlink" title="调用与返回"></a>调用与返回</h5><p>生成方法调用语句，如有必要，返回结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">generateReturnAndInvocation</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">returnStatement</span> <span class="operator">=</span> method.getReturnType().equals(<span class="keyword">void</span>.class) ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;return &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">args</span> <span class="operator">=</span> IntStream.range(<span class="number">0</span>, method.getParameters().length)</span><br><span class="line">            .mapToObj(i -&gt; String.format(CODE_EXTENSION_METHOD_INVOKE_ARGUMENT, i))</span><br><span class="line">            .collect(Collectors.joining(<span class="string">&quot;, &quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> returnStatement + String.format(<span class="string">&quot;extension.%s(%s);\n&quot;</span>, method.getName(), args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以 <code>Protocol</code> 接口的 <code>refer</code> 方法为例，生成的内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> extension.refer(arg0, arg1);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>新版本通过提炼方法、使用流式编程和使用 <code>String.format()</code> 代替 StringBuilder，提供了更好的代码可读性。官方写得源码解析真好。</p>
</blockquote>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://cn.dubbo.apache.org/zh-cn/docsv2.7/dev/source/adaptive-extension/">SPI 自适应拓展</a></li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>dubbo</tag>
        <tag>spi</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx 反向代理在家庭网络中的应用</title>
    <url>/2023/12/01/Nginx-reverse-proxy-for-home-networks/</url>
    <content><![CDATA[<p>原先在使用 <code>Cloudflare Tunnel</code> 访问家庭网络中的服务时，是直接将域名解析到相应服务。尽管 <code>Cloudflare</code> 已经提供相关的请求统计和安全防护功能，部分服务自身也有访问日志，但是为了更好地监控和跟踪对外服务的使用情况，采集 <code>Cloudlfare</code> 统计中缺少的新，决定使用 <code>Nginx</code> 反向代理内部服务，统一内部服务的访问入口。简而言之就是，又折腾一些有的没的。以上修改带来的一个附加好处是在局域网内访问服务时，通过在 <code>hosts</code> 文件中添加域名映射，可以用更加容易记忆的域名代替 <code>IP + port</code> 的形式去访问。</p>
<span id="more"></span>

<blockquote>
<p><code>Cloudflare Tunnel</code> 相较于 <code>Zerotier</code> 和 <code>OpenVPN</code>，尽管它们三者都能避免直接开放家庭网络，但前者可以让用户直接使用域名访问到局域网中的服务，便于分享。但它的速度和延迟并不理想，还有人反馈存在网络不稳定的现象，但作为个人玩具还是够用的。有朋友使用公网服务器配合打洞软件和家庭网络中的服务器组网，实现相同目标的同时效果更好。</p>
</blockquote>
<h2 id="网络结构示意图"><a href="#网络结构示意图" class="headerlink" title="网络结构示意图"></a>网络结构示意图</h2><p>客户端发起请求，请求经 <code>Cloudflare</code> 转发到局域网中的 <code>Tunnel</code>。原先，<code>Tunnel</code> 如虚线箭头所示，直接将请求发向目标服务，如今改为发向 <code>Nginx</code>，由 <code>Nginx</code> 反向代理，发向目标服务。</p>
<img src="/2023/12/01/Nginx-reverse-proxy-for-home-networks/Pasted%20image%2020231201202859.png" class="" title="网络结构示意图">

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h3><p><code>Nginx</code> 和 <code>Tunnel</code> 还有其他内部服务应处于同一个网络中。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;1.0&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.25.3</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">80</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$PWD/etc/nginx/conf.d:/etc/nginx/conf.d</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$PWD/etc/nginx/nginx.conf:/etc/nginx/nginx.conf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$PWD/log:/var/log/nginx</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my-network</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">my-network:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="etc-nginx-nginx-conf"><a href="#etc-nginx-nginx-conf" class="headerlink" title="&#x2F;etc&#x2F;nginx&#x2F;nginx.conf"></a>&#x2F;etc&#x2F;nginx&#x2F;nginx.conf</h3><p>在最后新增了拒绝未匹配成功的域名，在 <code>Cloudflare Tunnel</code> 的使用场景中，其实用处不大，因为未经配置的域名也无法解析到 <code>Nginx</code> 服务。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user  nginx;</span><br><span class="line">worker_processes  auto;</span><br><span class="line"></span><br><span class="line">error_log  /var/log/nginx/error.log notice;</span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line"></span><br><span class="line">    #以上是默认的配置内容，新增拒绝未匹配成功的域名</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80 default_server;</span><br><span class="line">        server_name _;</span><br><span class="line"></span><br><span class="line">        return 404;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="etc-nginx-conf-d"><a href="#etc-nginx-conf-d" class="headerlink" title="&#x2F;etc&#x2F;nginx&#x2F;conf.d"></a>&#x2F;etc&#x2F;nginx&#x2F;conf.d</h3><p>本目录下，配置 server 块。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    listen  [::]:80;</span><br><span class="line">    server_name  your.domain.com;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        #转发请求</span><br><span class="line">        proxy_pass http://your-service;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="正向代理和反向代理"><a href="#正向代理和反向代理" class="headerlink" title="正向代理和反向代理"></a>正向代理和反向代理</h2><h3 id="代理（正向代理）"><a href="#代理（正向代理）" class="headerlink" title="代理（正向代理）"></a>代理（正向代理）</h3><p><strong>代理</strong>（Proxy）也称为网络代理，是一种特殊的网络服务，允许一个终端通过这个服务与另一个终端进行非直接的连接。一般认为代理服务有利于保障网络终端的隐私或安全，在一定程度上能够阻止网络攻击。</p>
<img src="/2023/12/01/Nginx-reverse-proxy-for-home-networks/Pasted%20image%2020231201202645.png" class="" title="正向代理">

<h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul>
<li>提高访问速度</li>
<li>隐藏真实IP</li>
<li>突破网站的区域限制</li>
<li>突破网络审查</li>
<li>……</li>
</ul>
<h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>反向代理（Reverse Proxy）在电脑网络中是代理服务器的一种。服务器根据客户端的请求，从其关联的一组或多组后端服务器上获取资源，然后再将这些资源返回给客户端，客户端只会得知反向代理的 <code>IP</code> 地址，而不知道在代理服务器后面的服务器集群的存在。</p>
<img src="/2023/12/01/Nginx-reverse-proxy-for-home-networks/Pasted%20image%2020231201202654.png" class="" title="反向代理">

<h4 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h4><ul>
<li>对客户端隐藏服务器（集群）的 IP 地址</li>
<li>安全，可作为应用层防火墙</li>
<li><strong>负载均衡</strong></li>
<li>缓存服务，缓存静态内容和短时间内大量访问请求的动态内容</li>
<li>压缩内容，节省带宽</li>
<li>……</li>
</ul>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><table>
<thead>
<tr>
<th>正向代理</th>
<th>反向代理</th>
</tr>
</thead>
<tbody><tr>
<td>客户端的代理</td>
<td>服务端的代理</td>
</tr>
<tr>
<td>客户端一般需要特别设置</td>
<td>客户端不用做任何设置</td>
</tr>
<tr>
<td>请求发向目标服务器</td>
<td>请求发向代理</td>
</tr>
<tr>
<td>服务端知道代理不知道客户端</td>
<td>客户端知道代理不知道服务器</td>
</tr>
</tbody></table>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8">代理服务器</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86">反向代理</a></li>
</ul>
]]></content>
      <tags>
        <tag>nginx</tag>
        <tag>reverse proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring @Configuration 注解的源码分析</title>
    <url>/2023/11/23/source-code-analysis-of-Spring-Configuration-annotation/</url>
    <content><![CDATA[<p><code>Configuration</code> 注解是 <code>Spring</code> 中常用的注解，在一般的应用场景中，它用于标识一个类作为配置类，搭配 <code>Bean</code> 注解将创建的 <code>bean</code> 交给 <code>Spring</code> 容器管理。神奇的是，被 <code>Bean</code> 注解标注的方法，只会被真正调用一次。这种方法调用被拦截的情况很容易让人联想到代理，如果你在 <code>Debug</code> 时注意过配置类的实例，你会发现配置类的 <code>Class</code> 名称中携带 <code>EnhancerBySpringCGLIB</code>。本文将从源码角度，分析 <code>Configuration</code> 注解是如何工作的。</p>
<span id="more"></span>

<h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><ul>
<li>配置类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">lisi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;lisi&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(value = &quot;customName&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">person</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 测试 lisi() 在配置类拥有注解 @Configuration 时只会真正执行一次</span></span><br><span class="line">        lisi();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;wangwu&quot;</span>, <span class="number">30</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>测试类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">annotationConfigTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(BeanConfig.class);</span><br><span class="line">    <span class="type">BeanConfig</span> <span class="variable">beanConfig</span> <span class="operator">=</span> (BeanConfig) ac.getBean(<span class="string">&quot;beanConfig&quot;</span>);</span><br><span class="line">    <span class="comment">// 即使通过 beanConfig 调用，也不会执行第二次</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">lisi</span> <span class="operator">=</span> beanConfig.lisi();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="解析配置类"><a href="#解析配置类" class="headerlink" title="解析配置类"></a>解析配置类</h2><h3 id="什么是配置类？"><a href="#什么是配置类？" class="headerlink" title="什么是配置类？"></a>什么是配置类？</h3><p>通常情况下，我们称被 <code>Configuration</code> 注解标注的类为配置类。事实上，配置类的范围比这个定义稍微广泛一些，可以划分为全配置类和精简配置类。在解析配置类时，我们再进一步说明。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(BeanConfig.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... annotatedClasses)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>();</span><br><span class="line">    <span class="comment">// 注册类，几乎可以说无条件地注册 annotatedClasses 的 bean 定义</span></span><br><span class="line">    register(annotatedClasses);</span><br><span class="line">    refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本文不详细介绍配置类本身如何注册到 <code>BeanFactory</code> 中。当 <code>BeanConfig</code> 被传递给 <code>AnnotationConfigApplicationContext</code>，自身会先被解析为 <code>BeanDefinition</code> 注册到 <code>beanFactory</code> 中。有两点需要注意：</p>
<ol>
<li><code>annotatedClasses</code> 可以传入多个，意味着一开始<strong>静态指定的配置类</strong>可以有多个。</li>
<li><code>annotatedClasses</code> 除了在命名上提示用户应传入被注解的类外，<code>register(annotatedClasses)</code> 实际上只是将它们视作普通的 <code>Bean</code> 注册到 <code>beanFactory</code> 中。它们是从外界传入的**首批 <code>BeanDefinition</code>**。</li>
</ol>
<p>之后 <code>Spring</code> 进入 <code>refresh</code> 流程。使用 <code>IDEA Debug</code> 观察此时的 <code>beanDefinitionMap</code>，除了 <code>beanConfig</code> 外，<code>AnnotationConfigApplicationContext</code> 在创建时，已经自动注册了 <code>6</code> 个 <code>bean</code> 定义，其中一个就是我们今天的主角 <code>org.springframework.context.annotation.internalConfigurationAnnotationProcessor -&gt; org.springframework.context.annotation.ConfigurationClassPostProcessor</code>。显而易见，此时配置类还未被处理得到新的 <code>bean</code> 定义。</p>
<div style="width:70%;margin:auto"><img src="/2023/11/23/source-code-analysis-of-Spring-Configuration-annotation/Snipaste_2023-11-24_15-26-08.png" class="" title="AnnotationConfigApplicationContext 刷新前的 bean 定义"></div>

<h3 id="配置类后处理器-ConfigurationClassPostProcessor"><a href="#配置类后处理器-ConfigurationClassPostProcessor" class="headerlink" title="配置类后处理器 ConfigurationClassPostProcessor"></a>配置类后处理器 ConfigurationClassPostProcessor</h3><p>配置类后处理器 <code>ConfigurationClassPostProcessor</code> 实现了接口 <code>BeanDefinitionRegistryPostProcessor</code>，也因此同时实现了接口 <code>BeanFactoryPostProcessor</code>。在<a href="/2023/08/04/Spring-application-context-refresh-process/" title="Spring 应用 context 刷新流程">Spring 应用 context 刷新流程</a>中，我们介绍过这两个接口，它们作为工厂后处理器，被用于 <code>refresh</code> 过程的<strong>调用工厂后处理器阶段</strong>（<code>invokeBeanFactoryPostProcessors(beanFactory)</code>）。工厂后处理器的作用，一言以蔽之，允许自定义修改应用上下文中的 bean 定义。</p>
<p>配置类后处理器 <code>ConfigurationClassPostProcessor</code> 的具体作用可以概括为两点：</p>
<ol>
<li>解析配置类中配置的 <code>Bean</code>，将它们的 <code>bean</code> 定义注册到 <code>BeanFactory</code> 中。</li>
<li>（如有必要）增强配置类</li>
</ol>
<h3 id="处理配置类的核心方法-processConfigBeanDefinitions"><a href="#处理配置类的核心方法-processConfigBeanDefinitions" class="headerlink" title="处理配置类的核心方法 processConfigBeanDefinitions"></a>处理配置类的核心方法 processConfigBeanDefinitions</h3><p>根据之前的介绍，进入 <code>invokeBeanFactoryPostProcessors(beanFactory)</code>，<code>ConfigurationClassPostProcessor</code> 会先作为 <code>BeanDefinitionRegistryPostProcessor</code> 被调用。</p>
<blockquote>
<p>个人的理解是，先将 <code>BeanFactory</code> 视作 <code>BeanDefinitionRegistry</code> 注册好 <code>BeanDefinition</code>，再视作 <code>BeanFactory</code> 进行处理，有点预备好原材料再统一处理的意思。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 处理配置的 BeanDefinition</span></span><br><span class="line">    processConfigBeanDefinitions(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>核心方法 <code>processConfigBeanDefinitions(registry)</code> 冗长，个人建议无需过度关注细节（但同时个人感受是反复阅读和 <code>Debug</code> 确实有益于加深理解，看个人时间和精力）。</p>
</blockquote>
<p>基于配置类的 <code>BeanDefinition Registry</code>（也就是 <code>BeanFactory</code>），获取配置类，构建和校验配置模型：</p>
<ol>
<li>从 <code>BeanDefinition Registry</code>（即 <code>BeanFactory</code>）中查找配置类。</li>
<li>解析配置类得到<strong>配置模型</strong>，从模型中读取 <code>BeanDefinitions</code> 注册到 <code>BeanDefinition Registry</code>。</li>
<li>新的 <code>BeanDefinitions</code> 可能有新的配置类，回到 <code>1</code> 再来一遍。重复循环直到不再引入新的配置类。</li>
</ol>
<p>以本文示例进行说明，静态添加的配置类只有 <code>BeanConfig</code>，假如 <code>BeanConfig</code> 不仅被 <code>Configuration</code> 注解标注，还被 <code>ComponentScan</code> 注解标注，并且刚好 <code>Spring</code> 通过扫描获得并添加了新的配置类，那么新的配置类就需要继续被解析。</p>
<blockquote>
<p>应正视<strong>配置模型</strong>这个概念，它可以理解为配置类到 <code>BeanDefinitions</code> 的中间产物。最初我先入为主，带着<code>解析得到 BeanDefinitions</code> 这样“一阶段”完成的观念，非常不理解 <code>processConfigBeanDefinitions</code> 方法上 <code>Build and validate a configuration model based on the registry of Configuration classes</code> 这句注释。先行强调注意，<strong>处理配置类得到 <code>bean</code> 定义分为“两阶段”，解析配置类得到配置模型，从配置模型中读取 <code>bean</code> 定义</strong>。</p>
</blockquote>
<div style="width:60%;margin:auto"><img src="/2023/11/23/source-code-analysis-of-Spring-Configuration-annotation/Pasted%20image%2020231127205117.png" class="" title="处理配置类的过程"></div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processConfigBeanDefinitions</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">    List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;BeanDefinitionHolder&gt;();</span><br><span class="line">    <span class="comment">// 刚开始，获取全部的 BeanDefinitions 作为候选</span></span><br><span class="line">    String[] candidateNames = registry.getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">beanDef</span> <span class="operator">=</span> registry.getBeanDefinition(beanName);</span><br><span class="line">        <span class="keyword">if</span> (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||</span><br><span class="line">                ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) &#123;</span><br><span class="line">            <span class="comment">// 根据 beanDef 的 attributes 判断是 Full 还是 Lite 的配置类</span></span><br><span class="line">            <span class="comment">// 已经处理过的配置类，会在 attributes 中添加标识</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Bean definition has already been processed as a configuration class: &quot;</span> + beanDef);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="built_in">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">            <span class="comment">// 未处理过的候选者，检查是否是配置类。</span></span><br><span class="line">            <span class="comment">// configCandidates 的命名让人有些困惑，个人认为这里指代的就是配置类</span></span><br><span class="line">            configCandidates.add(<span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(beanDef, beanName));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return immediately if no @Configuration classes were found</span></span><br><span class="line">    <span class="comment">// 和注释略有不符，配置类的判定没有这么单一，不仅限于 @Configuration 注解的 Full 配置类</span></span><br><span class="line">    <span class="keyword">if</span> (configCandidates.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 attributes 中的 order 排序（来源于 @Order 注解，可能不存在）</span></span><br><span class="line">    Collections.sort(configCandidates, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;BeanDefinitionHolder&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());</span><br><span class="line">            <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());</span><br><span class="line">            <span class="keyword">return</span> (i1 &lt; i2) ? -<span class="number">1</span> : (i1 &gt; i2) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测应用上下文中是否配置了自定义 bean 名称生成策略</span></span><br><span class="line">    <span class="type">SingletonBeanRegistry</span> <span class="variable">sbr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (registry <span class="keyword">instanceof</span> SingletonBeanRegistry) &#123;</span><br><span class="line">        sbr = (SingletonBeanRegistry) registry;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.localBeanNameGeneratorSet &amp;&amp; sbr.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) &#123;</span><br><span class="line">            <span class="comment">// 如果 localBeanNameGenerator 未设置，且 SingletonBeanRegistry 中存在，就获取并使用</span></span><br><span class="line">            <span class="type">BeanNameGenerator</span> <span class="variable">generator</span> <span class="operator">=</span> (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);</span><br><span class="line">            <span class="built_in">this</span>.componentScanBeanNameGenerator = generator;</span><br><span class="line">            <span class="built_in">this</span>.importBeanNameGenerator = generator;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 ConfigurationClassParser，解析每一个配置类（不限于 Full 类型）</span></span><br><span class="line">    <span class="type">ConfigurationClassParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigurationClassParser</span>(</span><br><span class="line">            <span class="built_in">this</span>.metadataReaderFactory, <span class="built_in">this</span>.problemReporter, <span class="built_in">this</span>.environment,</span><br><span class="line">            <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.componentScanBeanNameGenerator, registry);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置类候选</span></span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; candidates = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;BeanDefinitionHolder&gt;(configCandidates);</span><br><span class="line">    <span class="comment">// 处理过的配置模型，已经被读取过 Bean 定义</span></span><br><span class="line">    <span class="comment">// 个人感觉命名为 alreadyRead 更为准确</span></span><br><span class="line">    Set&lt;ConfigurationClass&gt; alreadyParsed = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;ConfigurationClass&gt;(configCandidates.size());</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 解析</span></span><br><span class="line">        parser.parse(candidates);</span><br><span class="line">        <span class="comment">// 校验</span></span><br><span class="line">        parser.validate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 parser 中获取 ConfigurationClass，这就是配置模型（忍不住吐槽一下这个命名和配置类好容易搞混）</span></span><br><span class="line">        Set&lt;ConfigurationClass&gt; configClasses = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;ConfigurationClass&gt;(parser.getConfigurationClasses());</span><br><span class="line">        <span class="comment">// 排除已经读取过 Bean 定义的 ConfigurationClass</span></span><br><span class="line">        configClasses.removeAll(alreadyParsed);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read the model and create bean definitions based on its content</span></span><br><span class="line">        <span class="comment">// 读取模型并根据它的内容创建 BeanDefinitions</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.reader == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.reader = <span class="keyword">new</span> <span class="title class_">ConfigurationClassBeanDefinitionReader</span>(</span><br><span class="line">                    registry, <span class="built_in">this</span>.sourceExtractor, <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.environment,</span><br><span class="line">                    <span class="built_in">this</span>.importBeanNameGenerator, parser.getImportRegistry());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 加载（读取并注册） BeanDefinitions</span></span><br><span class="line">        <span class="built_in">this</span>.reader.loadBeanDefinitions(configClasses);</span><br><span class="line">        <span class="comment">// 添加到已经读取过的配置模型集合中（上面的 configClasses.removeAll(alreadyParsed) 造成的干扰好大）</span></span><br><span class="line">        alreadyParsed.addAll(configClasses);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清空这一轮处理的配置类集合</span></span><br><span class="line">        candidates.clear();</span><br><span class="line">        <span class="comment">// 通过 registry 中的 BeanDefinitions 数量判断是否有新增的 BeanDefinitions</span></span><br><span class="line">        <span class="keyword">if</span> (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123;</span><br><span class="line">            <span class="comment">// 重新获取全部 BeanDefinitions 作为候选</span></span><br><span class="line">            String[] newCandidateNames = registry.getBeanDefinitionNames();</span><br><span class="line">            <span class="comment">// 保留旧的候选集合用于快速筛选</span></span><br><span class="line">            Set&lt;String&gt; oldCandidateNames = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;(Arrays.asList(candidateNames));</span><br><span class="line">            <span class="comment">// 为什么 alreadyParsedClasses 不定义在循环外，需要每次动态地从 alreadyParsed 获取？难道 configurationClass.getMetadata().getClassName() 的结果会变化吗？</span></span><br><span class="line">            <span class="comment">// 如果不存在上述情况，直接在添加到 alreadyParsed 时，添加到 alreadyParsedClasses 就好了呀？</span></span><br><span class="line">            Set&lt;String&gt; alreadyParsedClasses = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">            <span class="keyword">for</span> (ConfigurationClass configurationClass : alreadyParsed) &#123;</span><br><span class="line">                alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (String candidateName : newCandidateNames) &#123;</span><br><span class="line">                <span class="comment">// 快速地排除旧候选</span></span><br><span class="line">                <span class="keyword">if</span> (!oldCandidateNames.contains(candidateName)) &#123;</span><br><span class="line">                    <span class="type">BeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> registry.getBeanDefinition(candidateName);</span><br><span class="line">                    <span class="comment">// 检查是否是配置类并且未被解析过（比如同一个配置类，重复注册，无需多次处理）</span></span><br><span class="line">                    <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, <span class="built_in">this</span>.metadataReaderFactory) &amp;&amp;</span><br><span class="line">                            !alreadyParsedClasses.contains(bd.getBeanClassName())) &#123;</span><br><span class="line">                        <span class="comment">// 添加到新的配置类集合</span></span><br><span class="line">                        candidates.add(<span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(bd, candidateName));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            candidateNames = newCandidateNames;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!candidates.isEmpty());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes</span></span><br><span class="line">    <span class="keyword">if</span> (sbr != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) &#123;</span><br><span class="line">            sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理 metadataReaderFactory 缓存</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.metadataReaderFactory <span class="keyword">instanceof</span> CachingMetadataReaderFactory) &#123;</span><br><span class="line">        ((CachingMetadataReaderFactory) <span class="built_in">this</span>.metadataReaderFactory).clearCache();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断是否是配置类"><a href="#判断是否是配置类" class="headerlink" title="判断是否是配置类"></a>判断是否是配置类</h3><p><code>checkConfigurationClassCandidate</code> 方法：</p>
<ol>
<li>不能 <code>className</code> 为 <code>null</code> 或 <code>Bean</code> 定义拥有工厂方法</li>
<li>被 <code>Configuration</code> 注解标注（全配置类）</li>
<li>被 <code>Component</code>、<code>ComponentScan</code>、<code>Import</code>、<code>ImportResource</code> 注解标注或者拥有被 <code>Bean</code> 注解标注的方法</li>
<li>设置 <code>order</code> 用于排序</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkConfigurationClassCandidate</span><span class="params">(BeanDefinition beanDef, MetadataReaderFactory metadataReaderFactory)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> beanDef.getBeanClassName();</span><br><span class="line">    <span class="keyword">if</span> (className == <span class="literal">null</span> || beanDef.getFactoryMethodName() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果 className 为 null，或者拥有工厂方法，返回 false</span></span><br><span class="line">        <span class="comment">// 举例，被 @Bean 注解的方法返回的 Bean，它的类即使被 @Configuration 注解，也不属于配置类</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 AnnotationMetadata</span></span><br><span class="line">    <span class="comment">// 这些分支对应的场景？</span></span><br><span class="line">    AnnotationMetadata metadata;</span><br><span class="line">    <span class="keyword">if</span> (beanDef <span class="keyword">instanceof</span> AnnotatedBeanDefinition &amp;&amp;</span><br><span class="line">            className.equals(((AnnotatedBeanDefinition) beanDef).getMetadata().getClassName())) &#123;</span><br><span class="line">        <span class="comment">// 可以复用 BeanDefinition 中已经解析过的 metadata</span></span><br><span class="line">        metadata = ((AnnotatedBeanDefinition) beanDef).getMetadata();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (beanDef <span class="keyword">instanceof</span> AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) beanDef).hasBeanClass()) &#123;</span><br><span class="line">        <span class="comment">// 检查是否存在已经加载的 Class，因为我们可能甚至无法加载该类的类文件</span></span><br><span class="line">        <span class="comment">// 创建 metadata 看起来也没干什么事情呀</span></span><br><span class="line">        Class&lt;?&gt; beanClass = ((AbstractBeanDefinition) beanDef).getBeanClass();</span><br><span class="line">        metadata = <span class="keyword">new</span> <span class="title class_">StandardAnnotationMetadata</span>(beanClass, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 第二个分支提到的无法加载类文件的情况是指这里吗？</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">MetadataReader</span> <span class="variable">metadataReader</span> <span class="operator">=</span> metadataReaderFactory.getMetadataReader(className);</span><br><span class="line">            metadata = metadataReader.getAnnotationMetadata();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Could not find class file for introspecting configuration annotations: &quot;</span> + className, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isFullConfigurationCandidate(metadata)) &#123;</span><br><span class="line">        <span class="comment">// 属于 Full 配置类，添加 Attribute 标记，标识已处理过</span></span><br><span class="line">        beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (isLiteConfigurationCandidate(metadata)) &#123;</span><br><span class="line">        <span class="comment">// 属于 Lite 配置类，添加 Attribute 标记，标识已处理过</span></span><br><span class="line">        beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不管是 Full 还是 Lite 配置类，检查是否被 @Order 注解，如果有则设置到 Attribute，用于排序</span></span><br><span class="line">    Map&lt;String, Object&gt; orderAttributes = metadata.getAnnotationAttributes(Order.class.getName());</span><br><span class="line">    <span class="keyword">if</span> (orderAttributes != <span class="literal">null</span>) &#123;</span><br><span class="line">        beanDef.setAttribute(ORDER_ATTRIBUTE, orderAttributes.get(AnnotationUtils.VALUE));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断是否属于-Full-配置类"><a href="#判断是否属于-Full-配置类" class="headerlink" title="判断是否属于 Full 配置类"></a>判断是否属于 Full 配置类</h4><ol>
<li>被 <code>Configuration</code> 注解标注</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isFullConfigurationCandidate</span><span class="params">(AnnotationMetadata metadata)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> metadata.isAnnotated(Configuration.class.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断是否属于-Lite-配置类"><a href="#判断是否属于-Lite-配置类" class="headerlink" title="判断是否属于 Lite 配置类"></a>判断是否属于 Lite 配置类</h4><ol>
<li>被 <code>Component</code>、<code>ComponentScan</code>、<code>Import</code>、<code>ImportResource</code> 注解标注</li>
<li>拥有被 <code>Bean</code> 注解标注的方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isLiteConfigurationCandidate</span><span class="params">(AnnotationMetadata metadata)</span> &#123;</span><br><span class="line">    <span class="comment">// 接口和注解，直接返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (metadata.isInterface()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果被 @Component、@ComponentScan、@Import、@ImportResource 注解</span></span><br><span class="line">    <span class="keyword">for</span> (String indicator : candidateIndicators) &#123;</span><br><span class="line">        <span class="keyword">if</span> (metadata.isAnnotated(indicator)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拥有被 @Bean 注解的方法</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> metadata.hasAnnotatedMethods(Bean.class.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Failed to introspect @Bean methods on class [&quot;</span> + metadata.getClassName() + <span class="string">&quot;]: &quot;</span> + ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环处理直至没有新增配置类"><a href="#循环处理直至没有新增配置类" class="headerlink" title="循环处理直至没有新增配置类"></a>循环处理直至没有新增配置类</h3><p>循环处理部分的代码有点难阅读。</p>
<ul>
<li>首先是因为命名比较相似，需要理清各个变量的含义和作用<ul>
<li><code>candidateNames</code> 就是普普通通的纯候选者（全部 <code>BeanDefinitions</code>），每次循环在解析完，加载 <code>BeanDefinitions</code> 后可能会新增</li>
<li><code>configCandidates</code>（<code>candidates</code>） 就是符合配置类条件的配置类。虽然命名带 <code>Candidates</code>，其实已经是正牌，并非候选。感觉 <code>configClass</code> 更容易理解，但该变量名另作他用。有新增就要继续循环</li>
<li><code>configClass</code>（<code>ConfigurationClass</code> 类） 是经过解析的配置模型，不要和配置类搞混了。后面出现过 <code>ConfigurationModel</code>，感觉该命名更加准确</li>
</ul>
</li>
<li>其次是因为对黑盒 parser 的作用不了解，个人经验如果完全将 <code>parser</code> 当作黑盒对待，不了解解析过程、解析的返回结果以及如何处理返回结果，理解循环解析的过程时会有点困难<ul>
<li><code>parser.parse(candidates)</code> 解析配置类构建得到配置模型（<code>ConfigurationClass</code>）。以副作用的形式进行处理，传入 <code>ConfigurationClass</code>，返回 <code>ConfigurationClass</code></li>
<li><code>this.reader.loadBeanDefinitions(configClasses)</code> 从配置模型（<code>ConfigurationClass</code>）中加载 <code>BeanDefinitions</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>再次提示：<strong>正视配置模型的概念，<code>ConfigurationClassParser</code> 使用配置类构建配置模型并校验；<code>ConfigurationClassBeanDefinitionReader</code> 从配置模型中读取 <code>bean</code> 定义。</strong></p>
</blockquote>
<div style="width:50%;margin:auto"><img src="/2023/11/23/source-code-analysis-of-Spring-Configuration-annotation/Pasted%20image%2020231127214511.png" class="" title="处理配置类流程图"></div>

<h3 id="解析配置类构建配置模型"><a href="#解析配置类构建配置模型" class="headerlink" title="解析配置类构建配置模型"></a>解析配置类构建配置模型</h3><p><code>parser.parse(candidates)</code> 正式进入解析过程，<code>ConfigurationClassParser</code> 负责将配置类转换为配置模型（<code>ConfigurationClass</code>）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; configCandidates)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.deferredImportSelectors = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;DeferredImportSelectorHolder&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环依次处理配置类</span></span><br><span class="line">    <span class="keyword">for</span> (BeanDefinitionHolder holder : configCandidates) &#123;</span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> holder.getBeanDefinition();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">                <span class="comment">// 拥有注解的 BeanDefinition</span></span><br><span class="line">                parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) &#123;</span><br><span class="line">                parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                parse(bd.getBeanClassName(), holder.getBeanName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">                    <span class="string">&quot;Failed to parse configuration class [&quot;</span> + bd.getBeanClassName() + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    processDeferredImportSelectors();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次都创建一个新的配置模型 <code>ConfigurationClass</code>，最终处理结果以副作用的形式直接表现在配置模型上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">(AnnotationMetadata metadata, String beanName)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 每次都 new 一个 ConfigurationClass</span></span><br><span class="line">    processConfigurationClass(<span class="keyword">new</span> <span class="title class_">ConfigurationClass</span>(metadata, beanName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div style="width:50%;margin:auto"><img src="/2023/11/23/source-code-analysis-of-Spring-Configuration-annotation/Pasted%20image%2020231127215414.png" class="" title="处理配置模型"></div>

<p>处理配置模型的方法 <code>processConfigurationClass</code>。</p>
<ol>
<li>检查配置模型是否曾经处理过</li>
<li>处理配置模型（递归处理配置类和它的父类）</li>
</ol>
<p><code>SourceClass</code> 是一个简单的包装器，无论带注解的源类是如何被加载的，允许以统一的方式处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processConfigurationClass</span><span class="params">(ConfigurationClass configClass)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 判断是否跳过</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ConfigurationClass 重写了 equals 和 hashCode 方法</span></span><br><span class="line">    <span class="type">ConfigurationClass</span> <span class="variable">existingClass</span> <span class="operator">=</span> <span class="built_in">this</span>.configurationClasses.get(configClass);</span><br><span class="line">    <span class="comment">// 判断是否已经存在</span></span><br><span class="line">    <span class="keyword">if</span> (existingClass != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 检查是否是导入的</span></span><br><span class="line">        <span class="keyword">if</span> (configClass.isImported()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (existingClass.isImported()) &#123;</span><br><span class="line">                <span class="comment">// 如果新的旧的 isImported 均为 true，合并 ImportedBy 集合</span></span><br><span class="line">                existingClass.mergeImportedBy(configClass);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Otherwise ignore new imported config class; existing non-imported class overrides it.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 可能找到了一个显式定义的配置类，用于代替导入的，直接移除旧的</span></span><br><span class="line">            <span class="built_in">this</span>.configurationClasses.remove(configClass);</span><br><span class="line">            <span class="keyword">for</span> (Iterator&lt;ConfigurationClass&gt; it = <span class="built_in">this</span>.knownSuperclasses.values().iterator(); it.hasNext();) &#123;</span><br><span class="line">                <span class="keyword">if</span> (configClass.equals(it.next())) &#123;</span><br><span class="line">                    it.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归处理配置类和它的父类</span></span><br><span class="line">    <span class="type">SourceClass</span> <span class="variable">sourceClass</span> <span class="operator">=</span> asSourceClass(configClass);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        sourceClass = doProcessConfigurationClass(configClass, sourceClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (sourceClass != <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存处理过的配置模型</span></span><br><span class="line">    <span class="built_in">this</span>.configurationClasses.put(configClass, configClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 <code>ConfigurationClass</code> 重写了 <code>equals</code> 和 <code>hashCode</code> 方法，<code>metadata</code> 的 <code>className</code> 相同代表配置模型也相同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object other)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span> == other || (other <span class="keyword">instanceof</span> ConfigurationClass &amp;&amp;</span><br><span class="line">            getMetadata().getClassName().equals(((ConfigurationClass) other).getMetadata().getClassName())));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getMetadata().getClassName().hashCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>真正处理配置模型的方法，根据注释很容易知道，如果配置类携带了 <code>PropertySource</code>、<code>ComponentScan</code>、<code>Import</code>、<code>ImportResource</code>、<code>Bean</code> 等注解，就是在这里被处理的。<br>比如示例中被 <code>Bean</code> 注解标注的方法，<code>configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass))</code> 将它以 <code>BeanMethod</code> 的形式添加到配置模型中。</p>
<ol>
<li>先递归的处理成员（嵌套）类</li>
<li>处理 <code>@PropertySource</code></li>
<li>处理 <code>@ComponentScan</code></li>
<li>处理 <code>@Import</code></li>
<li>处理 <code>@ImportResource</code></li>
<li>处理 <code>@Bean</code>，<strong>使用 <code>ASM</code> 代替 <code>JVM</code> 反射，以获得确定性的声明顺序</strong></li>
<li>处理接口的默认方法</li>
<li>检查是否有父类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> SourceClass <span class="title function_">doProcessConfigurationClass</span><span class="params">(ConfigurationClass configClass, SourceClass sourceClass)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recursively process any member (nested) classes first</span></span><br><span class="line">    processMemberClasses(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process any @PropertySource annotations</span></span><br><span class="line">    <span class="keyword">for</span> (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">            sourceClass.getMetadata(), PropertySources.class,</span><br><span class="line">            org.springframework.context.annotation.PropertySource.class)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.environment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">            processPropertySource(propertySource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Ignoring @PropertySource annotation on [&quot;</span> + sourceClass.getMetadata().getClassName() +</span><br><span class="line">                    <span class="string">&quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process any @ComponentScan annotations</span></span><br><span class="line">    Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">            sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);</span><br><span class="line">    <span class="keyword">if</span> (!componentScans.isEmpty() &amp;&amp;</span><br><span class="line">            !<span class="built_in">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line">            <span class="comment">// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span></span><br><span class="line">            Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line">                    <span class="built_in">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line">            <span class="comment">// Check the set of scanned definitions for any further config classes and parse recursively if needed</span></span><br><span class="line">            <span class="keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(</span><br><span class="line">                        holder.getBeanDefinition(), <span class="built_in">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process any @Import annotations</span></span><br><span class="line">    processImports(configClass, sourceClass, getImports(sourceClass), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process any @ImportResource annotations</span></span><br><span class="line">    <span class="keyword">if</span> (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) &#123;</span><br><span class="line">        <span class="type">AnnotationAttributes</span> <span class="variable">importResource</span> <span class="operator">=</span></span><br><span class="line">                AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);</span><br><span class="line">        String[] resources = importResource.getStringArray(<span class="string">&quot;locations&quot;</span>);</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">BeanDefinitionReader</span>&gt; readerClass = importResource.getClass(<span class="string">&quot;reader&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String resource : resources) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">resolvedResource</span> <span class="operator">=</span> <span class="built_in">this</span>.environment.resolveRequiredPlaceholders(resource);</span><br><span class="line">            configClass.addImportedResource(resolvedResource, readerClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process individual @Bean methods</span></span><br><span class="line">    Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);</span><br><span class="line">    <span class="keyword">for</span> (MethodMetadata methodMetadata : beanMethods) &#123;</span><br><span class="line">        configClass.addBeanMethod(<span class="keyword">new</span> <span class="title class_">BeanMethod</span>(methodMetadata, configClass));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process default methods on interfaces</span></span><br><span class="line">    processInterfaces(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有父类，且之前没有处理过，返回父类继续处理</span></span><br><span class="line">    <span class="keyword">if</span> (sourceClass.getMetadata().hasSuperClass()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">superclass</span> <span class="operator">=</span> sourceClass.getMetadata().getSuperClassName();</span><br><span class="line">        <span class="keyword">if</span> (!superclass.startsWith(<span class="string">&quot;java&quot;</span>) &amp;&amp; !<span class="built_in">this</span>.knownSuperclasses.containsKey(superclass)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.knownSuperclasses.put(superclass, configClass);</span><br><span class="line">            <span class="comment">// Superclass found, return its annotation metadata and recurse</span></span><br><span class="line">            <span class="keyword">return</span> sourceClass.getSuperClass();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No superclass -&gt; processing is complete</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读取配置模型，加载-Bean-定义"><a href="#读取配置模型，加载-Bean-定义" class="headerlink" title="读取配置模型，加载 Bean 定义"></a>读取配置模型，加载 Bean 定义</h3><p><code>this.reader.loadBeanDefinitions(configClasses)</code> 读取配置模型的内容，注册 <code>BeanDefinitions</code> 到 <code>BeanDefinition Registry</code>（也就是 <code>BeanFactory</code>）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(Set&lt;ConfigurationClass&gt; configurationModel)</span> &#123;</span><br><span class="line">    <span class="type">TrackedConditionEvaluator</span> <span class="variable">trackedConditionEvaluator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrackedConditionEvaluator</span>();</span><br><span class="line">    <span class="comment">// 叫 ConfigurationModel 多好啊，ConfigurationClass 真让人容易误解</span></span><br><span class="line">    <span class="keyword">for</span> (ConfigurationClass configClass : configurationModel) &#123;</span><br><span class="line">        loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理单独的一个配置模型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitionsForConfigurationClass</span><span class="params">(ConfigurationClass configClass,</span></span><br><span class="line"><span class="params">        TrackedConditionEvaluator trackedConditionEvaluator)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (trackedConditionEvaluator.shouldSkip(configClass)) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> configClass.getBeanName();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="built_in">this</span>.registry.containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.registry.removeBeanDefinition(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.importRegistry.removeImportingClass(configClass.getMetadata().getClassName());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (configClass.isImported()) &#123;</span><br><span class="line">        registerBeanDefinitionForImportedConfigurationClass(configClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (BeanMethod beanMethod : configClass.getBeanMethods()) &#123;</span><br><span class="line">        loadBeanDefinitionsForBeanMethod(beanMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());</span><br><span class="line">    loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="增强配置类"><a href="#增强配置类" class="headerlink" title="增强配置类"></a>增强配置类</h2><p>我们在介绍 <code>ConfigurationClassPostProcessor</code> 时提过，它既实现了接口 <code>BeanDefinitionRegistryPostProcessor</code>，也因此同时实现了接口 <code>BeanFactoryPostProcessor</code>。在 <code>invokeBeanFactoryPostProcessors(beanFactory)</code> 阶段，调用 <code>postProcessBeanDefinitionRegistry</code> 方法，成功注册配置类引入的 <code>Bean</code> 后，紧接着会调用 <code>postProcessBeanFactory</code> 方法，增强配置类本身。</p>
<blockquote>
<p><code>ConfigurationClasses</code> 在之前还是指配置模型，这里就又指配置类了。。。真让人头秃。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增强配置类</span></span><br><span class="line">    enhanceConfigurationClasses(beanFactory);</span><br><span class="line">    <span class="comment">// 添加后处理器 ImportAwareBeanPostProcessor</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ImportAwareBeanPostProcessor</span>(beanFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="增强所有-Full-类型配置类"><a href="#增强所有-Full-类型配置类" class="headerlink" title="增强所有 Full 类型配置类"></a>增强所有 Full 类型配置类</h3><ol>
<li>查找所有 <code>Full</code> 类型的配置类</li>
<li>依次使用 <code>ConfigurationClassEnhancer</code> 增强目标类，成功则替换 <code>BeanClass</code>（不成功的情况是已经增强过）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enhanceConfigurationClasses</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    Map&lt;String, AbstractBeanDefinition&gt; configBeanDefs = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;String, AbstractBeanDefinition&gt;();</span><br><span class="line">    <span class="comment">// 获取全部的 BeanDefinitions 检查是否存在全配置类（FullConfigurationClass）</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanFactory.getBeanDefinitionNames()) &#123;</span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">beanDef</span> <span class="operator">=</span> beanFactory.getBeanDefinition(beanName);</span><br><span class="line">        <span class="keyword">if</span> (ConfigurationClassUtils.isFullConfigurationClass(beanDef)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(beanDef <span class="keyword">instanceof</span> AbstractBeanDefinition)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(<span class="string">&quot;Cannot enhance @Configuration bean definition &#x27;&quot;</span> +</span><br><span class="line">                        beanName + <span class="string">&quot;&#x27; since it is not stored in an AbstractBeanDefinition subclass&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (logger.isWarnEnabled() &amp;&amp; beanFactory.containsSingleton(beanName)) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Cannot enhance @Configuration bean definition &#x27;&quot;</span> + beanName +</span><br><span class="line">                        <span class="string">&quot;&#x27; since its singleton instance has been created too early. The typical cause &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;is a non-static @Bean method with a BeanDefinitionRegistryPostProcessor &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;return type: Consider declaring such methods as &#x27;static&#x27;.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (configBeanDefs.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过 CGLib 增强</span></span><br><span class="line">    <span class="type">ConfigurationClassEnhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigurationClassEnhancer</span>();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, AbstractBeanDefinition&gt; entry : configBeanDefs.entrySet()) &#123;</span><br><span class="line">        <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDef</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">        <span class="comment">// 如果被 @Configuration 注解的类被代理，则始终代理目标类（proxy target class），在 Attributes 中标记</span></span><br><span class="line">        beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; configClass = beanDef.resolveBeanClass(<span class="built_in">this</span>.beanClassLoader);</span><br><span class="line">            Class&lt;?&gt; enhancedClass = enhancer.enhance(configClass, <span class="built_in">this</span>.beanClassLoader);</span><br><span class="line">            <span class="keyword">if</span> (configClass != enhancedClass) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(String.format(<span class="string">&quot;Replacing bean definition &#x27;%s&#x27; existing class &#x27;%s&#x27; with &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;enhanced class &#x27;%s&#x27;&quot;</span>, entry.getKey(), configClass.getName(), enhancedClass.getName()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果成功增强，则替换掉 BeanClass</span></span><br><span class="line">                beanDef.setBeanClass(enhancedClass);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Cannot load configuration class: &quot;</span> + beanDef.getBeanClassName(), ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>如果增强过则不再处理。这往往代表容器中存在多个 <code>ConfigurationClassPostProcessor</code>，虽然无害，但是建议调整配置</li>
<li>如果未曾增强过，则创建增强类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; enhance(Class&lt;?&gt; configClass, ClassLoader classLoader) &#123;</span><br><span class="line">    <span class="comment">// 增强过的类都实现了 EnhancedConfiguration，因此可以起到标识作用</span></span><br><span class="line">    <span class="keyword">if</span> (EnhancedConfiguration.class.isAssignableFrom(configClass)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(String.format(<span class="string">&quot;Ignoring request to enhance %s as it has &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;already been enhanced. This usually indicates that more than one &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;ConfigurationClassPostProcessor has been registered (e.g. via &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;&lt;context:annotation-config&gt;). This is harmless, but you may &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;want check your configuration and remove one CCPP if possible&quot;</span>,</span><br><span class="line">                    configClass.getName()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> configClass;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建增强类</span></span><br><span class="line">    Class&lt;?&gt; enhancedClass = createClass(newEnhancer(configClass, classLoader));</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(String.format(<span class="string">&quot;Successfully enhanced %s; enhanced class name is: %s&quot;</span>,</span><br><span class="line">                configClass.getName(), enhancedClass.getName()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enhancedClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建-CGLib-子类"><a href="#创建-CGLib-子类" class="headerlink" title="创建 CGLib 子类"></a>创建 CGLib 子类</h3><blockquote>
<p>如果完全不熟悉 <code>CGLib</code>，可以单独查阅一下相关资料，稍作了解。</p>
</blockquote>
<p>创建 <code>Enhancer</code>，并设置属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Enhancer <span class="title function_">newEnhancer</span><span class="params">(Class&lt;?&gt; superclass, ClassLoader classLoader)</span> &#123;</span><br><span class="line">    <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">    <span class="comment">// 设置被增强的类为父类</span></span><br><span class="line">    enhancer.setSuperclass(superclass);</span><br><span class="line">    <span class="comment">// 设置接口，可以用于标识类被增强过</span></span><br><span class="line">    enhancer.setInterfaces(<span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123;EnhancedConfiguration.class&#125;);</span><br><span class="line">    enhancer.setUseFactory(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 设置命名策略，BySpringCGLIB 后缀</span></span><br><span class="line">    enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">    <span class="comment">// 设置生成策略，这里为 CGLib 子类新增一个 $$beanFactory 属性</span></span><br><span class="line">    enhancer.setStrategy(<span class="keyword">new</span> <span class="title class_">BeanFactoryAwareGeneratorStrategy</span>(classLoader));</span><br><span class="line">    <span class="comment">// 设置 CallbackFilter，用于方法匹配</span></span><br><span class="line">    enhancer.setCallbackFilter(CALLBACK_FILTER);</span><br><span class="line">    enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes());</span><br><span class="line">    <span class="keyword">return</span> enhancer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>所有因为 <code>Configuration</code> 注解而被增强的配置类，它的 <code>CGLib</code> 子类都实现了这个标记接口，用于检查候选类是否已经增强过，避免重复增强。</li>
<li>该接口继承了 <code>BeanFactoryAware</code>。**创建得到的 <code>CGLib</code> 子类必须能够访问 <code>BeanFactory</code>**，用以在工厂方法交叉调用时获取已经创建的 <code>Bean</code> 而非真正执行。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EnhancedConfiguration</span> <span class="keyword">extends</span> <span class="title class_">BeanFactoryAware</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建子类，并注册静态回调。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; createClass(Enhancer enhancer) &#123;</span><br><span class="line">    Class&lt;?&gt; subclass = enhancer.createClass();</span><br><span class="line">    <span class="comment">// 注册静态回调（虽然注释不太理解）</span></span><br><span class="line">    Enhancer.registerStaticCallbacks(subclass, CALLBACKS);</span><br><span class="line">    <span class="keyword">return</span> subclass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CALLBACKS</code>、<code>CALLBACK_FILTER</code> 和 <code>$$beanFactory</code> 属性名都是 <code>ConfigurationClassEnhancer</code> 的静态属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConfigurationClassEnhancer</span> &#123;</span><br><span class="line">    <span class="comment">// The callbacks to use. Note that these callbacks must be stateless.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Callback[] CALLBACKS = <span class="keyword">new</span> <span class="title class_">Callback</span>[] &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">BeanMethodInterceptor</span>(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">BeanFactoryAwareMethodInterceptor</span>(),</span><br><span class="line">            NoOp.INSTANCE</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ConditionalCallbackFilter</span> <span class="variable">CALLBACK_FILTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConditionalCallbackFilter</span>(CALLBACKS);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BEAN_FACTORY_FIELD</span> <span class="operator">=</span> <span class="string">&quot;$$beanFactory&quot;</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匹配回调-ConditionalCallbackFilter"><a href="#匹配回调-ConditionalCallbackFilter" class="headerlink" title="匹配回调 ConditionalCallbackFilter"></a>匹配回调 ConditionalCallbackFilter</h3><p><code>ConditionalCallbackFilter</code> 实现了 <code>CGLib</code> 的 <code>CallbackFilter</code> 接口，<code>accept</code> 方法返回准备使用的 <code>Callback</code> 的索引。匹配规则如下：</p>
<ol>
<li>遍历 <code>callbacks</code>，依次判断<ol>
<li>如果 <code>this.callbacks[i]</code> 不是 <code>ConditionalCallback</code> 类型，直接返回。根据 <code>CALLBACKS</code> 的值，这意味着没有匹配到合适的 <code>MethodInterceptor</code>，选择 <code>NoOp.INSTANCE</code>。</li>
<li>如果 <code>this.callbacks[i]</code> 是 <code>ConditionalCallback</code> 类型，使用 <code>isMatch</code> 方法判断是否匹配，匹配成功返回对应索引</li>
</ol>
</li>
</ol>
<p><code>Callback</code> 中除了 <code>NoOp.INSTANCE</code>，还有 <code>BeanFactoryAwareMethodInterceptor</code> 用于拦截 <code>setBeanFactory</code> 方法，以及 <code>BeanMethodInterceptor</code> 拦截 <code>@Bean</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ConditionalCallbackFilter</span> <span class="keyword">implements</span> <span class="title class_">CallbackFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Callback[] callbacks;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt;[] callbackTypes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConditionalCallbackFilter</span><span class="params">(Callback[] callbacks)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.callbacks = callbacks;</span><br><span class="line">        <span class="built_in">this</span>.callbackTypes = <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[callbacks.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; callbacks.length; i++) &#123;</span><br><span class="line">            <span class="built_in">this</span>.callbackTypes[i] = callbacks[i].getClass();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">accept</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="built_in">this</span>.callbacks.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(<span class="built_in">this</span>.callbacks[i] <span class="keyword">instanceof</span> ConditionalCallback) ||</span><br><span class="line">                    ((ConditionalCallback) <span class="built_in">this</span>.callbacks[i]).isMatch(method)) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No callback available for method &quot;</span> + method.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt;[] getCallbackTypes() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.callbackTypes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拦截-setBeanFactory-方法"><a href="#拦截-setBeanFactory-方法" class="headerlink" title="拦截 setBeanFactory 方法"></a>拦截 setBeanFactory 方法</h3><p><code>BeanFactoryAwareMethodInterceptor</code> 实现了 <code>MethodInterceptor</code> 和 <code>ConditionalCallback</code> 接口。<code>isMatch</code> 匹配到 <code>BeanFactoryAware</code> 接口的 <code>setBeanFactory</code> 方法，则调用 <code>intercept</code> 方法，为 <code>$$beanFactory</code> 属性赋值。<code>$$beanFactory</code> 是 <code>CGLib</code> 生成的 <code>BeanFactory</code> 类型的属性。这个属性是通过设置 <code>enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader))</code> 生成的。</p>
<p>这样，当配置类 <code>Bean</code> 被创建时，会因为实现了 <code>BeanFactoryAware</code>，在初始化阶段被调用 <code>setBeanFactory</code> 方法而被拦截。拦截后将获得的 <code>beanFactory</code> 实例保存在 <code>CGlib</code> 生成的属性 <code>$$beanFactory</code> 中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BeanFactoryAwareMethodInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span>, ConditionalCallback &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> ReflectionUtils.findField(obj.getClass(), BEAN_FACTORY_FIELD);</span><br><span class="line">        Assert.state(field != <span class="literal">null</span>, <span class="string">&quot;Unable to find generated BeanFactory field&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置 beanFactory 的值</span></span><br><span class="line">        field.set(obj, args[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Does the actual (non-CGLIB) superclass implement BeanFactoryAware?</span></span><br><span class="line">        <span class="comment">// If so, call its setBeanFactory() method. If not, just exit.</span></span><br><span class="line">        <span class="comment">// 如果实际的（non-CGLIB）父类实现了 BeanFactoryAware 接口，调用它的 setBeanFactory() 方法</span></span><br><span class="line">        <span class="keyword">if</span> (BeanFactoryAware.class.isAssignableFrom(ClassUtils.getUserClass(obj.getClass().getSuperclass()))) &#123;</span><br><span class="line">            <span class="keyword">return</span> proxy.invokeSuper(obj, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据方法名、参数数量、参数类型、方法所在的类判断</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(Method candidateMethod)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (candidateMethod.getName().equals(<span class="string">&quot;setBeanFactory&quot;</span>) &amp;&amp;</span><br><span class="line">                candidateMethod.getParameterTypes().length == <span class="number">1</span> &amp;&amp;</span><br><span class="line">                BeanFactory.class == candidateMethod.getParameterTypes()[<span class="number">0</span>] &amp;&amp;</span><br><span class="line">                BeanFactoryAware.class.isAssignableFrom(candidateMethod.getDeclaringClass()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="生成-beanFactory-属性"><a href="#生成-beanFactory-属性" class="headerlink" title="生成 $$beanFactory 属性"></a>生成 $$beanFactory 属性</h4><p><code>BeanFactoryAwareGeneratorStrategy</code> 为配置的 <code>CGLib</code> 子类生成一个访问控制符为 <code>public</code>、类型为 <code>BeanFactory</code>、名称为 <code>$$beanFactory</code> 的属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BeanFactoryAwareGeneratorStrategy</span> <span class="keyword">extends</span> <span class="title class_">DefaultGeneratorStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader classLoader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BeanFactoryAwareGeneratorStrategy</span><span class="params">(ClassLoader classLoader)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.classLoader = classLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> ClassGenerator <span class="title function_">transform</span><span class="params">(ClassGenerator cg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ClassEmitterTransformer</span> <span class="variable">transformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassEmitterTransformer</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">end_class</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// 新增一个访问控制符为 public、类型为 BeanFactory、名称为 $$beanFactory 的属性</span></span><br><span class="line">                declare_field(Constants.ACC_PUBLIC, BEAN_FACTORY_FIELD, Type.getType(BeanFactory.class), <span class="literal">null</span>);</span><br><span class="line">                <span class="built_in">super</span>.end_class();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransformingClassGenerator</span>(cg, transformer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理逻辑是清晰的，作用和影响不清楚</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] generate(ClassGenerator cg) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.classLoader == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.generate(cg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">currentThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        ClassLoader threadContextClassLoader;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            threadContextClassLoader = currentThread.getContextClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="comment">// Cannot access thread context ClassLoader - falling back...</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.generate(cg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">overrideClassLoader</span> <span class="operator">=</span> !<span class="built_in">this</span>.classLoader.equals(threadContextClassLoader);</span><br><span class="line">        <span class="keyword">if</span> (overrideClassLoader) &#123;</span><br><span class="line">            currentThread.setContextClassLoader(<span class="built_in">this</span>.classLoader);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.generate(cg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (overrideClassLoader) &#123;</span><br><span class="line">                <span class="comment">// Reset original thread context ClassLoader.</span></span><br><span class="line">                currentThread.setContextClassLoader(threadContextClassLoader);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="核心：拦截-Bean-方法"><a href="#核心：拦截-Bean-方法" class="headerlink" title="核心：拦截 @Bean 方法"></a>核心：拦截 @Bean 方法</h3><p><code>BeanMethodInterceptor</code> 实现了 <code>MethodInterceptor</code> 和 <code>ConditionalCallback</code> 接口。<code>isMatch</code> 匹配到被 <code>Bean</code> 注解标注的方法，则调用 <code>intercept</code> 方法。被 <code>Configuration</code> 注解标注的配置类，它定义的被 <code>Bean</code> 注解标注的方法，只会在第一次被调用时真正地执行并创建实例，后续不会再执行的“魔法”就在这里。即使你手动地调用配置类的方法，或是被 <code>Bean</code> 注解标注的方法间互相调用，都是如此。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,</span></span><br><span class="line"><span class="params">            MethodProxy cglibMethodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// 通过反射，获得 beanFactory 实例</span></span><br><span class="line">    <span class="type">ConfigurableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> getBeanFactory(enhancedConfigInstance);</span><br><span class="line">    <span class="comment">// 获取 beanName，默认是方法名，可以自定义</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> BeanAnnotationHelper.determineBeanNameFor(beanMethod);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确定这个 bean 是否属于 scoped-proxy（不了解）</span></span><br><span class="line">    <span class="type">Scope</span> <span class="variable">scope</span> <span class="operator">=</span> AnnotatedElementUtils.findMergedAnnotation(beanMethod, Scope.class);</span><br><span class="line">    <span class="keyword">if</span> (scope != <span class="literal">null</span> &amp;&amp; scope.proxyMode() != ScopedProxyMode.NO) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">scopedBeanName</span> <span class="operator">=</span> ScopedProxyCreator.getTargetBeanName(beanName);</span><br><span class="line">        <span class="keyword">if</span> (beanFactory.isCurrentlyInCreation(scopedBeanName)) &#123;</span><br><span class="line">            beanName = scopedBeanName;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// To handle the case of an inter-bean method reference, we must explicitly check the</span></span><br><span class="line">    <span class="comment">// container for already cached instances.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// First, check to see if the requested bean is a FactoryBean. If so, create a subclass</span></span><br><span class="line">    <span class="comment">// proxy that intercepts calls to getObject() and returns any cached bean instance.</span></span><br><span class="line">    <span class="comment">// This ensures that the semantics of calling a FactoryBean from within @Bean methods</span></span><br><span class="line">    <span class="comment">// is the same as that of referring to a FactoryBean within XML. See SPR-6602.</span></span><br><span class="line">    <span class="keyword">if</span> (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &amp;&amp;</span><br><span class="line">            factoryContainsBean(beanFactory, beanName)) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">factoryBean</span> <span class="operator">=</span> beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">        <span class="keyword">if</span> (factoryBean <span class="keyword">instanceof</span> ScopedProxyFactoryBean) &#123;</span><br><span class="line">            <span class="comment">// Scoped proxy factory beans are a special case and should not be further proxied</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// It is a candidate FactoryBean - go ahead with enhancement</span></span><br><span class="line">            <span class="comment">// 处理 FactoryBean 类型</span></span><br><span class="line">            <span class="keyword">return</span> enhanceFactoryBean(factoryBean, beanMethod.getReturnType(), beanFactory, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 beanMethod 是不是当前正在被调用的 FactoryMethod</span></span><br><span class="line">    <span class="keyword">if</span> (isCurrentlyInvokedFactoryMethod(beanMethod)) &#123;</span><br><span class="line">        <span class="comment">// The factory is calling the bean method in order to instantiate and register the bean</span></span><br><span class="line">        <span class="comment">// (i.e. via a getBean() call) -&gt; invoke the super implementation of the method to actually</span></span><br><span class="line">        <span class="comment">// create the bean instance.</span></span><br><span class="line">        <span class="keyword">if</span> (logger.isWarnEnabled() &amp;&amp;</span><br><span class="line">                BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) &#123;</span><br><span class="line">            logger.warn(String.format(<span class="string">&quot;@Bean method %s.%s is non-static and returns an object &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;assignable to Spring&#x27;s BeanFactoryPostProcessor interface. This will &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;result in a failure to process annotations such as @Autowired, &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;@Resource and @PostConstruct within the method&#x27;s declaring &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;@Configuration class. Add the &#x27;static&#x27; modifier to this method to avoid &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;these container lifecycle issues; see @Bean javadoc for complete details.&quot;</span>,</span><br><span class="line">                    beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用实际的父类方法，创建 Bean 实例</span></span><br><span class="line">        <span class="keyword">return</span> cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 BeanFactory 里获取</span></span><br><span class="line">    <span class="keyword">return</span> obtainBeanInstanceFromFactory(beanMethod, beanMethodArgs, beanFactory, beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>isCurrentlyInvokedFactoryMethod(beanMethod)</code> 检查 <code>beanMethod</code> 是不是当前正在被调用的 <code>FactoryMethod</code></li>
<li>如果是，则调用实际的父类方法，创建 <code>Bean</code> 实例</li>
<li>如果不是，则从 <code>BeanFactory</code> 中获取</li>
</ol>
<p>以本文示例进行说明。</p>
<ol>
<li>调用 <code>lisi()</code> 前，设置当前正在调用的 <code>FactoryMethod</code> 为 <code>lisi()</code><ol>
<li>lisi() 调用被拦截后，查询获知当前正在调用的 <code>FactoryMethod</code> 确实是 <code>lisi()</code>，调用父类方法创建</li>
</ol>
</li>
<li>调用 <code>person()</code> 前，设置当前正在调用的 <code>FactoryMethod</code> 为 <code>person()</code><ol>
<li><code>person()</code> 调用被拦截后，查询获知当前正在调用的 <code>FactoryMethod</code> 确实是 <code>person()</code>，调用父类方法创建</li>
<li>父类方法内调用了 <code>lisi()</code><ol>
<li><code>lisi()</code> 调用被拦截后，查询获知当前正在调用的 <code>FactoryMethod</code> 是 <code>person()</code>，从 <code>BeanFactory</code> 中获取</li>
<li>从 <code>BeanFactory</code> 中获取得到已经创建的 <code>lisi</code></li>
</ol>
</li>
<li>继续创建并返回</li>
</ol>
</li>
</ol>
<p>以上处理的过程是比较清晰简单的，但是当前正在被调用的 <code>FactoryMethod</code> 是什么时候保存的，怎么处理的，还未明朗。</p>
<h4 id="isCurrentlyInvokedFactoryMethod"><a href="#isCurrentlyInvokedFactoryMethod" class="headerlink" title="isCurrentlyInvokedFactoryMethod"></a>isCurrentlyInvokedFactoryMethod</h4><p>判断是否是当前正在被调用的 <code>FactoryMethod</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isCurrentlyInvokedFactoryMethod</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">    <span class="type">Method</span> <span class="variable">currentlyInvoked</span> <span class="operator">=</span> SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod();</span><br><span class="line">    <span class="keyword">return</span> (currentlyInvoked != <span class="literal">null</span> &amp;&amp; method.getName().equals(currentlyInvoked.getName()) &amp;&amp;</span><br><span class="line">            Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原理是通过 <code>ThreadLocal</code> 记录正在调用的 <code>FactoryMethod</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleInstantiationStrategy</span> <span class="keyword">implements</span> <span class="title class_">InstantiationStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Method&gt; currentlyInvokedFactoryMethod = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Method&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the factory method currently being invoked or &#123;<span class="doctag">@code</span> null&#125; if none.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Allows factory method implementations to determine whether the current</span></span><br><span class="line"><span class="comment">	 * caller is the container itself as opposed to user code.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Method <span class="title function_">getCurrentlyInvokedFactoryMethod</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> currentlyInvokedFactoryMethod.get();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里只是通过 <code>get</code> 获取 <code>currentlyInvokedFactoryMethod</code> 的值，我们还不知道它是在哪更新的。</p>
<h3 id="currentlyInvokedFactoryMethod-的“来龙去脉”"><a href="#currentlyInvokedFactoryMethod-的“来龙去脉”" class="headerlink" title="currentlyInvokedFactoryMethod 的“来龙去脉”"></a>currentlyInvokedFactoryMethod 的“来龙去脉”</h3><p>当 <code>BeanFactory</code> 创建 <code>Bean</code> 实例时，被 <code>Bean</code> 注解标注的方法注册的 <code>Bean</code> 在实例化时是使用工厂方法而不是构造器方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> BeanWrapper <span class="title function_">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="literal">null</span>)  &#123;</span><br><span class="line">        <span class="comment">// 如果 FactoryMethodName 不为 null，则通过工厂方法实例化</span></span><br><span class="line">        <span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> BeanWrapper <span class="title function_">instantiateUsingFactoryMethod</span><span class="params">(</span></span><br><span class="line"><span class="params">        String beanName, RootBeanDefinition mbd, Object[] explicitArgs)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConstructorResolver</span>(<span class="built_in">this</span>).instantiateUsingFactoryMethod(beanName, mbd, explicitArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>BeanFactory</code> 委托给 <code>ConstructorResolver</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> BeanWrapper <span class="title function_">instantiateUsingFactoryMethod</span><span class="params">(</span></span><br><span class="line"><span class="params">		<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> Object[] explicitArgs)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    beanInstance = <span class="built_in">this</span>.beanFactory.getInstantiationStrategy().instantiate(</span><br><span class="line">			mbd, beanName, <span class="built_in">this</span>.beanFactory, factoryBean, factoryMethodToUse, argsToUse);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AbstractAutowireCapableBeanFactory</code> 的 <code>instantiationStrategy</code> 类型是 <code>CglibSubclassingInstantiationStrategy</code>，继承自 <code>SimpleInstantiationStrategy</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">InstantiationStrategy</span> <span class="variable">instantiationStrategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CglibSubclassingInstantiationStrategy</span>();</span><br></pre></td></tr></table></figure>

<p><code>SimpleInstantiationStrategy</code> 的 <code>instantiate</code> 方法在通过反射调用 <code>factoryBean</code> 对应的 <code>method</code> 前后，会处理 <code>currentlyInvokedFactoryMethod</code> 的值。</p>
<blockquote>
<p>被 <code>Bean</code> 注解标注的方法，对应的 <code>Bean</code> 就是一个 <code>FactoryBean</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleInstantiationStrategy</span> <span class="keyword">implements</span> <span class="title class_">InstantiationStrategy</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">instantiate</span><span class="params">(RootBeanDefinition bd, String beanName, BeanFactory owner,</span></span><br><span class="line"><span class="params">            Object factoryBean, <span class="keyword">final</span> Method factoryMethod, Object... args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">                AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Object&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                        ReflectionUtils.makeAccessible(factoryMethod);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ReflectionUtils.makeAccessible(factoryMethod);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 获取之前正在被调用的 FactoryMethod</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">priorInvokedFactoryMethod</span> <span class="operator">=</span> currentlyInvokedFactoryMethod.get();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 将当前正在被调用的 FactoryMethod 保存</span></span><br><span class="line">                currentlyInvokedFactoryMethod.set(factoryMethod);</span><br><span class="line">                <span class="comment">// 调用 FactoryMethod</span></span><br><span class="line">                <span class="keyword">return</span> factoryMethod.invoke(factoryBean, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (priorInvokedFactoryMethod != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果之前正在被调用的 FactoryMethod 不为 null，复原</span></span><br><span class="line">                    currentlyInvokedFactoryMethod.set(priorInvokedFactoryMethod);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 否则移除</span></span><br><span class="line">                    currentlyInvokedFactoryMethod.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanInstantiationException</span>(factoryMethod,</span><br><span class="line">                    <span class="string">&quot;Illegal arguments to factory method &#x27;&quot;</span> + factoryMethod.getName() + <span class="string">&quot;&#x27;; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;args: &quot;</span> + StringUtils.arrayToCommaDelimitedString(args), ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanInstantiationException</span>(factoryMethod,</span><br><span class="line">                    <span class="string">&quot;Cannot access factory method &#x27;&quot;</span> + factoryMethod.getName() + <span class="string">&quot;&#x27;; is it public?&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Factory method &#x27;&quot;</span> + factoryMethod.getName() + <span class="string">&quot;&#x27; threw exception&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (bd.getFactoryBeanName() != <span class="literal">null</span> &amp;&amp; owner <span class="keyword">instanceof</span> ConfigurableBeanFactory &amp;&amp;</span><br><span class="line">                    ((ConfigurableBeanFactory) owner).isCurrentlyInCreation(bd.getFactoryBeanName())) &#123;</span><br><span class="line">                msg = <span class="string">&quot;Circular reference involving containing bean &#x27;&quot;</span> + bd.getFactoryBeanName() + <span class="string">&quot;&#x27; - consider &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;declaring the factory method as static for independence from its containing instance. &quot;</span> + msg;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanInstantiationException</span>(factoryMethod, msg, ex.getTargetException());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="从-BeanFactory-获取-Bean"><a href="#从-BeanFactory-获取-Bean" class="headerlink" title="从 BeanFactory 获取 Bean"></a>从 BeanFactory 获取 Bean</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">obtainBeanInstanceFromFactory</span><span class="params">(Method beanMethod, Object[] beanMethodArgs,</span></span><br><span class="line"><span class="params">        ConfigurableBeanFactory beanFactory, String beanName)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bean 可能已经在创建中</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">alreadyInCreation</span> <span class="operator">=</span> beanFactory.isCurrentlyInCreation(beanName);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (alreadyInCreation) &#123;</span><br><span class="line">            <span class="comment">// 暂时添加到 inCreationCheckExclusions，不再检查是否在创建中</span></span><br><span class="line">            beanFactory.setCurrentlyInCreation(beanName, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">useArgs</span> <span class="operator">=</span> !ObjectUtils.isEmpty(beanMethodArgs);</span><br><span class="line">        <span class="keyword">if</span> (useArgs &amp;&amp; beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line">            <span class="comment">// 检查参数是否存在 null</span></span><br><span class="line">            <span class="keyword">for</span> (Object arg : beanMethodArgs) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arg == <span class="literal">null</span>) &#123;</span><br><span class="line">                    useArgs = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从 beanFactory 获取 Bean</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">beanInstance</span> <span class="operator">=</span> (useArgs ? beanFactory.getBean(beanName, beanMethodArgs) :</span><br><span class="line">                beanFactory.getBean(beanName));</span><br><span class="line">        <span class="keyword">if</span> (beanInstance != <span class="literal">null</span> &amp;&amp; !ClassUtils.isAssignableValue(beanMethod.getReturnType(), beanInstance)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> String.format(<span class="string">&quot;@Bean method %s.%s called as a bean reference &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;for type [%s] but overridden by non-compatible bean instance of type [%s].&quot;</span>,</span><br><span class="line">                        beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName(),</span><br><span class="line">                        beanMethod.getReturnType().getName(), beanInstance.getClass().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> beanFactory.getMergedBeanDefinition(beanName);</span><br><span class="line">                msg += <span class="string">&quot; Overriding bean of same name declared in: &quot;</span> + beanDefinition.getResourceDescription();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">                <span class="comment">// Ignore - simply no detailed message then.</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注册依赖关系</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">currentlyInvoked</span> <span class="operator">=</span> SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod();</span><br><span class="line">        <span class="keyword">if</span> (currentlyInvoked != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">outerBeanName</span> <span class="operator">=</span> BeanAnnotationHelper.determineBeanNameFor(currentlyInvoked);</span><br><span class="line">            beanFactory.registerDependentBean(beanName, outerBeanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (alreadyInCreation) &#123;</span><br><span class="line">            <span class="comment">// 复原状态</span></span><br><span class="line">            beanFactory.setCurrentlyInCreation(beanName, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>延续自本文的文章：</p>
<ul>
<li><a href="/2023/12/11/the-truth-about-override-of-ComponentScan-basePackages/" title="ComponentScan 扫描路径覆盖的真相">ComponentScan 扫描路径覆盖的真相</a></li>
<li><a href="/2023/12/04/use-and-analysis-of-Import-annotation-in-Spring/" title="Spring 中 @Import 注解的使用和源码分析">Spring 中 @Import 注解的使用和源码分析</a></li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 中 @Import 注解的使用和源码分析</title>
    <url>/2023/12/04/use-and-analysis-of-Import-annotation-in-Spring/</url>
    <content><![CDATA[<p><code>Import</code> 注解是 <code>Spring</code> 基于 <code>Java</code> 注解配置的重要组成部分，处理 <code>Import</code> 注解是处理 <code>Configuration</code> 注解的子过程之一，本文将介绍 <code>Import</code> 注解的 <code>3</code> 种使用方式，然后通过分析源码和处理过程示意图解释它是如何导入（注册） <code>BeanDefinition</code> 的。</p>
<span id="more"></span>

<ul>
<li>本文的写作动机继承自<a href="/2023/11/23/source-code-analysis-of-Spring-Configuration-annotation/" title="Spring @Configuration 注解的源码分析">Spring @Configuration 注解的源码分析</a>，处理 <code>@Import</code> 是处理 <code>@Configuration</code> 过程的一部分。</li>
</ul>
<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p><code>Import</code> 注解有 <code>3</code> 种导入（注册） <code>BeanDefinition</code> 的方式：</p>
<ol>
<li>使用 <code>Import</code> 将目标类的 <code>Class</code> 对象，解析为 <code>BeanDefinition</code> 并注册。</li>
<li>使用 <code>Import</code> 配合 <code>ImportSelector</code> 的实现类，将 <code>selectImports</code> 方法返回的所有全限定类名字符串，解析为 <code>BeanDefinition</code> 并注册。</li>
<li>使用 <code>Import</code> 配合 <code>ImportBeanDefinitionRegistra</code>r 的实现类，在 <code>registerBeanDefinitions</code> 方法中，直接向 <code>BeanDefinitionRegistry</code> 中注册 <code>BeanDefinition</code>。</li>
</ol>
<h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><p>测试了使用 <code>Import</code> 注解的 <code>3</code> 种方式：</p>
<ol>
<li>使用 <code>Import</code> 直接导入（注册） <code>Red</code>。</li>
<li>配合 <code>ImportBeanDefinitionRegistrar</code> 间接注册 <code>Color</code>。</li>
<li>配合 <code>ImportSelector</code> 间接导入（注册） <code>Blue</code>。</li>
</ol>
<p>用例中的特别地测试了以下两种情况：</p>
<ol>
<li>使用 <code>Import</code> 直接导入和配合 <code>ImportSelector</code> 间接导入相同的类 <code>Red</code> 只会注册一个 <code>BeanDefinition</code>。</li>
<li>尽管 <code>MyImportSelector</code> 书面顺序在 <code>MyImportBeanDefinitionRegistrar</code> 之后，但是 <code>MyImportBeanDefinitionRegistrar</code> 判断 <code>registry</code> 是否包含在 <code>MyImportSelector</code> 导入的类 <code>Blue</code> 时，不受顺序影响。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(&#123;Red.class, MyImportBeanDefinitionRegistrar.class, MyImportSelector.class,&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImportConfig</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImportBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">hasRed</span> <span class="operator">=</span> registry.containsBeanDefinition(<span class="string">&quot;com.moralok.bean.Red&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">hasBlue</span> <span class="operator">=</span> registry.containsBeanDefinition(<span class="string">&quot;com.moralok.bean.Blue&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (hasRed &amp;&amp; hasBlue) &#123;</span><br><span class="line">            <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(Color.class);</span><br><span class="line">            registry.registerBeanDefinition(<span class="string">&quot;color&quot;</span>, beanDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">ImportSelector</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;com.moralok.bean.Blue&quot;</span>, <span class="string">&quot;com.moralok.bean.Red&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Red</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Blue</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IocTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">importTest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(ImportConfig.class);</span><br><span class="line">        String[] beanDefinitionNames = ac.getBeanDefinitionNames();</span><br><span class="line">        <span class="keyword">for</span> (String name : beanDefinitionNames) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;beanDefinitionName..........&quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">beanDefinitionName..........importConfig</span><br><span class="line">beanDefinitionName..........com.moralok.bean.Red</span><br><span class="line">beanDefinitionName..........com.moralok.bean.Blue</span><br><span class="line">beanDefinitionName..........color</span><br></pre></td></tr></table></figure>

<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>关于 <code>Import</code> 注解的源码分析需要建立在对关于 <code>Configuration</code> 注解的源码的了解基础上，因为前者是 <code>Spring</code> 解析配置类处理过程的一部分，可以参考文章:</p>
<ul>
<li><a href="/2023/11/23/source-code-analysis-of-Spring-Configuration-annotation/" title="Spring @Configuration 注解的源码分析">Spring @Configuration 注解的源码分析</a></li>
</ul>
<h3 id="获取要导入的目标"><a href="#获取要导入的目标" class="headerlink" title="获取要导入的目标"></a>获取要导入的目标</h3><p>在 <code>doProcessConfigurationClass</code> 方法中处理配置类构建配置模型时，会调用 <code>processImports</code> 方法处理 <code>Import</code> 注解。在进入方法前，会调用 <code>getImports</code> 方法从 <code>sourceClass</code> 获取要导入的目标。</p>
<blockquote>
<p>注意：目标不仅仅来自直接标注在 <code>sourceClass</code> 上的 <code>Import</code> 注解，因为 <code>sourceClass</code> 上可能还有其他的注解，这些注解自身可能标注了 <code>Import</code> 注解，因此需要递归地遍历所有注解，找到所有的 <code>Import</code> 注解。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> SourceClass <span class="title function_">doProcessConfigurationClass</span><span class="params">(ConfigurationClass configClass, SourceClass sourceClass)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 前后省略 @PropertySource、@ComponentScan、@ImportSource、@Bean 等注解的处理</span></span><br><span class="line">    <span class="comment">// 处理 Import 注解</span></span><br><span class="line">    processImports(configClass, sourceClass, getImports(sourceClass), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>collectImports</code> 方法是一种常见的递归写法（深度优先遍历）。<code>imports</code> 存放要导入的目标，<code>visited</code> 存放已经访问过的 <code>sourceClass</code>。<code>sourceClass</code> 在入口处包装了一个普通的 <code>Class</code>，在递归的过程中包装的都是一个注解 <code>Class</code>。</p>
<blockquote>
<p>注意：这里还没有检测循环导入的情况并抛出异常，但 <code>visited</code> 保证了只会遍历一次。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取 Import 注解 value 中的 Class 对象，并包装为 SourceClass 返回</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;SourceClass&gt; <span class="title function_">getImports</span><span class="params">(SourceClass sourceClass)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    Set&lt;SourceClass&gt; imports = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;SourceClass&gt;();</span><br><span class="line">    Set&lt;SourceClass&gt; visited = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;SourceClass&gt;();</span><br><span class="line">    collectImports(sourceClass, imports, visited);</span><br><span class="line">    <span class="keyword">return</span> imports;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归地收集要导入的目标（包装为 SourceClass）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">collectImports</span><span class="params">(SourceClass sourceClass, Set&lt;SourceClass&gt; imports, Set&lt;SourceClass&gt; visited)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 sourceClass 尚未访问过</span></span><br><span class="line">    <span class="keyword">if</span> (visited.add(sourceClass)) &#123;</span><br><span class="line">        <span class="comment">// 遍历 sourceClass 上的注解</span></span><br><span class="line">        <span class="keyword">for</span> (SourceClass annotation : sourceClass.getAnnotations()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">annName</span> <span class="operator">=</span> annotation.getMetadata().getClassName();</span><br><span class="line">            <span class="comment">// 只要注解的名称不是 java 开头或者不是 Import 注解</span></span><br><span class="line">            <span class="keyword">if</span> (!annName.startsWith(<span class="string">&quot;java&quot;</span>) &amp;&amp; !annName.equals(Import.class.getName())) &#123;</span><br><span class="line">                <span class="comment">// 将该注解作为 sourceClass 递归地调用</span></span><br><span class="line">                collectImports(annotation, imports, visited);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将 Import 注解的 value 的值转换为 sourceClass 加入 imports</span></span><br><span class="line">        imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), <span class="string">&quot;value&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候，并不区分要导入的目标的 <code>Class</code> 有什么特别之处，<code>Import</code> 注解的语义，此时宽泛地说就是：“将 <code>value</code> 中的类导入”。但是显而易见，这样的方式不够灵活，因此才有了另外两种更有灵活性的导入方式：<code>ImportSelector</code> 和 <code>ImportBeanDefinitionRegistrar</code>，<code>Spring</code> 最终不会真的注册这两种类，而是注册它们“介绍”的类，相当于把确定导入什么类的工作委托给它们。</p>
<h3 id="处理要导入的目标"><a href="#处理要导入的目标" class="headerlink" title="处理要导入的目标"></a>处理要导入的目标</h3><p><code>processImports</code> 方法是处理 <code>Import</code> 注解的核心方法，这里的处理逻辑就对应着 <code>Import</code> 注解的三种使用方式。主要步骤如下：</p>
<ul>
<li>检测要导入的候选者不为空</li>
<li>判断是否要检测循环导入以及是否存在循环导入</li>
<li>处理要导入的候选者<ul>
<li>如果是 <code>ImportSelector</code> 类型，调用 <code>selectImports</code> 方法获取新的要导入的目标，递归调用 <code>processImports</code> 处理</li>
<li>如果是 <code>ImportBeanDefinitionRegistrar</code> 类型，添加到配置模型 <code>configClass</code>（出口 <code>1</code>）</li>
<li>如果是其他剩余情况，作为配置类处理（出口 <code>2</code>）</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processImports</span><span class="params">(ConfigurationClass configClass, SourceClass currentSourceClass,</span></span><br><span class="line"><span class="params">			Collection&lt;SourceClass&gt; importCandidates, <span class="type">boolean</span> checkForCircularImports)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 如果要导入的目标为空，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (importCandidates.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (checkForCircularImports &amp;&amp; isChainedImportOnStack(configClass)) &#123;</span><br><span class="line">        <span class="comment">// 如果要检查循环导入，且确实存在循环导入，则抛出异常</span></span><br><span class="line">        <span class="built_in">this</span>.problemReporter.error(<span class="keyword">new</span> <span class="title class_">CircularImportProblem</span>(configClass, <span class="built_in">this</span>.importStack));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将配置模型放入 importStack，用于检查循环导入</span></span><br><span class="line">        <span class="built_in">this</span>.importStack.push(configClass);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历每一个准备导入的目标</span></span><br><span class="line">            <span class="keyword">for</span> (SourceClass candidate : importCandidates) &#123;</span><br><span class="line">                <span class="comment">// 如果是 ImportSelector 类型，委托给它确定导入目标</span></span><br><span class="line">                <span class="keyword">if</span> (candidate.isAssignable(ImportSelector.class)) &#123;</span><br><span class="line">                    <span class="comment">// 加载类</span></span><br><span class="line">                    Class&lt;?&gt; candidateClass = candidate.loadClass();</span><br><span class="line">                    <span class="comment">// 实例化得到 ImportSelector 实例</span></span><br><span class="line">                    <span class="type">ImportSelector</span> <span class="variable">selector</span> <span class="operator">=</span> BeanUtils.instantiateClass(candidateClass, ImportSelector.class);</span><br><span class="line">                    <span class="comment">// 调用其 Aware 接口</span></span><br><span class="line">                    ParserStrategyUtils.invokeAwareMethods(</span><br><span class="line">                            selector, <span class="built_in">this</span>.environment, <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.registry);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">this</span>.deferredImportSelectors != <span class="literal">null</span> &amp;&amp; selector <span class="keyword">instanceof</span> DeferredImportSelector) &#123;</span><br><span class="line">                        <span class="comment">// 如果是 DeferredImportSelector 类型，存入 deferredImportSelectors 推迟调用</span></span><br><span class="line">                        <span class="built_in">this</span>.deferredImportSelectors.add(</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">DeferredImportSelectorHolder</span>(configClass, (DeferredImportSelector) selector));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 调用 selectImports 方法，返回要导入的目标的全限定类名</span></span><br><span class="line">                        String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());</span><br><span class="line">                        <span class="comment">// 包装为 SourceClass</span></span><br><span class="line">                        Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames);</span><br><span class="line">                        <span class="comment">// 递归调用 processImports</span></span><br><span class="line">                        <span class="comment">// 从这里看，ImportSelector 本质上是更加灵活的 Import</span></span><br><span class="line">                        processImports(configClass, currentSourceClass, importSourceClasses, <span class="literal">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果是 ImportBeanDefinitionRegistrar 类型，委托给它注册额外的 BeanDefinitions</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) &#123;</span><br><span class="line">                    <span class="comment">// 加载类</span></span><br><span class="line">                    Class&lt;?&gt; candidateClass = candidate.loadClass();</span><br><span class="line">                    <span class="comment">// 实例化得到 ImportBeanDefinitionRegistrar 实例</span></span><br><span class="line">                    <span class="type">ImportBeanDefinitionRegistrar</span> <span class="variable">registrar</span> <span class="operator">=</span></span><br><span class="line">                            BeanUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class);</span><br><span class="line">                    <span class="comment">// 调用其 Aware 接口</span></span><br><span class="line">                    ParserStrategyUtils.invokeAwareMethods(</span><br><span class="line">                            registrar, <span class="built_in">this</span>.environment, <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.registry);</span><br><span class="line">                    <span class="comment">// 添加到配置模型</span></span><br><span class="line">                    configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 既不是 ImportSelector，也不是 ImportBeanDefinitionRegistrar 的其他剩余情况，将其视为被 Configuration 注解标注的配置类进行处理</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.importStack.registerImport(</span><br><span class="line">                            currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());</span><br><span class="line">                    <span class="comment">// asConfigClass 方法建立了 candidate importBy configClass 的关系</span></span><br><span class="line">                    processConfigurationClass(candidate.asConfigClass(configClass));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">                    <span class="string">&quot;Failed to process import candidates for configuration class [&quot;</span> +</span><br><span class="line">                    configClass.getMetadata().getClassName() + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// pop 配置模型</span></span><br><span class="line">            <span class="built_in">this</span>.importStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类型一：ImportSelector"><a href="#类型一：ImportSelector" class="headerlink" title="类型一：ImportSelector"></a>类型一：ImportSelector</h4><p>如果要导入的目标是 <code>ImportSelector</code> 类型，那么 <code>Spring</code> 将确定真正导入什么目标的工作委托给它，不导入目标本身，实际上只导入目标“介绍”的类。具体步骤是：</p>
<ol>
<li>先获取 <code>Class</code> 对象</li>
<li>再实例化得到一个 <code>ImportSelector</code> 实例</li>
<li>调用 <code>selectImports</code> 方法，该方法返回的是类的全限定名，这样就得到了真正要导入的目标</li>
<li>再次递归调用 <code>processImports</code></li>
</ol>
<p><code>ImportSelector</code> 就像它名字的含义一样，本质上是一种导入选择器，是一种更加灵活的 <code>getImports</code> 方法。由于返回的目标可能属于三种情形中的任意一种，所以对这些目标的处理还是要回到 <code>processImports</code> 方法。可以说 <code>ImportSelector</code> 类型本身不是 <code>processImports</code> 方法的出口，它最终会转换为 <code>ImportBeanDefinitionRegistrar</code> 或其他剩余情况。</p>
<p><code>ImportSelector</code> 灵活性的来源：</p>
<ul>
<li><code>selectImports</code> 的 <code>AnnotationMetadata</code> 参数，为它提供了根据注解信息返回要导入的目标的能力</li>
<li><code>ImportSelector</code> 可以实现 <code>Aware</code> 接口，用以感知到一些容器级别的资源，如 <code>BeanFactory</code>，这为它提供了根据这些资源中的信息返回要导入的目标的能力</li>
</ul>
<h4 id="类型二：ImportBeanDefinitionRegistrar"><a href="#类型二：ImportBeanDefinitionRegistrar" class="headerlink" title="类型二：ImportBeanDefinitionRegistrar"></a>类型二：ImportBeanDefinitionRegistrar</h4><p>如果要导入的目标是 <code>ImportBeanDefinitionRegistrar</code>，它会和 <code>ImportSelector</code> 有些相似却又有所不同。<code>Spring</code> 同样将确定真正导入什么目标的工作委托给它，不导入目标本身，实际上只导入目标“介绍”的类。</p>
<ol>
<li>先获取 <code>Class</code> 对象</li>
<li>再实例化得到一个 <code>ImportBeanDefinitionRegistrar</code> 实例</li>
<li>添加到配置模型 <code>configClass</code> 的 <code>importBeanDefinitionRegistrars</code> 属性</li>
</ol>
<p><code>ImportBeanDefinitionRegistrar</code> 不像 <code>ImportSelector</code> 需要进一步处理，它本身就代表着一个返回出口，成为了配置模型的一部分。但是请注意，<code>registerBeanDefinitions</code> 方法此时并没有被调用。</p>
<p><code>ImportBeanDefinitionRegistrar</code> 灵活性的来源：</p>
<ul>
<li><code>registerBeanDefinitions</code> 的 <code>AnnotationMetadata</code> 参数，为它提供了根据注解信息决定注册 <code>BeanDefinition</code> 的能力</li>
<li><code>registerBeanDefinitions</code> 的 <code>BeanDefinitionRegistry</code> 参数，为它提供了根据 <code>BeanDefinitionRegistry</code> 中的信息决定注册 <code>BeanDefinition</code> 的能力</li>
<li><code>ImportBeanDefinitionRegistrar</code> 可以实现 <code>Aware</code> 接口，用以感知到一些容器级别的资源，如 <code>BeanFactory</code>，这为它提供了根据这些资源中的信息返回要导入的目标的能力</li>
</ul>
<h4 id="类型三：其他剩余情况"><a href="#类型三：其他剩余情况" class="headerlink" title="类型三：其他剩余情况"></a>类型三：其他剩余情况</h4><p>如果要导入的目标属于既不是 <code>ImportSelector</code> 也不是 <code>ImportBeanDefinitionRegistrar</code> 的其他剩余情况，那么 <code>Spring</code> 将其视为被 <code>Configuration</code> 注解标注的配置类进行处理。这里的处理逻辑是，<code>Import</code> 注解导入的类可能不是一个普通的类，而是一个配置类，因此需要回到 <code>processConfigurationClass</code> 进行处理。<code>processConfigurationClass</code> 方法正是本文开头的 <code>doProcessConfigurationClass</code> 方法的调用方，这里有两个地方值得注意：</p>
<ul>
<li><code>Import</code> 注解产生的 <code>ConfigurationClass</code> 根据不同的情况需要合并或者被抛弃，显式声明比 Import 导入的优先级更高。</li>
<li>其他剩余情况下，目标最终会转换为一个配置模型，添加到 <code>parser</code> 的 <code>configurationClasses</code> 属性。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processConfigurationClass</span><span class="params">(ConfigurationClass configClass)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 判断是否跳过处理</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果配置模型已经存在</span></span><br><span class="line">    <span class="type">ConfigurationClass</span> <span class="variable">existingClass</span> <span class="operator">=</span> <span class="built_in">this</span>.configurationClasses.get(configClass);</span><br><span class="line">    <span class="keyword">if</span> (existingClass != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果新的配置模型代表的类，是 Import 导入的</span></span><br><span class="line">        <span class="keyword">if</span> (configClass.isImported()) &#123;</span><br><span class="line">            <span class="comment">// 如果已存在的配置模型也是 Import 导入的</span></span><br><span class="line">            <span class="keyword">if</span> (existingClass.isImported()) &#123;</span><br><span class="line">                <span class="comment">// 合并它们的来源</span></span><br><span class="line">                <span class="comment">// 比如一个类 A 既被 Config1 上的 Import 注解导入，也被 Config2 上的 Import 导入</span></span><br><span class="line">                existingClass.mergeImportedBy(configClass);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 否则忽略新的因为 Import 导入而产生的配置模型</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 使用显式定义的代替 Import 导入的（显式定义的和 Import 导入的有什么不同吗）</span></span><br><span class="line">            <span class="built_in">this</span>.configurationClasses.remove(configClass);</span><br><span class="line">            <span class="keyword">for</span> (Iterator&lt;ConfigurationClass&gt; it = <span class="built_in">this</span>.knownSuperclasses.values().iterator(); it.hasNext();) &#123;</span><br><span class="line">                <span class="keyword">if</span> (configClass.equals(it.next())) &#123;</span><br><span class="line">                    it.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先递归地处理配置类和它的父类，因为配合各种注解，可能引入更多的类</span></span><br><span class="line">    <span class="type">SourceClass</span> <span class="variable">sourceClass</span> <span class="operator">=</span> asSourceClass(configClass);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        sourceClass = doProcessConfigurationClass(configClass, sourceClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (sourceClass != <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个配置类，本身最终被解析成配置模型（配置模型在后续将会解析出 BeanDefinition）</span></span><br><span class="line">    <span class="built_in">this</span>.configurationClasses.put(configClass, configClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DeferredImportSelector-的调用时机"><a href="#DeferredImportSelector-的调用时机" class="headerlink" title="DeferredImportSelector 的调用时机"></a>DeferredImportSelector 的调用时机</h3><p>在解析完每一批（注释中说“全部”）的配置类后，会统一调用 <code>DeferredImportSelector</code>。它作为一个标记接口推迟了 <code>selectImports</code> 的时机，打破了处理顺序的限制，在方法被调用时，可以得到更加完整的信息。注释中说“在选择导入的目标是 <code>@Conditional</code> 时，这个类型的选择器会很有用”，但是我不太理解，因为这个时候，处理配置类得到的信息尚未转换为 <code>ImportSelector</code> 可以感知到的信息，不像 <code>ImportBeanDefinitionRegistrar</code>，它被调用的时机在最后，也因此可以感知到更多的信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; configCandidates)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.deferredImportSelectors = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;DeferredImportSelectorHolder&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (BeanDefinitionHolder holder : configCandidates) &#123;</span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> holder.getBeanDefinition();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">                parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) &#123;</span><br><span class="line">                parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                parse(bd.getBeanClassName(), holder.getBeanName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">                    <span class="string">&quot;Failed to parse configuration class [&quot;</span> + bd.getBeanClassName() + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用 DeferredImportSelectors</span></span><br><span class="line">    processDeferredImportSelectors();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processDeferredImportSelectors</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取处理这一批配置类获得的 DeferredImportSelectors</span></span><br><span class="line">    List&lt;DeferredImportSelectorHolder&gt; deferredImports = <span class="built_in">this</span>.deferredImportSelectors;</span><br><span class="line">    <span class="comment">// 清空</span></span><br><span class="line">    <span class="built_in">this</span>.deferredImportSelectors = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    Collections.sort(deferredImports, DEFERRED_IMPORT_COMPARATOR);</span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">for</span> (DeferredImportSelectorHolder deferredImport : deferredImports) &#123;</span><br><span class="line">        <span class="type">ConfigurationClass</span> <span class="variable">configClass</span> <span class="operator">=</span> deferredImport.getConfigurationClass();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用 selectImports 获取要导入的目标</span></span><br><span class="line">            String[] imports = deferredImport.getImportSelector().selectImports(configClass.getMetadata());</span><br><span class="line">            <span class="comment">// 调用 processImports 处理要导入的目标，这里不管循环导入？竟然是任由 StackOverFlow</span></span><br><span class="line">            processImports(configClass, asSourceClass(configClass), asSourceClasses(imports), <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">                    <span class="string">&quot;Failed to process import candidates for configuration class [&quot;</span> +</span><br><span class="line">                    configClass.getMetadata().getClassName() + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ImportBeanDefinitionRegistrar-的调用时机"><a href="#ImportBeanDefinitionRegistrar-的调用时机" class="headerlink" title="ImportBeanDefinitionRegistrar 的调用时机"></a>ImportBeanDefinitionRegistrar 的调用时机</h3><p><code>ConfigurationClassPostProcessor</code> 在每次解析得到新的一批配置模型后，都会调用 <code>ConfigurationClassBeanDefinitionReader</code> 的 <code>loadBeanDefinitions</code> 方法加载 <code>BeanDefinition</code>，在这过程的最后会从 <code>ImportBeanDefinitionRegistrar</code> 加载 <code>BeanDefinition</code>。这代表在处理同一批配置类时，在 <code>registerBeanDefinitions</code> 方法中总是能感知到以其他方式注册到 <code>BeanDefinitionRegistry</code> 中的 <code>BeanDefinition</code>，不论书面定义的顺序如何。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(Set&lt;ConfigurationClass&gt; configurationModel)</span> &#123;</span><br><span class="line">    <span class="type">TrackedConditionEvaluator</span> <span class="variable">trackedConditionEvaluator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrackedConditionEvaluator</span>();</span><br><span class="line">    <span class="comment">// 遍历每一个配置模型</span></span><br><span class="line">    <span class="keyword">for</span> (ConfigurationClass configClass : configurationModel) &#123;</span><br><span class="line">        <span class="comment">// 从配置模型中加载 BeanDefinistion</span></span><br><span class="line">        loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitionsForConfigurationClass</span><span class="params">(ConfigurationClass configClass,</span></span><br><span class="line"><span class="params">        TrackedConditionEvaluator trackedConditionEvaluator)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (trackedConditionEvaluator.shouldSkip(configClass)) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> configClass.getBeanName();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="built_in">this</span>.registry.containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.registry.removeBeanDefinition(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.importRegistry.removeImportingClass(configClass.getMetadata().getClassName());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果配置模型本身是导入的，为自身注册 BeanDefinition</span></span><br><span class="line">    <span class="keyword">if</span> (configClass.isImported()) &#123;</span><br><span class="line">        registerBeanDefinitionForImportedConfigurationClass(configClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为 BeanMethod 加载 BeanDefinition（Bean 注解）</span></span><br><span class="line">    <span class="keyword">for</span> (BeanMethod beanMethod : configClass.getBeanMethods()) &#123;</span><br><span class="line">        loadBeanDefinitionsForBeanMethod(beanMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为 ImportResources 加载 BeanDefinition（ImportResource 注解）</span></span><br><span class="line">    loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());</span><br><span class="line">    <span class="comment">// 从 ImportBeanDefinitionRegistrar 加载 BeanDefinition</span></span><br><span class="line">    loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitionsFromRegistrars</span><span class="params">(Map&lt;ImportBeanDefinitionRegistrar, AnnotationMetadata&gt; registrars)</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历 ImportBeanDefinitionRegistrar 调用 registerBeanDefinitions 方法注册 BeanDefinition</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;ImportBeanDefinitionRegistrar, AnnotationMetadata&gt; entry : registrars.entrySet()) &#123;</span><br><span class="line">        entry.getKey().registerBeanDefinitions(entry.getValue(), <span class="built_in">this</span>.registry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环导入的检测"><a href="#循环导入的检测" class="headerlink" title="循环导入的检测"></a>循环导入的检测</h3><p>在处理导入的目标前将配置类放入 <code>importStack</code>，处理完毕移除。如果要导入的目标属于其他剩余情况时，注册被导入类-&gt;所有导入类集合的映射关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processImports</span><span class="params">(ConfigurationClass configClass, SourceClass currentSourceClass,</span></span><br><span class="line"><span class="params">			Collection&lt;SourceClass&gt; importCandidates, <span class="type">boolean</span> checkForCircularImports)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (checkForCircularImports &amp;&amp; isChainedImportOnStack(configClass)) &#123;</span><br><span class="line">        <span class="comment">// 如果要检查循环导入，且确实存在循环导入，则抛出异常</span></span><br><span class="line">        <span class="built_in">this</span>.problemReporter.error(<span class="keyword">new</span> <span class="title class_">CircularImportProblem</span>(configClass, <span class="built_in">this</span>.importStack));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将配置模型放入 importStack，用于检查循环导入</span></span><br><span class="line">        <span class="built_in">this</span>.importStack.push(configClass);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历每一个准备导入的目标</span></span><br><span class="line">            <span class="keyword">for</span> (SourceClass candidate : importCandidates) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 记录了被导入类-&gt;所有导入类集合的映射关系</span></span><br><span class="line">                    <span class="built_in">this</span>.importStack.registerImport(</span><br><span class="line">                            currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());</span><br><span class="line">                    <span class="comment">// asConfigClass 方法建立了 candidate importBy configClass 的关系</span></span><br><span class="line">                    processConfigurationClass(candidate.asConfigClass(configClass));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// pop 配置模型</span></span><br><span class="line">            <span class="built_in">this</span>.importStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检测是否发生循环导入。以当前类开始，循环向上查找最近一个导入自身的类，如果找到自身，说明发生循环导入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isChainedImportOnStack</span><span class="params">(ConfigurationClass configClass)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 importStack 已存在该配置模型</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.importStack.contains(configClass)) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">configClassName</span> <span class="operator">=</span> configClass.getMetadata().getClassName();</span><br><span class="line">        <span class="comment">// 获取最新一个导入 configClass 的类</span></span><br><span class="line">        <span class="type">AnnotationMetadata</span> <span class="variable">importingClass</span> <span class="operator">=</span> <span class="built_in">this</span>.importStack.getImportingClassFor(configClassName);</span><br><span class="line">        <span class="comment">// 循环查找导入类的最近一个导入类，如果找到了自身，表示发生循环导入</span></span><br><span class="line">        <span class="keyword">while</span> (importingClass != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (configClassName.equals(importingClass.getClassName())) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            importingClass = <span class="built_in">this</span>.importStack.getImportingClassFor(importingClass.getClassName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><table>
<thead>
<tr>
<th></th>
<th><code>ImportSelector</code></th>
<th><code>ImportBeanDefinitionRegistrar</code></th>
<th>其他剩余情况</th>
</tr>
</thead>
<tbody><tr>
<td>灵活性</td>
<td>中</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>处理结果</td>
<td></td>
<td>转换为配置模型的一部分</td>
<td>转换为一个配置模型</td>
</tr>
<tr>
<td>方法调用时机</td>
<td>立即（或解析配置类的最后）</td>
<td>加载 <code>BeanDefinition</code> 的最后</td>
<td></td>
</tr>
<tr>
<td>方法的结果</td>
<td>获取 <code>Import</code> 目标</td>
<td>直接注册 <code>BeanDefinition</code></td>
<td></td>
</tr>
</tbody></table>
<h3 id="处理过程示意图"><a href="#处理过程示意图" class="headerlink" title="处理过程示意图"></a>处理过程示意图</h3><div style="width:70%;margin:auto"><img src="/2023/12/04/use-and-analysis-of-Import-annotation-in-Spring/Pasted%20image%2020231205175232.png" class="" title="Import 注解的处理过程示意图"></div>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 logrotate 滚动 Docker 容器内的 Nginx 的日志</title>
    <url>/2023/12/02/rotating-nginx-logs-in-docker-container-with-logrotate/</url>
    <content><![CDATA[<p><code>Nginx</code> 没有提供开箱即用的日志滚动功能，而是将其交给使用者自己实现。你既可以按照官方文档的建议通过编写脚本实现，也可以使用 <code>logrotate</code> 管理日志。但是和在普通场景下不同，在使用 <code>Docker</code> 运行 <code>Nginx</code> 时，你可能需要额外考虑一点细节。本文记录了在为 <code>Docker</code> 中的 <code>Nginx</code> 的日志文件配置滚动功能过程中遇到的一些问题和思考。</p>
<span id="more"></span>

<h2 id="Nginx-滚动日志"><a href="#Nginx-滚动日志" class="headerlink" title="Nginx 滚动日志"></a>Nginx 滚动日志</h2><h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h3><blockquote>
<p>In order to rotate log files, they need to be renamed first. After that USR1 signal should be sent to the master process. The master process will then re-open all currently open log files and assign them an unprivileged user under which the worker processes are running, as an owner. After successful re-opening, the master process closes all open files and sends the message to worker process to ask them to re-open files. Worker processes also open new files and close old files right away. As a result, old files are almost immediately available for post processing, such as compression.</p>
</blockquote>
<p>根据官方文档的解释，滚动日志文件的流程应如下，你可以自己编写 <code>Shell</code> 脚本配合 <code>crontab</code> 实现定时滚动功能。</p>
<ol>
<li>首先重命名日志文件</li>
<li>之后发送 <code>USR1</code> 信号给 <code>Nginx</code> 主进程，<code>Nginx</code> 将重新打开日志文件</li>
<li>对日志文件进行后处理，比如压缩（可选）</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> access.log access.log.0</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> -USR1 `<span class="built_in">cat</span> master.nginx.pid`</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sleep</span> 1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gzip access.log.0    <span class="comment"># do something with access.log.0</span></span></span><br></pre></td></tr></table></figure>

<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ol>
<li>在没有执行 <code>kill</code> 命令前，即便已经重命名了日志文件，<code>Nginx</code> 还是会向重命名后的文件写入日志。因为在 <code>Linux</code> 系统中，系统内核是根据文件描述符定位文件的。</li>
<li><code>USR1</code> 是自定义信号，软件的作者自己确定收到该信号后做什么。在 <code>Nginx</code> 中，主进程收到信号后，会重新打开所有当前打开的日志文件并将它们分配给一个非特权用户作为所有者，工作进程就是在该所有者下运行的。成功重新打开后，主进程关闭所有打开的文件并向工作进程发送消息，要求它们重新打开文件。工作进程也打开新文件并立即关闭旧文件。</li>
</ol>
<h3 id="使用-logrotate"><a href="#使用-logrotate" class="headerlink" title="使用 logrotate"></a>使用 logrotate</h3><blockquote>
<p>logrotate is designed to ease administration of systems that generate large numbers of log files. It allows automatic rotation, compression, removal, and mailing of log files. Each log file may be handled daily, weekly, monthly, or when it grows too large.</p>
</blockquote>
<p><code>logrotate</code> 旨在简化生成大量日志文件的系统的管理。它允许自动滚动、压缩、删除和邮寄日志文件。每个日志文件可以在每天、每周、每月或当它变得太大时处理。<code>Linux</code> 一般默认安装了 <code>logrotate</code>。</p>
<h4 id="默认配置文件"><a href="#默认配置文件" class="headerlink" title="默认配置文件"></a>默认配置文件</h4><p>查看默认配置文件：<code>cat /etc/logrotate.conf</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># see &quot;man logrotate&quot; for details</span><br><span class="line"># 每周滚动日志文件</span><br><span class="line">weekly</span><br><span class="line"></span><br><span class="line"># 默认使用 adm group，因为这是 /var/log/syslog 的所属组</span><br><span class="line">su root adm</span><br><span class="line"></span><br><span class="line"># 保留 4 周的备份（其实是保留 4 个备份，对应 weekly 的设置，就是保留 4 周）</span><br><span class="line">rotate 4</span><br><span class="line"></span><br><span class="line"># 在滚动旧日志文件后，创建新的空日志文件</span><br><span class="line">create</span><br><span class="line"></span><br><span class="line"># 使用日期作为滚动日志文件的后缀</span><br><span class="line">#dateext</span><br><span class="line"></span><br><span class="line"># 如果你希望压缩日志文件，请取消注释</span><br><span class="line">#compress</span><br><span class="line"></span><br><span class="line"># 软件包将日志滚动的配置信息放入此目录中</span><br><span class="line">include /etc/logrotate.d</span><br><span class="line"></span><br><span class="line"># system-specific logs may be also be configured here.</span><br></pre></td></tr></table></figure>

<h4 id="配置信息所在目录"><a href="#配置信息所在目录" class="headerlink" title="配置信息所在目录"></a>配置信息所在目录</h4><p>查看日志滚动的配置信息所在的目录：<code>ls /etc/logrotate.d/</code>。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">alternatives  apport  apt  bootlog  btmp  dpkg  rsyslog  ubuntu-advantage-tools  ufw  unattended-upgrades  wtmp</span><br></pre></td></tr></table></figure>

<h4 id="为-Nginx-新增配置"><a href="#为-Nginx-新增配置" class="headerlink" title="为 Nginx 新增配置"></a>为 Nginx 新增配置</h4><p>为 <code>Nginx</code> 新增日志滚动配置，<code>vim /etc/logrotate.d/nginx</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/path/to/your/nginx/logs/*.log &#123;</span><br><span class="line">    # 切换用户</span><br><span class="line">    su moralok moralok</span><br><span class="line">    # 每天滚动日志文件</span><br><span class="line">    daily</span><br><span class="line">    # 使用日期作为滚动日志文件的后缀</span><br><span class="line">    dateext</span><br><span class="line">    # 如果日志丢失，不报错继续滚动下一个日志</span><br><span class="line">    missingok</span><br><span class="line">    # 保留 31 个备份</span><br><span class="line">    rotate 31</span><br><span class="line">    # 不压缩</span><br><span class="line">    nocompress</span><br><span class="line">    # 整个日志组运行一次的脚本</span><br><span class="line">    sharedscripts</span><br><span class="line">    # 滚动后的处理</span><br><span class="line">    postrotate</span><br><span class="line">        # 重新打开日志文件        </span><br><span class="line">        docker exec nginx sh -c &quot;[ ! -f /var/run/nginx.pid ] || (kill -USR1 `docker exec nginx cat /var/run/nginx.pid`; echo &#x27;Successfully rotating nginx logs.&#x27;)&quot;</span><br><span class="line">    endscript</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="验证配置和测试"><a href="#验证配置和测试" class="headerlink" title="验证配置和测试"></a>验证配置和测试</h4><p>测试配置文件是否有错误，<code>logrotate -d /etc/logrotate.d/nginx</code>。</p>
<p>强制滚动：<code>logrotate -f /etc/logrotate.d/nginx</code></p>
<h2 id="一些坑"><a href="#一些坑" class="headerlink" title="一些坑"></a>一些坑</h2><h3 id="var-lib-logrotate-权限问题"><a href="#var-lib-logrotate-权限问题" class="headerlink" title="&#x2F;var&#x2F;lib&#x2F;logrotate&#x2F; 权限问题"></a>&#x2F;var&#x2F;lib&#x2F;logrotate&#x2F; 权限问题</h3><p>当你使用校验过配置文件的正确性后，尝试强制滚动时，可能会遇到报错。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">logrotate -f /etc/logrotate.d/nginx</span> </span><br><span class="line">error: error creating output file /var/lib/logrotate/status.tmp: Permission denied</span><br></pre></td></tr></table></figure>

<p>这是因为 logrotate 会在 <code>/var/lib/logrotate/</code> 目录下创建 <code>status</code> 文件。查看目录权限可知，需要以 <code>root</code> 身份运行 <code>logrotate</code>。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ll /var/lib/logrotate</span></span><br><span class="line">total 12</span><br><span class="line">drwxr-xr-x  2 root root 4096 Dec  2 08:35 ./</span><br><span class="line">drwxr-xr-x 44 root root 4096 Jun 26 09:02 ../</span><br><span class="line">-rw-r--r--  1 root root 1395 Dec  2 08:35 status</span><br></pre></td></tr></table></figure>

<p>事实上，<code>logrotate -d /etc/logrotate.d/nginx</code> 命令也会读取 <code>/var/lib/logrotate/status</code>，但是 <code>other</code> 对该目录也有 <code>r</code> 读取权限，所以没有报错。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">logrotate -d /etc/logrotate.d/nginx</span> </span><br><span class="line">WARNING: logrotate in debug mode does nothing except printing debug messages!  Consider using verbose mode (-v) instead if this is not what you want.</span><br><span class="line"></span><br><span class="line">reading config file /etc/logrotate.d/nginx</span><br><span class="line">Reading state from file: /var/lib/logrotate/status</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="日志文件夹的权限"><a href="#日志文件夹的权限" class="headerlink" title="日志文件夹的权限"></a>日志文件夹的权限</h3><p>即使你使用 <code>root</code> 身份运行 <code>logrotate</code>，你可能还会遇到以下报错</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">logrotate -f /etc/logrotate.d/nginx</span> </span><br><span class="line">error: skipping &quot;/path/to/your/nginx/logs/*.log&quot; because parent directory has insecure permissions (It&#x27;s world writable or writable by group which is not &quot;root&quot;) Set &quot;su&quot; directive in config file to tell logrotate which user/group should be used for rotation.</span><br></pre></td></tr></table></figure>

<p>你需要在配置文件中，使用 <code>su &lt;user&gt; &lt;group&gt;</code> 指定日志所在文件夹所属的用户和组，<code>logrotate</code> 才能正确读写。</p>
<h3 id="由宿主机还是容器主导"><a href="#由宿主机还是容器主导" class="headerlink" title="由宿主机还是容器主导"></a>由宿主机还是容器主导</h3><p>首先 <code>Nginx</code> 的日志文件夹通过挂载映射到宿主机，日志滚动既可以由宿主机主导，也可以由容器主导，不过不论如何我们都需要向 <code>Docker</code> 容器内的 <code>Nginx</code> 发送 <code>USR1</code> 信号。有人倾向于在容器内完成所有工作，和宿主机几乎完全隔离；我个人更青睐于由宿主机主导，因为容器内的环境并不总是拥有你想要使用的软件（除非你总是定制自己使用的镜像），甚至标准镜像往往非常精简。</p>
<p>在 <code>logrotate</code> 配置中的 <code>postrotate</code> 部分添加脚本，使用 <code>docker exec</code> 在容器内执行命令，完成向 <code>Nginx</code> 发送信号的工作。脚本的处理逻辑大概是“如果存在 <code>/var/run/nginx.pid</code>，就执行 <code>kill -USR1 \`cat /var/run/nginx.pid\`</code> 命令，并打印成功的消息”。但是我看到很多文章中分享的配置类似下面这样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec nginx sh -c &quot;if [ -f /var/run/nginx.pid ]; then kill -USR1 $(docker exec nginx cat /var/run/nginx.pid); fi&quot;</span><br><span class="line"></span><br><span class="line">docker exec nginx sh -c &quot;[ ! -f /var/run/nginx.pid ] || kill -USR1 `cat /var/run/nginx.pid`;&quot;</span><br></pre></td></tr></table></figure>

<p>经过测试都会有以下报错，我不清楚是否大多是抓取发布的文章，也不清楚他们是否测试过，对于 <code>Shell</code> 脚本写得不多的我来说，半夜测试反复排查错误真是头昏脑胀。在我原先的理解里，<code>-c</code> 后面的脚本是整体发到容器内部执行的，后来我才意识到，我对脚本内部的命令在宿主机还是容器里执行的理解是错误的。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">cat: /var/run/nginx.pid: No such file or directory</span><br></pre></td></tr></table></figure>

<h3 id="继续写入旧日志文件"><a href="#继续写入旧日志文件" class="headerlink" title="继续写入旧日志文件"></a>继续写入旧日志文件</h3><p>在使用 <code>logrotate -f /etc/logrotate.d/nginx</code> 测试通过后的第二天，发现虽然创建了新的日志文件，但是 <code>Nginx</code> 继续写入到旧的日志文件。这不同于网上很多文章提到的“没有发送 <code>USR1</code> 信号给 <code>Nginx</code> ”的情况。</p>
<p>尝试手动发送信号，观察效果。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec nginx sh -c &quot;kill -USR1 `docker exec nginx cat /var/run/nginx.pid`&quot;</span><br></pre></td></tr></table></figure>

<p>发现虽然终止了继续写入到旧的文件，但是在宿主机读取日志时，提示没有权限。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> access.log</span></span><br><span class="line">cat: access.log: Permission denied</span><br></pre></td></tr></table></figure>

<p>查看日志文件权限，发现不对劲。新建的 <code>access.log</code> 的权限为 <code>600</code>，所属用户从 <code>moralok</code> 变为 <code>systemd-resolve</code>，失去了只有所属用户才拥有的 <code>rw</code> 权限。</p>
<blockquote>
<p>此时虽然注意到没有成功创建新的 <code>error.log</code>，但是只是以为对于空的日志文件不滚动。并且在后续重现问题时发现此时其实可以在容器里看到日志开始写入新的日志文件。</p>
</blockquote>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ll</span></span><br><span class="line">total 136</span><br><span class="line">drwxrwxr-x 2 moralok         moralok 4096 Dec  3 00:00 ./</span><br><span class="line">drwxrwxr-x 4 moralok         moralok 4096 Nov 30 17:25 ../</span><br><span class="line">-rw------- 1 moralok         moralok    0 Dec  3 00:00 access.log</span><br><span class="line">-rw-r--r-- 1 systemd-resolve root  109200 Dec  3 07:01 access.log-20231203</span><br><span class="line">-rw-r--r-- 1 systemd-resolve root       0 Dec  2 19:07 error.log</span><br></pre></td></tr></table></figure>

<p>这个时候我的想法是，既然成功创建了新的日志文件，肯定是 <code>Nginx</code> 接收到了 <code>USR1</code> 信号。怎么会出现“<code>crontab</code> 触发时发送信号有问题，手动发送却没问题”的情况呢？难道是两者触发的执行方式有所不同？还是说宿主机创建的文件会有问题？注意到新的日志文件所属的用户和组和原日志文件所属的用户和组不同，我开始怀疑创建文件的过程有问题。在反复测试尝试重现问题后，我把关注点放到了 <code>create</code> 配置上。其实在最开始，我就关注了它，我想既然在默认的配置文件中已经设置而且我也不修改，那么就不在 <code>/etc/logrotate.d/nginx</code> 添加了。我甚至花了很多时间浏览文档，确认它在缺省后面的权限属性时会使用原日志文件的权限属性。当时我还专门记录了一个疑问，“文档说在运行 <code>postrotate</code> 脚本前创建新文件，可是在测试验证时，新文件是 <code>Nginx</code> 接收 <code>USR1</code> 信号后重新打开文件时创建的，在脚本执行报错或者脚本中并不发送信号时，不会产生新文件”。现在想来，都是坑，坑里注定要灌满眼泪！</p>
<p>在 <code>/etc/logrotate.d/nginx</code> 添加 <code>create</code> 后，成功重现问题。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">renaming /path/to/your/nginx/logs/access.log to /path/to/your/nginx/logs/access.log-20231203</span><br><span class="line">creating new /path/to/your/nginx/logs/access.log mode = 0644 uid = 101 gid = 0</span><br><span class="line">error: error setting owner of /path/to/your/nginx/logs/access.log to uid 101 and gid 0: Operation not permitted</span><br><span class="line">switching euid to 0 and egid to 0</span><br></pre></td></tr></table></figure>

<p>可见 <code>logrotate -f /etc/logrotate.d/nginx</code>，并没有使用到默认配置 <code>/etc/logrotate.conf</code>，而 <code>crontab</code> 触发 <code>logrotate</code> 时使用到了。修改为 <code>create 0644 moralok moralok</code>，成功解决问题。可以确认 <code>create</code> 在缺省权限属性的时候，如果日志文件因为挂载到容器中而被修改了所属用户，<code>logrotate</code> 按照原文件的权限属性创建新文件时会报错，从而导致脚本不能正常执行，<code>Nginx</code> 不会收到信号，<code>error.log</code> 也不会继续滚动。按此原因推理，在配置文件中，加入 <code>nocreate</code> 也可以解决问题，并且更加符合官方文档建议的流程。</p>
<blockquote>
<p>枯坐一下午，百思不得其解，想到抓狂。不得不说真的很讨厌这类问题，特定条件下奇怪的问题，食之无味，弃之还不行！如果照着网上的文章，一开始就添加配置真的不会遇到啊。可是不喜欢不明不白地修改配置来解决问题，也不喜欢一次性加很多设置却不知道各个配置的功能，特别是在我的理解里这个默认配置似乎没问题的情况下。明明想要克制住不知重点还不断深入探索细节的坏习惯，却还是被一个 <code>Bug</code> 带着花费了大量的时间和精力，解决了一个照着抄就不会遇到的问题。虽然真的有收获，真的解决了前一晚留下的疑问，可是不甘心啊，气气气！而且为什么这样会有问题，我还是不懂！</p>
</blockquote>
<h2 id="logrotate-备忘"><a href="#logrotate-备忘" class="headerlink" title="logrotate 备忘"></a>logrotate 备忘</h2><p><a href="https://linux.die.net/man/8/logrotate">帮助文档</a></p>
<h3 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-d, --debug : 打开调试模式，这意味着不会对日志进行任何更改，并且 logrotate 状态文件不会更新。仅打印调试消息。</span><br><span class="line">-f, --force : 告诉 logrotate 强制滚动，即使它认为这没有必要。有时，在将新条目添加到 logrotate 配置文件后，或者如果已手动删除旧日志文件，这会很有用，因为将创建新文件，并且正确地继续记录日志。</span><br><span class="line">-m, --mail &lt;command&gt; : 告诉 logrotate 在邮寄日志时使用哪个命令。此命令应接受两个参数：消息的主题，收件人。然后，该命令必须读取标准输入上的消息并将其邮寄给收件人。默认邮件命令是 /bin/mail -s。</span><br><span class="line">-s, --state &lt;statefile&gt; : 告诉 logrotate 使用备用状态文件。如果 logrotate 以不同用户身份运行不同的日志文件集，这会非常有用。默认状态文件是 /var/lib/logrotate/status。</span><br><span class="line">--usage : 打印简短的用法信息。</span><br><span class="line">--?, --help : 打印帮助信息。</span><br><span class="line">-v, --verbose : 打开详细模式，例如在滚动期间显示消息。</span><br></pre></td></tr></table></figure>

<h3 id="常用配置文件参数"><a href="#常用配置文件参数" class="headerlink" title="常用配置文件参数"></a>常用配置文件参数</h3><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>daily</td>
<td>周期：每天</td>
</tr>
<tr>
<td>weekly</td>
<td>周期：每周</td>
</tr>
<tr>
<td>monthly</td>
<td>周期：每月</td>
</tr>
<tr>
<td>yearly</td>
<td>周期：每年</td>
</tr>
<tr>
<td>dateext</td>
<td>使用日期代替数字作为扩展名（YYYYMMDD），如：access.log-20231202</td>
</tr>
<tr>
<td>dateformat</td>
<td>必须配合 dateext 使用，只支持 %Y %m %d %s 这四个参数</td>
</tr>
<tr>
<td>compress</td>
<td>使用 gzip 压缩旧版本日志文件</td>
</tr>
<tr>
<td>nocompress</td>
<td>不压缩</td>
</tr>
<tr>
<td>delaycompress</td>
<td>延迟到下一次滚动周期再压缩</td>
</tr>
<tr>
<td>nodelaycompress</td>
<td>不延迟压缩，覆盖 delaycompress</td>
</tr>
<tr>
<td>create mode owner group</td>
<td>滚动后（运行 postrotate 脚本前），立即创建日志文件，指定权限属性</td>
</tr>
<tr>
<td>nocreate</td>
<td>不创建新的日志文件，覆盖 create</td>
</tr>
<tr>
<td>copytruncate</td>
<td>创建副本后就地截断原始日志文件，用于一些无法被告知关闭日志文件的程序，可能会丢失复制和截断之间的日志</td>
</tr>
<tr>
<td>nocopytruncate</td>
<td>不截断始日志文件，覆盖 copytruncate</td>
</tr>
<tr>
<td>ifempty</td>
<td>即使是空文件也滚动（默认），覆盖 notifempty</td>
</tr>
<tr>
<td>missingok</td>
<td>如果日志丢失，不报错继续滚动下一个日志</td>
</tr>
<tr>
<td>notifempty</td>
<td>如果是空文件，不滚动，覆盖 ifempty</td>
</tr>
<tr>
<td>sharedscripts</td>
<td>在所有日志都滚动后统一执行一次脚本。如果没有配置，每个日志滚动后都会执行一次脚本</td>
</tr>
<tr>
<td>prerotate&#x2F;endscript</td>
<td>存放在滚动以前需要执行的脚本，两者必须单独成行</td>
</tr>
<tr>
<td>postrotate&#x2F;endscript</td>
<td>存放在滚动以后需要执行的脚本，两者必须单独成行</td>
</tr>
<tr>
<td>rotate count</td>
<td>日志文件在删除或邮寄前滚动的次数，0 指没有备份</td>
</tr>
<tr>
<td>size log-size</td>
<td>当日志文件到达指定的大小时才滚动，默认单位 byte，可以使用 k、M、G</td>
</tr>
</tbody></table>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://nginx.org/en/docs/control.html#logs">Rotating Log-files</a></li>
<li><a href="https://www.nginx.com/resources/wiki/start/topics/examples/logrotation/">Log Rotation</a></li>
<li><a href="https://linux.die.net/man/8/logrotate">logrotate(8) - Linux man page</a></li>
<li><a href="https://serverfault.com/questions/1023555/error-error-creating-output-file-var-lib-logrotate-status-tmp-permission-deni">error: error creating output file &#x2F;var&#x2F;lib&#x2F;logrotate.status.tmp: Permission denied</a></li>
<li><a href="https://stackoverflow.com/questions/26482773/apache-and-logrotate-configuration">apache-and-logrotate-configuration</a></li>
<li><a href="https://blog.slogra.com/post-792.html">docker nginx&#x2F;openresty容器使用logrotate日志切割</a></li>
</ul>
]]></content>
      <tags>
        <tag>docker</tag>
        <tag>nginx</tag>
        <tag>logrotate</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 自定义 starter 和自动配置的工作原理</title>
    <url>/2023/12/06/custom-starter-and-auto-configuration-in-Spring-Boot/</url>
    <content><![CDATA[<p>如果你正在参与一个共享库的开发，你可能会想为使用方提供自动配置的支持，以帮助对方快速地接入和使用。自动配置机制往往和 <code>starter</code> 联系在一起，本文将介绍如何创建一个自定义的 <code>starter</code> 并从源码角度分析 <code>Spring Boot</code> 自动配置的工作原理。</p>
<span id="more"></span>

<h2 id="自定义-starter"><a href="#自定义-starter" class="headerlink" title="自定义 starter"></a>自定义 starter</h2><p>一个 library 的完整 <code>Spring Boot starter</code> 可能包含以下组件：</p>
<ul>
<li>自动配置模块：包含自动配置的代码。</li>
<li>启动模块：提供“自动配置模块、library 以及其他有用的依赖项”的依赖项。简而言之，添加 <code>starter</code> 之后应该足以开始使用这个 library。</li>
</ul>
<blockquote>
<p><strong>如果你不需要将自动配置的代码和依赖项管理分开，你可以将它们合并到一个模块中</strong>。</p>
</blockquote>
<h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><ul>
<li>不要以 <code>spring-boot</code> 开头命名模块，即使你使用的是不同的 Maven groupId，因为 <code>Spring</code> 可能在将来提供官方的自动配置支持。自定义 <code>starter</code> 约定俗成的命名方式是 <code>xxx-spring-boot-starter</code>。</li>
<li>如果你的 <code>starter</code> 提供了配置属性的定义，请选择适当的命名空间，避免使用 <code>Spring Boot</code> 的命名空间，否则他们未来的修改可能破坏你的配置。</li>
</ul>
<p>以下将通过一款基于 <code>Redis</code> 实现的分布式锁 <a href="https://github.com/moralok/redis-lock"><strong>redis-lock</strong></a> 的 <code>starter</code> 介绍如何创建一个自定义的 <code>Spring Boot starter</code>。<strong>注意：实际上项目中的的 <code>redis-lock-spring-boot-starter</code> 合并了自动配置模块和启动模块</strong>。</p>
<h3 id="自动配置模块"><a href="#自动配置模块" class="headerlink" title="自动配置模块"></a>自动配置模块</h3><p>自动配置模块包含开始使用 library 所需要的一切配置。它还可能包含配置键定义（<code>@ConfigurationProperties</code>）和任何其他可用于进一步自定义组件初始化方式的回调接口。</p>
<p>按照惯例，模块命名为 <code>redis-lock-spring-boot-autoconfigure</code>。</p>
<h4 id="依赖项"><a href="#依赖项" class="headerlink" title="依赖项"></a>依赖项</h4><p>自动配置模块需要添加以下依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h4><p>和平常在 <code>Spring</code> 中使用一个 library 时一样，创建配置类并配置好使用它所需要的 <code>Bean</code>。</p>
<ul>
<li><code>Configuration</code> 注解，标识为配置类</li>
<li><code>Bean</code> 注解，配置所需要的 <code>Bean</code></li>
<li><code>EnableConfigurationProperties</code> 注解，启用配置属性（可选）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(RedisLockProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisLockAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisLockProperties redisLockProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(RedisClient.class)</span></span><br><span class="line">    <span class="keyword">public</span> RedisClient <span class="title function_">redisClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">RedisURI</span> <span class="variable">redisURI</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisURI</span>();</span><br><span class="line">        redisURI.setHost(redisLockProperties.getHost());</span><br><span class="line">        redisURI.setPort(redisLockProperties.getPort());</span><br><span class="line">        redisURI.setDatabase(redisLockProperties.getDatabase());</span><br><span class="line">        <span class="keyword">if</span> (redisLockProperties.getUsername() != <span class="literal">null</span>) &#123;</span><br><span class="line">            redisURI.setUsername(redisLockProperties.getUsername());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (redisLockProperties.getPassword() != <span class="literal">null</span>) &#123;</span><br><span class="line">            redisURI.setUsername(redisLockProperties.getPassword());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> RedisClient.create(redisURI);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(RedisLockManager.class)</span></span><br><span class="line">    <span class="keyword">public</span> RedisLockManager <span class="title function_">redisLockManager</span><span class="params">(RedisClient redisClient)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RedisLockManager</span>(redisClient);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="配置属性"><a href="#配置属性" class="headerlink" title="配置属性"></a>配置属性</h4><p>你可能需要定义一些配置属性来设置使用 library 所需要的属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = RedisLockProperties.PREFIX)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisLockProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PREFIX</span> <span class="operator">=</span> <span class="string">&quot;redis-lock&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">6379</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">database</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> waitTimeMillis;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> leaseTimeMillis;</span><br><span class="line">    <span class="comment">// 省略 setter 和 getter 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="spring-factories-文件"><a href="#spring-factories-文件" class="headerlink" title="spring.factories 文件"></a>spring.factories 文件</h4><p>在 <code>src/main/resources/META-INF</code> 目录中添加一个 <code>spring.factories</code> 文件，文件内容如下。键为 <code>EnableAutoConfiguration</code> 的全限定名，值为配置类的全限定名，如果需要配置多个配置类，可以用逗号分隔。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">com.moralok.redislock.autoconfigure.RedisLockAutoConfiguration</span></span><br></pre></td></tr></table></figure>

<h3 id="启动模块"><a href="#启动模块" class="headerlink" title="启动模块"></a>启动模块</h3><p><code>starter</code> 实际上是一个空的 <code>jar</code>，它唯一的目的就是提供使用 <code>library</code> 所需要的依赖项。</p>
<p>按照惯例，模块命名为 <code>redis-lock-spring-boot-starter</code>。</p>
<p>需要引入以下依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- library 的依赖项 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.moralok.redis-lock<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;redis-lock.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 自动配置模块的依赖项 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redis-lock-spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;redis-lock.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 其他需要的依赖的依赖项，比如日志相关的 --&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>这样就创建了一个自定义 <code>starter</code>。在项目中引入 <code>starter</code> 后，无需进一步配置，即可使用 <code>RedisLockManager</code> 和 <code>RedisClient</code>。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.moralok.redis-lock<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redis-lock-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;redis-lock.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="自动配置的工作原理"><a href="#自动配置的工作原理" class="headerlink" title="自动配置的工作原理"></a>自动配置的工作原理</h2><p>从自定义 <code>starter</code> 的过程来看，使用 <code>library</code> 所需要的配置类和依赖项并没有“凭空消失”，而是由 <code>starter</code> 的编写者提供。然而在正常情况下，第三方的 <code>jar</code> 中的配置类并不在 <code>Spring</code> 扫描 <code>Bean</code> 的范围内，那么 <code>starter</code> 中的配置类是如何被注册到 <code>Spring</code> 容器中呢？我们做的事情中，看起来比较特别的一件事情是添加了 <code>spring.factories</code> 文件。</p>
<h3 id="SpringBootApplication-注解"><a href="#SpringBootApplication-注解" class="headerlink" title="SpringBootApplication 注解"></a>SpringBootApplication 注解</h3><p>在 <code>Spring Boot</code> 的启动类（也是 <code>Spring context</code> 的最初配置类）上，标注了 <code>SpringBootApplication</code> 注解。该注解上标注了 <code>EnableAutoConfiguration</code> 注解，它的全限定名正是 <code>spring.factories</code> 文件中配置的键。注解的名字表明它用于<strong>启用自动配置</strong>功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123;</span></span><br><span class="line"><span class="meta">		@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@AliasFor(annotation = EnableAutoConfiguration.class)</span></span><br><span class="line">	Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@AliasFor(annotation = EnableAutoConfiguration.class)</span></span><br><span class="line">	String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackages&quot;)</span></span><br><span class="line">	String[] scanBasePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackageClasses&quot;)</span></span><br><span class="line">	Class&lt;?&gt;[] scanBasePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="启用自动配置"><a href="#启用自动配置" class="headerlink" title="启用自动配置"></a>启用自动配置</h3><p><code>EnableAutoConfiguration</code> 注解用于启用自动配置功能。该注解上标注了 <code>Import</code> 注解，导入了 <code>AutoConfigurationImportSelector</code>。很多形似 <code>EnableXXX</code> 的注解都是通过 <code>Import</code> 注解导入（注册）一些配置类，达到启用 <code>XXX</code> 功能的目的。<code>Import</code> 注解的功能详见之前的文章：</p>
<ul>
<li><a href="/2023/12/04/use-and-analysis-of-Import-annotation-in-Spring/" title="Spring 中 @Import 注解的使用和源码分析">Spring 中 @Import 注解的使用和源码分析</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">String</span> <span class="variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="operator">=</span> <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line">	Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自动配置导入选择器"><a href="#自动配置导入选择器" class="headerlink" title="自动配置导入选择器"></a>自动配置导入选择器</h3><p>导入选择器 <code>ImportSelector</code> 的 <code>selectImports</code> 方法返回要导入的类的全限定名。<code>AutoConfigurationImportSelector</code> 的名字含义是自动配置导入选择器，顾名思义它返回的应该是要导入的<strong>自动配置类</strong>。自动配置类这个说法有点容易让人误解，好像这个配置类本身具备“自动”的特性，实际上它就是一个普通的配置类。自动配置描述的是一种机制，想象一下，如果我们在 <code>selectImports</code> 方法中返回 <code>starter</code> 中的配置类 <code>RedisLockAutoConfiguration</code>，是不是就为 <code>redis-lock</code> 完成了自动配置。事实上，<code>selectImports</code> 方法的作用就是找到并返回那些需要被自动配置的配置类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">    <span class="comment">// 检测是否启用自动配置</span></span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="comment">// 如果未启用，返回空数组</span></span><br><span class="line">        <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 加载自动配置的元数据</span></span><br><span class="line">        <span class="type">AutoConfigurationMetadata</span> <span class="variable">autoConfigurationMetadata</span> <span class="operator">=</span> AutoConfigurationMetadataLoader</span><br><span class="line">                .loadMetadata(<span class="built_in">this</span>.beanClassLoader);</span><br><span class="line">        <span class="comment">// 获取注解中配置的 exclude 和 excludeName</span></span><br><span class="line">        <span class="type">AnnotationAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> getAttributes(annotationMetadata);</span><br><span class="line">        <span class="comment">// 核心方法：获取候选的配置类</span></span><br><span class="line">        List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,</span><br><span class="line">                attributes);</span><br><span class="line">        <span class="comment">// 移除重复的</span></span><br><span class="line">        configurations = removeDuplicates(configurations);</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        configurations = sort(configurations, autoConfigurationMetadata);</span><br><span class="line">        <span class="comment">// 从注解的配置中获取需要排除的</span></span><br><span class="line">        Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">        <span class="comment">// 检查排除的类，如果已加载且不在 configurations 中，抛出异常（不理解原因）</span></span><br><span class="line">        checkExcludedClasses(configurations, exclusions);</span><br><span class="line">        <span class="comment">// 移除需要排除的</span></span><br><span class="line">        configurations.removeAll(exclusions);</span><br><span class="line">        <span class="comment">// 过滤，获取 spring.factories 中的 AutoConfigurationImportFilter 执行过滤</span></span><br><span class="line">        configurations = filter(configurations, autoConfigurationMetadata);</span><br><span class="line">        <span class="comment">// 触发自动配置类导入事件</span></span><br><span class="line">        fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">        <span class="keyword">return</span> StringUtils.toStringArray(configurations);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过环境变量 <code>spring.boot.enableautoconfiguration</code> 覆盖是否启用自动配置功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">(AnnotationMetadata metadata)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (getClass() == AutoConfigurationImportSelector.class) &#123;</span><br><span class="line">        <span class="keyword">return</span> getEnvironment().getProperty(</span><br><span class="line">                EnableAutoConfiguration.ENABLED_OVERRIDE_PROPERTY, Boolean.class,</span><br><span class="line">                <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取候选的配置类"><a href="#获取候选的配置类" class="headerlink" title="获取候选的配置类"></a>获取候选的配置类</h3><p>我们前面提到过，自动配置类本身只是普通的配置类，那么有什么标记或特征表明目标是一个自动配置类吗？有的，凡是配置在 <code>spring.factories</code> 文件中 <code>EnableAutoConfiguration</code>（<code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code>） 键下的类，就是候选的自动配置类。<br><code>getCandidateConfigurations</code> 方法用于获取候选的配置类。该方法运用了 <strong><code>Spring</code> 的 <code>SPI</code></strong> 机制，通过 <code>SpringFactoriesLoader</code> 获得所有配置在 <code>spring.factories</code> 文件中，<code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code> 键下的类，其中就包括了 <code>RedisLockAutoConfiguration</code>。这样就完成了自动配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> List&lt;String&gt; <span class="title function_">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata,</span></span><br><span class="line"><span class="params">        AnnotationAttributes attributes)</span> &#123;</span><br><span class="line">    <span class="comment">// 通过 SpringFactoriesLoader 加载候选的配置</span></span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(</span><br><span class="line">            getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());</span><br><span class="line">    Assert.notEmpty(configurations,</span><br><span class="line">            <span class="string">&quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;</span></span><br><span class="line">                    + <span class="string">&quot;are using a custom packaging, make sure that file is correct.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() &#123;</span><br><span class="line">    <span class="keyword">return</span> EnableAutoConfiguration.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于 <code>Spring Boot SPI</code> 机制获取配置在 <code>spring.factories</code> 文件中的自动配置类的过程我们不再分析，可以参见以下文章：</p>
<ul>
<li><a href="/2023/12/06/how-does-Spring-Boot-SPI-works/" title="Spring Boot SPI 的工作原理">Spring Boot SPI 的工作原理</a></li>
</ul>
<h2 id="让-starter-更好用"><a href="#让-starter-更好用" class="headerlink" title="让 starter 更好用"></a>让 starter 更好用</h2><h3 id="为配置属性生成元数据"><a href="#为配置属性生成元数据" class="headerlink" title="为配置属性生成元数据"></a>为配置属性生成元数据</h3><p>在平时开发时你可能会注意到，有时候在配置文件 <code>application.properties</code> 或 <code>application.yml</code> 中编写配置时，<code>IDEA</code> 会自动提示我们存在哪些配置，默认值是什么。</p>
<div style="width:70%;margin:auto"><img src="/2023/12/06/custom-starter-and-auto-configuration-in-Spring-Boot/Snipaste_2023-12-07_00-08-47.png" class="" title="IDEA 对配置属性的智能提示"></div>

<p>只需要添加以下依赖，在编译项目时，就会自动调用该处理器 <code>spring-boot-configuration-processor</code> 为你的项目中被 <code>ConfigurationProperties</code> 注解标注的类生成配置元数据文件。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：不要盲目手打相信智能提示弄错了依赖，谁能想到 <code>Spring</code> 有好几个命名这么像的 <code>processor</code>，偏偏网上还有各种复制粘贴的文章解答在多模块项目中 <code>spring-boot-configuration-processor</code> 出现的问题——来自 <code>Debug</code> 到深夜的人的怨念。</p>
</blockquote>
<div style="width:70%;margin:auto"><img src="/2023/12/06/custom-starter-and-auto-configuration-in-Spring-Boot/Snipaste_2023-12-06_23-52-47.png" class="" title="易弄错的 processor"></div>

<h3 id="配合-Conditional-注解"><a href="#配合-Conditional-注解" class="headerlink" title="配合 Conditional 注解"></a>配合 Conditional 注解</h3><p>你几乎总是希望在自动配置类中包含一个或者多个 <code>Conditional</code> 注解。<code>ConditionalOnMissingBean</code> 是一个常用的注解，允许开发人员在对默认设置不满意时覆盖自动配置。</p>
<h3 id="谨慎地提供依赖"><a href="#谨慎地提供依赖" class="headerlink" title="谨慎地提供依赖"></a>谨慎地提供依赖</h3><p>不要对添加 <code>starter</code> 的项目做出假设，如果你的 <code>starter</code> 需要用到别的 <code>starter</code>，也请提到它们。为你的 library 的典型用法选择一组适当的默认依赖，避免引入不必要的依赖项，尽管当可选的依赖项很多时这可能有些困难。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Spring Boot</code> 的自动配置在底层是通过标准的 <code>Configuration</code> 注解实现的，配合 <code>Conditional</code> 注解限制何时应用自动配置。“自动”的特性是基于两个重要的机制：</p>
<ul>
<li><code>SPI</code> 机制，从 <code>spring.factories</code> 文件中，获取自动配置类的全限定类名</li>
<li><code>Import</code> 机制，导入从 <code>ImportSelector</code> 返回的类</li>
</ul>
<p>工作原理的示意图如下：</p>
<div style="width:70%;margin:auto"><img src="/2023/12/06/custom-starter-and-auto-configuration-in-Spring-Boot/Pasted%20image%2020231206230317.png" class="" title="Spring Boot 自动装配工作原理"></div>

<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://docs.spring.io/spring-boot/docs/1.5.11.RELEASE/reference/html/boot-features-developing-auto-configuration.html">Creating your own auto-configuration</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/1.5.11.RELEASE/reference/html/configuration-metadata.html#configuration-metadata-annotation-processor">Generating your own meta-data using the annotation processor</a></li>
<li><a href="/2023/12/04/use-and-analysis-of-Import-annotation-in-Spring/" title="Spring 中 @Import 注解的使用和源码分析">Spring 中 @Import 注解的使用和源码分析</a></li>
<li><a href="/2023/12/06/how-does-Spring-Boot-SPI-works/" title="Spring Boot SPI 的工作原理">Spring Boot SPI 的工作原理</a></li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>spring boot</tag>
        <tag>auto configuration</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot SPI 的工作原理</title>
    <url>/2023/12/06/how-does-Spring-Boot-SPI-works/</url>
    <content><![CDATA[<p>在分析 <code>Spring Boot</code> 自动配置的工作原理时，我们并没有深入“如何获得配置在 <code>spring.factories</code> 中的自动配置类”。本文将从图解和源码两个角度分析 <code>Spring Boot SPI</code> 机制，了解 <code>spring.factories</code> 中的配置是如何被加载和解析成为缓存中的“接口-实现”键值对。</p>
<span id="more"></span>

<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>Spring Boot SPI</code> 是一个框架内部使用的工厂加载机制。</p>
<p><code>SpringFactoriesLoader</code> 从 “<code>META-INF/spring.factories</code>” 文件加载并实例化给定类型的工厂，这些文件可能存在于类路径下的多个 <code>JAR</code>q 文件中。</p>
<p><code>spring.factories</code> 文件必须采用 <code>Properties</code> 格式，其中键是接口或抽象类的全限定名称，值是逗号分隔的实现类的全限定名称列表。例如：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">example.MyService</span>=<span class="string">example.MyServiceImpl1,example.MyServiceImpl2</span></span><br></pre></td></tr></table></figure>

<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><p><code>loadSpringFactories</code> 方法加载以及缓存所有工厂是以 <code>ClassLoader</code> 为单位的，过程如下：</p>
<div style="width:70%;margin:auto"><img src="/2023/12/06/how-does-Spring-Boot-SPI-works/Pasted%20image%2020231207024143.png" class="" title="加载所有工厂"></div>

<p>资源从一个位置名称字符串转换为缓存中的键值对，经历了以下过程。</p>
<div style="width:70%;margin:auto"><img src="/2023/12/06/how-does-Spring-Boot-SPI-works/Pasted%20image%2020231207024151.png" class="" title="从资源位置的名称转换为键值对"></div>


<p>缓存的结构示意图</p>
<div style="width:70%;margin:auto"><img src="/2023/12/06/how-does-Spring-Boot-SPI-works/Pasted%20image%2020231207024134.png" class="" title="从资源位置的名称转换为键值对"></div>

<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SpringFactoriesLoader</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 寻找工厂的位置</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;可以存在于多个 JAR 文件中</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FACTORIES_RESOURCE_LOCATION</span> <span class="operator">=</span> <span class="string">&quot;META-INF/spring.factories&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Log</span> <span class="variable">logger</span> <span class="operator">=</span> LogFactory.getLog(SpringFactoriesLoader.class);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;ClassLoader, MultiValueMap&lt;String, String&gt;&gt; cache = <span class="keyword">new</span> <span class="title class_">ConcurrentReferenceHashMap</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用给定的类加载器从“META-INF/spring.factories”文件加载并实例化给定类型的工厂实现。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;返回的工厂通过 AnnotationAwareOrderComparator 进行排序。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;如果需要自定义实例化策略，可以使用 loadFactoryNames 方法获取所有注册的工厂名称。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">loadFactories</span><span class="params">(Class&lt;T&gt; factoryClass, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line">        Assert.notNull(factoryClass, <span class="string">&quot;&#x27;factoryClass&#x27; must not be null&quot;</span>);</span><br><span class="line">        <span class="comment">// 确定使用的 class loader</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoaderToUse</span> <span class="operator">=</span> classLoader;</span><br><span class="line">        <span class="keyword">if</span> (classLoaderToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">            classLoaderToUse = SpringFactoriesLoader.class.getClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用给定的类加载器从“META-INF/spring.factories”文件加载给定类型的工厂实现的全限定名称。</span></span><br><span class="line">        List&lt;String&gt; factoryNames = loadFactoryNames(factoryClass, classLoaderToUse);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Loaded [&quot;</span> + factoryClass.getName() + <span class="string">&quot;] names: &quot;</span> + factoryNames);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;T&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(factoryNames.size());</span><br><span class="line">        <span class="comment">// 遍历工厂实现的全限定名</span></span><br><span class="line">        <span class="keyword">for</span> (String factoryName : factoryNames) &#123;</span><br><span class="line">            <span class="comment">// 实例化工厂实现</span></span><br><span class="line">            result.add(instantiateFactory(factoryName, factoryClass, classLoaderToUse));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用 AnnotationAwareOrderComparator 对结果进行排序</span></span><br><span class="line">        AnnotationAwareOrderComparator.sort(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用给定的类加载器从“META-INF/spring.factories”文件加载给定类型的工厂实现的全限定名称。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryClass, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">factoryClassName</span> <span class="operator">=</span> factoryClass.getName();</span><br><span class="line">        <span class="keyword">return</span> loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用给定的类加载器从“META-INF/spring.factories”文件加载所有的工厂。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; <span class="title function_">loadSpringFactories</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line">        <span class="comment">// 从缓存中获取</span></span><br><span class="line">        MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);</span><br><span class="line">        <span class="comment">// 如果缓存中已存在，返回结果</span></span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        <span class="comment">// 如果缓存中不存在</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从类路径下查找给定名称的所有资源</span></span><br><span class="line">            Enumeration&lt;URL&gt; urls = (classLoader != <span class="literal">null</span> ?</span><br><span class="line">                    classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">                    ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">            result = <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">// 遍历资源</span></span><br><span class="line">            <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">                <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> urls.nextElement();</span><br><span class="line">                <span class="type">UrlResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlResource</span>(url);</span><br><span class="line">                <span class="comment">// 从给定资源中加载属性</span></span><br><span class="line">                <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> PropertiesLoaderUtils.loadPropertie(resource);</span><br><span class="line">                <span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">                    <span class="comment">// 将值按逗号分割成列表</span></span><br><span class="line">                    List&lt;String&gt; factoryClassNames = Arrays.asList(</span><br><span class="line">                            StringUtils.commaDelimitedListToStringArray((String) entry.getValue()));</span><br><span class="line">                    result.addAll((String) entry.getKey(), factoryClassNames);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 放入缓存</span></span><br><span class="line">            cache.put(classLoader, result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unable to load factories from location [&quot;</span> +</span><br><span class="line">                    FACTORIES_RESOURCE_LOCATION + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">instantiateFactory</span><span class="params">(String instanceClassName, Class&lt;T&gt; factoryClass, ClassLoader classLoader)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 加载类</span></span><br><span class="line">            Class&lt;?&gt; instanceClass = ClassUtils.forName(instanceClassName, classLoader);</span><br><span class="line">            <span class="comment">// 检测 factoryClass 是否和 instanceClass 相同，或者是其超类或超接口</span></span><br><span class="line">            <span class="keyword">if</span> (!factoryClass.isAssignableFrom(instanceClass)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                        <span class="string">&quot;Class [&quot;</span> + instanceClassName + <span class="string">&quot;] is not assignable to [&quot;</span> + factoryClass.getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 通过反射进行实例化</span></span><br><span class="line">            <span class="keyword">return</span> (T) ReflectionUtils.accessibleConstructor(instanceClass).newInstance();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unable to instantiate factory class: &quot;</span> + factoryClass.getName(), ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>spring.factories</code> 中的键值对并非严格的接口-实现关系，比如 <code>Spring Boot</code> 自动配置机制中，<code>EnableAutoConfiguration</code> 的值是标准的配置类（被 Configuration 注解标注的类）。因此在实例化方法中，需要检测是否可赋值。</p>
<p><code>loadFactories</code> 方法默认实例化给定类型的所有工厂，如果需要自定义实例化策略，可以通过 loadFactoryNames 方法获取所有注册的工厂。</p>
<blockquote>
<p><code>SpringFactoriesLoader</code> 的源码既简单又不简单，代码较少，逻辑也清晰，但是查找资源并加载部分用到的 <code>API</code>，如 <code>UrlResource</code>、<code>MultiMap</code>，并不大熟悉，感觉很多框架里加载和解析资源部份的代码都不大好学以致用。</p>
</blockquote>
]]></content>
      <tags>
        <tag>spring</tag>
        <tag>spi</tag>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 中 @PropertySource 注解的使用和源码分析</title>
    <url>/2023/12/07/use-and-analysis-of-PropertySource-annotation-in-Spring/</url>
    <content><![CDATA[<p><code>@PropertySource</code> 注解提供了一种方便的声明性机制，用于将 <code>PropertySource</code> 添加到 <code>Spring</code> 容器的 <code>Environment</code> 环境中。该注解通常搭配 <code>@Configuration</code> 注解一起使用。本文将介绍如何使用 <code>@PropertySource</code> 注解，并通过分析源码解释外部配置文件是如何被解析进入 <code>Spring</code> 的 <code>Environment</code> 中。</p>
<span id="more"></span>

<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p><code>@Configuration</code> 注解表示这是一个配置类，<code>Spring</code> 在处理配置类时，会解析并处理配置类上的 <code>@PropertySource</code> 注解，将对应的配置文件解析为 <code>PropertySource</code>，添加到 <code>Spring</code> 容器的 <code>Environment</code> 环境中。这样就可以在其他的 <code>Bean</code> 中，使用 <code>@Value</code> 注解使用这些配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource(value = &quot;classpath:/player.properties&quot;, encoding = &quot;UTF-8&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertySourceConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Player <span class="title function_">player</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Player</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;player.nickname&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String nickname;</span><br><span class="line">    <span class="comment">// 省略 setter 和 getter 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">player.nickname</span>=<span class="string">Tom</span></span><br></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertySourceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(PropertySourceConfig.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">Player</span> <span class="variable">player</span> <span class="operator">=</span> (Player) ac.getBean(<span class="string">&quot;player&quot;</span>);</span><br><span class="line">        System.out.println(player);</span><br><span class="line"></span><br><span class="line">        <span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> ac.getEnvironment();</span><br><span class="line">        <span class="type">String</span> <span class="variable">property</span> <span class="operator">=</span> environment.getProperty(<span class="string">&quot;player.nickname&quot;</span>);</span><br><span class="line">        System.out.println(property);</span><br><span class="line"></span><br><span class="line">        ac.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Player&#123;name=&#x27;null&#x27;, age=null, nickname=&#x27;Tom&#x27;&#125;</span><br><span class="line">Tom</span><br></pre></td></tr></table></figure>

<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>关于 <code>Spring</code> 是如何处理配置类的请参见之前的文章：</p>
<ul>
<li><a href="/2023/11/23/source-code-analysis-of-Spring-Configuration-annotation/" title="Spring @Configuration 注解的源码分析">Spring @Configuration 注解的源码分析</a></li>
</ul>
<h3 id="获取-PropertySource-注解属性"><a href="#获取-PropertySource-注解属性" class="headerlink" title="获取 @PropertySource 注解属性"></a>获取 @PropertySource 注解属性</h3><p><code>Spring</code> 在解析配置类构建配置模型时，会对配置类上的 <code>@PropertySource</code> 注解进行处理。<code>Spring</code> 将获取所有的 <code>@PropertySource</code> 注解属性，并遍历进行处理。</p>
<ul>
<li><code>@PropertySource</code> 注解是可重复的，一个类上可以标注多个</li>
<li><code>@PropertySources</code> 注解包含 <code>@PropertySource</code> 注解</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> SourceClass <span class="title function_">doProcessConfigurationClass</span><span class="params">(ConfigurationClass configClass, SourceClass sourceClass)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 处理 @PropertySource 注解</span></span><br><span class="line">    <span class="comment">// 获取所有 @PropertySource 注解的属性并遍历。注意该注解为可重复的。</span></span><br><span class="line">    <span class="keyword">for</span> (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">            sourceClass.getMetadata(), PropertySources.class,</span><br><span class="line">            org.springframework.context.annotation.PropertySource.class)) &#123;</span><br><span class="line">        <span class="comment">// 如果 environment 是 ConfigurableEnvironment 的一个实例，目前恒为 true</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.environment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">            <span class="comment">// 处理单个 @PropertySource 注解的属性</span></span><br><span class="line">            processPropertySource(propertySource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Ignoring @PropertySource annotation on [&quot;</span> + sourceClass.getMetadata().getClassName() +</span><br><span class="line">                    <span class="string">&quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>IDEA</code> 查看 <code>AnnotationAttributes</code>：</p>
<div style="width:70%;margin:auto"><img src="/2023/12/07/use-and-analysis-of-PropertySource-annotation-in-Spring/Snipaste_2023-12-07_21-12-20.png" class="" title="IDEA 查看 AnnotationAttributes"></div>

<h3 id="处理-PropertySource-注解属性"><a href="#处理-PropertySource-注解属性" class="headerlink" title="处理 @PropertySource 注解属性"></a>处理 @PropertySource 注解属性</h3><ul>
<li>读取 <code>@PropertySource</code> 注解属性的信息，如名称、编码和位置等等</li>
<li>遍历 <code>location</code> 查找资源</li>
<li>通过 <code>PropertySourceFactory</code> 使用资源创建属性源 <code>PropertySource</code></li>
<li>将属性源添加到 <code>Environment</code></li>
</ul>
<blockquote>
<p>注意属性源 <code>PropertySource</code> 不是 <code>@PropertySource</code> 注解，而是表示 <code>name/value</code> 属性对的源的抽象基类。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processPropertySource</span><span class="params">(AnnotationAttributes propertySource)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 属性源的 name，大部分时候不指定</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> propertySource.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasLength(name)) &#123;</span><br><span class="line">        name = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">encoding</span> <span class="operator">=</span> propertySource.getString(<span class="string">&quot;encoding&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasLength(encoding)) &#123;</span><br><span class="line">        encoding = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 位置</span></span><br><span class="line">    String[] locations = propertySource.getStringArray(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">    Assert.isTrue(locations.length &gt; <span class="number">0</span>, <span class="string">&quot;At least one @PropertySource(value) location is required&quot;</span>);</span><br><span class="line">    <span class="comment">// 找不到资源时是否忽略，默认 false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">ignoreResourceNotFound</span> <span class="operator">=</span> propertySource.getBoolean(<span class="string">&quot;ignoreResourceNotFound&quot;</span>);</span><br><span class="line">    <span class="comment">// 属性源工厂，默认 DefaultPropertySourceFactory</span></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">PropertySourceFactory</span>&gt; factoryClass = propertySource.getClass(<span class="string">&quot;factory&quot;</span>);</span><br><span class="line">    <span class="type">PropertySourceFactory</span> <span class="variable">factory</span> <span class="operator">=</span> (factoryClass == PropertySourceFactory.class ?</span><br><span class="line">            DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass));</span><br><span class="line">    <span class="comment">// 遍历位置</span></span><br><span class="line">    <span class="keyword">for</span> (String location : locations) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 解析位置，这代表 location 也可以使用占位符</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">resolvedLocation</span> <span class="operator">=</span> <span class="built_in">this</span>.environment.resolveRequiredPlaceholders(location);</span><br><span class="line">            <span class="comment">// 查找资源</span></span><br><span class="line">            <span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="built_in">this</span>.resourceLoader.getResource(resolvedLocation);</span><br><span class="line">            <span class="comment">// 创建属性源，并添加到 Environment</span></span><br><span class="line">            addPropertySource(factory.createPropertySource(name, <span class="keyword">new</span> <span class="title class_">EncodedResource</span>(resource, encoding)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">            <span class="comment">// Placeholders not resolvable</span></span><br><span class="line">            <span class="keyword">if</span> (ignoreResourceNotFound) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(<span class="string">&quot;Properties location [&quot;</span> + location + <span class="string">&quot;] not resolvable: &quot;</span> + ex.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="comment">// Resource not found when trying to open it</span></span><br><span class="line">            <span class="keyword">if</span> (ignoreResourceNotFound &amp;&amp;</span><br><span class="line">                    (ex <span class="keyword">instanceof</span> FileNotFoundException || ex <span class="keyword">instanceof</span> UnknownHostException)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(<span class="string">&quot;Properties location [&quot;</span> + location + <span class="string">&quot;] not resolvable: &quot;</span> + ex.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加属性源到-Environment"><a href="#添加属性源到-Environment" class="headerlink" title="添加属性源到 Environment"></a>添加属性源到 Environment</h3><p>将属性源添加到 <code>Environment</code> 中有以下几个规则：</p>
<ul>
<li>所有通过 <code>@PropertySource</code> 注解加入的属性源，<code>name</code> 都会添加到 <code>propertySourceNames</code></li>
<li><code>propertySourceNames</code> 为空时，代表这是第一个通过 <code>@PropertySource</code> 注解加入的属性源，添加到最后（前面有系统属性源）</li>
<li><code>propertySourceNames</code> 不为空时，添加到上一个添加到 <code>propertySourceNames</code> 中的属性源的前面（后来居上）</li>
<li>添加到 <code>propertySources</code> 的方法中都是先尝试移除，后添加（代表可能有顺序调整，具体场景不知）</li>
<li>如果已存在通过 <code>@PropertySource</code> 注解加入的属性源，则扩展为 <code>CompositePropertySource</code>，里面包含多个同名属性源（后来居上）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addPropertySource</span><span class="params">(PropertySource&lt;?&gt; propertySource)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> propertySource.getName();</span><br><span class="line">    <span class="comment">// 从 Environment 中取出 MutablePropertySources</span></span><br><span class="line">    <span class="type">MutablePropertySources</span> <span class="variable">propertySources</span> <span class="operator">=</span> ((ConfigurableEnvironment) <span class="built_in">this</span>.environment).getPropertySources();</span><br><span class="line">    <span class="comment">// 检查环境中是否已存在该属性源并且 propertySourceNames 中不存在</span></span><br><span class="line">    <span class="keyword">if</span> (propertySources.contains(name) &amp;&amp; <span class="built_in">this</span>.propertySourceNames.contains(name)) &#123;</span><br><span class="line">        <span class="comment">// 如果已经添加过，则扩展</span></span><br><span class="line">        PropertySource&lt;?&gt; existing = propertySources.get(name);</span><br><span class="line">        PropertySource&lt;?&gt; newSource = (propertySource <span class="keyword">instanceof</span> ResourcePropertySource ?</span><br><span class="line">                ((ResourcePropertySource) propertySource).withResourceName() : propertySource);</span><br><span class="line">        <span class="keyword">if</span> (existing <span class="keyword">instanceof</span> CompositePropertySource) &#123;</span><br><span class="line">            <span class="comment">// 如果已经扩展过，添加（addFirst）</span></span><br><span class="line">            ((CompositePropertySource) existing).addFirstPropertySource(newSource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 第一次扩展，替换为 CompositePropertySource</span></span><br><span class="line">            <span class="keyword">if</span> (existing <span class="keyword">instanceof</span> ResourcePropertySource) &#123;</span><br><span class="line">                existing = ((ResourcePropertySource) existing).withResourceName();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">CompositePropertySource</span> <span class="variable">composite</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CompositePropertySource</span>(name);</span><br><span class="line">            composite.addPropertySource(newSource);</span><br><span class="line">            composite.addPropertySource(existing);</span><br><span class="line">            propertySources.replace(name, composite);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 propertySourceNames 为空，添加到最后</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.propertySourceNames.isEmpty()) &#123;</span><br><span class="line">            propertySources.addLast(propertySource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 propertySourceNames 不为空，添加到上一次添加的属性源的前面</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">firstProcessed</span> <span class="operator">=</span> <span class="built_in">this</span>.propertySourceNames.get(<span class="built_in">this</span>.propertySourceNames.size() - <span class="number">1</span>);</span><br><span class="line">            propertySources.addBefore(firstProcessed, propertySource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加到 propertySourceNames</span></span><br><span class="line">    <span class="built_in">this</span>.propertySourceNames.add(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以适当地将添加属性源和使用属性分开看待，<code>Environment</code> 是它们产生联系的枢纽，<code>@PropertySource</code> 注解的处理过程是 <code>@Configuration</code> 注解的处理过程的一部分，在文件中的配置转换成为 <code>Environment</code> 中的 <code>PropertySource</code> 后，如何使用它们是独立的一件事情。</p>
<div style="width:70%;margin:auto"><img src="/2023/12/07/use-and-analysis-of-PropertySource-annotation-in-Spring/Snipaste_2023-12-07_22-49-22.png" class="" title="Environment 中的 MutablePropertySources"></div>

<p>关于搭配使用的 <code>@Value</code> 注解是如何工作的，可以参考文章：</p>
<ul>
<li><ul>
<li><a href="/2023/12/08/source-code-analysis-of-AutowiredAnnotationBeanPostProcessor-in-Spring/" title="Spring AutowiredAnnotationBeanPostProcessor 的源码分析">Spring AutowiredAnnotationBeanPostProcessor 的源码分析</a></li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring AutowiredAnnotationBeanPostProcessor 的源码分析</title>
    <url>/2023/12/08/source-code-analysis-of-AutowiredAnnotationBeanPostProcessor-in-Spring/</url>
    <content><![CDATA[<p>在 <code>Spring</code> 中，<code>AutowiredAnnotationBeanPostProcessor</code> 是一个非常重要的后处理器，它可以自动装配标注注解的字段和方法，默认使用 <code>@Autowired</code> 和 <code>@Value</code> 注解，可以支持 <code>JSR-330</code> 的 <code>@Inject</code> 注解。本文通过分析源码介绍它的调用时机和工作原理。</p>
<span id="more"></span>

<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><code>AutowiredAnnotationBeanPostProcessor</code> 顾名思义，是自动装配注解的 <code>BeanPostProcessor</code>，但是它处理的不仅仅是 <code>@Autowired</code> 这一个注解。个人认为 <code>Autowired Annotation</code> 的意思更接近“用于标注<strong>目标</strong>是<strong>被自动装配</strong>的<strong>注解</strong>”。使用“目标”是为了表达注解标注的目标不仅仅限于字段，更是包括构造函数、方法、方法参数以及注解；使用“被自动装配”是为了表达注解描述的是目标的特征或者被处理的结果，体现出被动的语义更准确；使用“注解”是为了表达注解的种类不仅仅限于 <code>@Autowired</code>，还包括 <code>@Value</code> 和 <code>@Inject</code>，它们都指示目标需要被自动装配处理。</p>
<p>通过 <code>AutowiredAnnotationBeanPostProcessor</code> 的构造函数可以看到 <code>@Inject</code> 注解的特别之处，为了使用它，需要在 <code>Maven</code> 配置中额外引入 <code>javax.inject</code> 依赖。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AutowiredAnnotationBeanPostProcessor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.autowiredAnnotationTypes.add(Autowired.class);</span><br><span class="line">    <span class="built_in">this</span>.autowiredAnnotationTypes.add(Value.class);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.autowiredAnnotationTypes.add((Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;)</span><br><span class="line">                ClassUtils.forName(<span class="string">&quot;javax.inject.Inject&quot;</span>, AutowiredAnnotationBeanPostProcessor.class.getClassLoader()));</span><br><span class="line">        logger.info(<span class="string">&quot;JSR-330 &#x27;javax.inject.Inject&#x27; annotation found and supported for autowiring&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="comment">// JSR-330 API not available - simply skip.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="入口：populateBean-方法"><a href="#入口：populateBean-方法" class="headerlink" title="入口：populateBean 方法"></a>入口：<code>populateBean</code> 方法</h3><p>我们在<a href="/2023/08/10/how-does-Spring-load-beans/" title="Spring Bean 加载过程">Spring Bean 加载过程</a>中介绍过<strong>为 <code>bean</code> 填充属性值</strong>发生在 <code>populateBean</code> 方法中。我们也将直接从这里开始跟踪代码的处理过程。</p>
<blockquote>
<p>个人认为宽松地讲，“填充属性”等于“注入属性”等于“自动装配”，前两者更侧重处理的结果，后者更侧重过程的特征，但请注意在具体的代码上下文中应辨析区别。例如为 <code>bean</code> 填充属性是 <code>Spring</code> 的重要目标之一，基于 <code>Autowired Annotation</code> 进行自动装配某一个后处理器的功能，是 <code>Spring</code> 实现目标的其中一个具体方式。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, BeanWrapper bw)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 如果存在 InstantiationAwareBeanPostProcessor 或者需要检查依赖</span></span><br><span class="line">    <span class="keyword">if</span> (hasInstAwareBpps || needsDepCheck) &#123;</span><br><span class="line">        PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">        <span class="comment">// 如果存在 InstantiationAwareBeanPostProcessor </span></span><br><span class="line">        <span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">            <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                    <span class="comment">// AutowiredAnnotationBeanPostProcessor 实现了 InstantiationAwareBeanPostProcessor 接口</span></span><br><span class="line">                    <span class="type">InstantiationAwareBeanPostProcessor</span> <span class="variable">ibp</span> <span class="operator">=</span> (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                    <span class="comment">// 调用 postProcessPropertyValues 方法</span></span><br><span class="line">                    pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">                    <span class="keyword">if</span> (pvs == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">            checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有时候在 <code>Spring</code> 中看到 <code>BeanPostProcessor</code> 并不能代表将目光转向该接口的方法实现。不同 <code>BeanPostProcessor</code> 的子接口存在不同的调用时机。<code>AutowiredAnnotationBeanPostProcessor</code> 间接实现了 <code>InstantiationAwareBeanPostProcessor</code> 并直接实现了 <code>MergedBeanDefinitionPostProcessor</code>，这是我们今天要关注的两个重点接口。</p>
</blockquote>
<p><strong><code>AutowiredAnnotationBeanPostProcessor</code> 是什么时候注册的呢？</strong></p>
<p>以 <code>AnnotationConfigApplicationContext</code> 为例，它在构造函数中创建了 <code>AnnotatedBeanDefinitionReader</code>，<code>AnnotatedBeanDefinitionReader</code> 又在构造函数中注册了基于注解配置的处理器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="built_in">this</span>.registry);</span><br></pre></td></tr></table></figure>

<p>其中就包括 <code>AutowiredAnnotationBeanPostProcessor</code>。</p>
<h3 id="后处理-PropertyValues"><a href="#后处理-PropertyValues" class="headerlink" title="后处理 PropertyValues"></a>后处理 PropertyValues</h3><p><code>AutowiredAnnotationBeanPostProcessor</code> 实现了 <code>InstantiationAwareBeanPostProcessor</code> 接口，该接口关注 <code>bean</code> 的实例化：</p>
<ul>
<li><code>postProcessBeforeInstantiation</code>（实例化前）</li>
<li><code>postProcessAfterInstantiation</code>（实例化后）</li>
<li><code>postProcessPropertyValues</code>（实例化后）</li>
</ul>
<blockquote>
<p><code>postProcessPropertyValues</code> 方法在工厂将给定属性值应用到给定 <code>bean</code> 之前对给定属性值进行后处理。允许检查是否满足所有依赖关系，例如基于 <code>bean</code> 属性 <code>setters</code> 上的 <code>@Required</code> 注解进行检查。还允许替换要应用的属性值，通常是通过基于原始 <code>PropertyValues</code> 创建新的 <code>MutablePropertyValues</code> 实例，并添加或删除特定值。</p>
</blockquote>
<p><code>postProcessPropertyValues</code> 方法做了两件事情：</p>
<ul>
<li>查找需要自动装配的元数据</li>
<li>注入</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PropertyValues <span class="title function_">postProcessPropertyValues</span><span class="params">(</span></span><br><span class="line"><span class="params">        PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line">    <span class="comment">// 查找自动装配元数据</span></span><br><span class="line">    <span class="type">InjectionMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> findAutowiringMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 注入</span></span><br><span class="line">        metadata.inject(bean, beanName, pvs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName, <span class="string">&quot;Injection of autowired dependencies failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查找自动装配元数据"><a href="#查找自动装配元数据" class="headerlink" title="查找自动装配元数据"></a>查找自动装配元数据</h3><blockquote>
<p>这部分代码体现了注入（Injection）和自动装配（Autowiring）的等价性。<code>InjectionMetadata</code> 和 <code>AutowiringMetadata</code> 的含义是用于注入（自动装配）的元数据。</p>
</blockquote>
<p><code>InjectionMetadata</code> 是用于管理注入元数据的内部类，不适合直接在应用程序中使用。它和 <code>Class</code> 是一对一的关系，封装了需要<strong>被注入</strong>的元素 <code>InjectedElement</code>。一个 <code>InjectedElement</code> 对应着一个字段（<code>Field</code>）或一个方法（<code>Method</code>），分别对应着两个实现类 <code>AutowiredFieldElement</code> 和 <code>AutowiredMethodElement</code>。这里再次体现了<strong>被注入、被自动装配</strong>的语义。</p>
<p>查找自动装配元数据的过程如下：</p>
<ul>
<li>先从缓存中获取，如果存在且不需要刷新，则直接返回结果</li>
<li>否则构建自动装配元数据并放入缓存</li>
</ul>
<blockquote>
<p>注意：在 <code>postProcessPropertyValues</code> 第一次调用 <code>findAutowiringMetadata</code> 缓存中就已经有结果了。什么时候构建并存入缓存的呢？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> InjectionMetadata <span class="title function_">findAutowiringMetadata</span><span class="params">(String beanName, Class&lt;?&gt; clazz, PropertyValues pvs)</span> &#123;</span><br><span class="line">    <span class="comment">// 缓存 key，如果没有指定退化为使用全限定类名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">cacheKey</span> <span class="operator">=</span> (StringUtils.hasLength(beanName) ? beanName : clazz.getName());</span><br><span class="line">    <span class="comment">// 双重检查</span></span><br><span class="line">    <span class="comment">// 先从缓存中获取</span></span><br><span class="line">    <span class="type">InjectionMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> <span class="built_in">this</span>.injectionMetadataCache.get(cacheKey);</span><br><span class="line">    <span class="comment">// 检测是否需要刷新</span></span><br><span class="line">    <span class="keyword">if</span> (InjectionMetadata.needsRefresh(metadata, clazz)) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>.injectionMetadataCache) &#123;</span><br><span class="line">            metadata = <span class="built_in">this</span>.injectionMetadataCache.get(cacheKey);</span><br><span class="line">            <span class="keyword">if</span> (InjectionMetadata.needsRefresh(metadata, clazz)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (metadata != <span class="literal">null</span>) &#123;</span><br><span class="line">                    metadata.clear(pvs);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 构建自动装配元数据</span></span><br><span class="line">                    metadata = buildAutowiringMetadata(clazz);</span><br><span class="line">                    <span class="comment">// 放入缓存</span></span><br><span class="line">                    <span class="built_in">this</span>.injectionMetadataCache.put(cacheKey, metadata);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (NoClassDefFoundError err) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Failed to introspect bean class [&quot;</span> + clazz.getName() +</span><br><span class="line">                            <span class="string">&quot;] for autowiring metadata: could not find class that it depends on&quot;</span>, err);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> metadata;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">needsRefresh</span><span class="params">(InjectionMetadata metadata, Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">    <span class="comment">// metadata.targetClass != clazz 的场景是什么？</span></span><br><span class="line">    <span class="keyword">return</span> (metadata == <span class="literal">null</span> || metadata.targetClass != clazz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="构建自动装配元数据"><a href="#构建自动装配元数据" class="headerlink" title="构建自动装配元数据"></a>构建自动装配元数据</h4><p>构建自动装配元数据只需要给定一个 <code>Class</code>，沿着给定的 <code>Class</code> 的父类向上循环查找直到 <code>Object</code> 类。在每个循环中，先遍历当前类声明的所有属性，找到标注了自动装配注解的属性，为其创建 <code>AutowiredFieldElement</code> 并添加到临时集合，再遍历当前类声明的所有方法，找到标注了自动装配注解的方法，为其创建 <code>AutowiredMethodElement</code> 并添加到临时集合。最后汇总 <code>InjectedElement</code> 封装到 <code>InjectionMetadata</code> 中。</p>
<blockquote>
<p>这个处理顺序意味着在注入时方法的优先级高于字段，前者会覆盖后者。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> InjectionMetadata <span class="title function_">buildAutowiringMetadata</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">    LinkedList&lt;InjectionMetadata.InjectedElement&gt; elements = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;InjectionMetadata.InjectedElement&gt;();</span><br><span class="line">    Class&lt;?&gt; targetClass = clazz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> LinkedList&lt;InjectionMetadata.InjectedElement&gt; currElements =</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;InjectionMetadata.InjectedElement&gt;();</span><br><span class="line">        <span class="comment">// 处理字段 Field -&gt; AutowiredFieldElement</span></span><br><span class="line">        ReflectionUtils.doWithLocalFields(targetClass, <span class="keyword">new</span> <span class="title class_">ReflectionUtils</span>.FieldCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWith</span><span class="params">(Field field)</span> <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException &#123;</span><br><span class="line">                <span class="comment">// 查找表示需被自动装配的注解：@Autowired、@Value、@Inject（可选）</span></span><br><span class="line">                <span class="type">AnnotationAttributes</span> <span class="variable">ann</span> <span class="operator">=</span> findAutowiredAnnotation(field);</span><br><span class="line">                <span class="keyword">if</span> (ann != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (Modifier.isStatic(field.getModifiers())) &#123;</span><br><span class="line">                        <span class="comment">// 不支持静态字段</span></span><br><span class="line">                        <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                            logger.warn(<span class="string">&quot;Autowired annotation is not supported on static fields: &quot;</span> + field);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 确定 required</span></span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">required</span> <span class="operator">=</span> determineRequiredStatus(ann);</span><br><span class="line">                    <span class="comment">// 根据 field 和 required 创建 AutowiredFieldElement 并添加</span></span><br><span class="line">                    currElements.add(<span class="keyword">new</span> <span class="title class_">AutowiredFieldElement</span>(field, required));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 处理方法 Method -&gt; AutowiredMethodElement</span></span><br><span class="line">        ReflectionUtils.doWithLocalMethods(targetClass, <span class="keyword">new</span> <span class="title class_">ReflectionUtils</span>.MethodCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWith</span><span class="params">(Method method)</span> <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException &#123;</span><br><span class="line">                <span class="type">Method</span> <span class="variable">bridgedMethod</span> <span class="operator">=</span> BridgeMethodResolver.findBridgedMethod(method);</span><br><span class="line">                <span class="keyword">if</span> (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 查找表示需被自动装配的注解：@Autowired、@Value、@Inject（可选）</span></span><br><span class="line">                <span class="type">AnnotationAttributes</span> <span class="variable">ann</span> <span class="operator">=</span> findAutowiredAnnotation(bridgedMethod);</span><br><span class="line">                <span class="keyword">if</span> (ann != <span class="literal">null</span> &amp;&amp; method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (Modifier.isStatic(method.getModifiers())) &#123;</span><br><span class="line">                        <span class="comment">// 不支持静态方法</span></span><br><span class="line">                        <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                            logger.warn(<span class="string">&quot;Autowired annotation is not supported on static methods: &quot;</span> + method);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (method.getParameterTypes().length == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 不支持无参数的方法</span></span><br><span class="line">                        <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                            logger.warn(<span class="string">&quot;Autowired annotation should only be used on methods with parameters: &quot;</span> +</span><br><span class="line">                                    method);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 确定 required</span></span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">required</span> <span class="operator">=</span> determineRequiredStatus(ann);</span><br><span class="line">                    <span class="type">PropertyDescriptor</span> <span class="variable">pd</span> <span class="operator">=</span> BeanUtils.findPropertyForMethod(bridgedMethod, clazz);</span><br><span class="line">                    <span class="comment">// 创建 AutowiredMethodElement 并添加</span></span><br><span class="line">                    currElements.add(<span class="keyword">new</span> <span class="title class_">AutowiredMethodElement</span>(method, required, pd));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        elements.addAll(<span class="number">0</span>, currElements);</span><br><span class="line">        <span class="comment">// 向父类继续查找</span></span><br><span class="line">        targetClass = targetClass.getSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (targetClass != <span class="literal">null</span> &amp;&amp; targetClass != Object.class);</span><br><span class="line">    <span class="comment">// 封装为 InjectionMetadata 返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InjectionMetadata</span>(clazz, elements);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h3><p>对于字段来说，注入意味着将一个解析得到的 <code>value</code> 通过反射设置到字段中；对于方法来说，注入意味着解析得到方法参数的 <code>value</code>，然后通过反射调用方法。</p>
<p><code>InjectionMetadata</code> 的 <code>inject</code> 方法比较简单，内部会遍历并调用 <code>InjectedElement</code> 的 <code>inject</code> 方法，<code>AutowiredFieldElement</code> 和 <code>AutowiredMethodElement</code> 各自实现了 <code>inject</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inject</span><span class="params">(Object target, String beanName, PropertyValues pvs)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    Collection&lt;InjectedElement&gt; elementsToIterate =</span><br><span class="line">            (<span class="built_in">this</span>.checkedElements != <span class="literal">null</span> ? <span class="built_in">this</span>.checkedElements : <span class="built_in">this</span>.injectedElements);</span><br><span class="line">    <span class="keyword">if</span> (!elementsToIterate.isEmpty()) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">debug</span> <span class="operator">=</span> logger.isDebugEnabled();</span><br><span class="line">        <span class="comment">// 遍历（InjectedElement 包装的可能是字段，也可能是方法）</span></span><br><span class="line">        <span class="keyword">for</span> (InjectedElement element : elementsToIterate) &#123;</span><br><span class="line">            <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Processing injected element of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;: &quot;</span> + element);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 注入</span></span><br><span class="line">            element.inject(target, beanName, pvs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不论是 <code>AutowiredFieldElement</code> 还是 <code>AutowiredMethodElement</code>，<code>inject</code> 的过程都比较相似：</p>
<ul>
<li>都使用 <code>DependencyDescriptor</code> 描述即将被注入的特定依赖项，<code>DependencyDescriptor</code> 包装了构造函数参数、方法参数或者字段，允许以统一的方式访问它们的元数据</li>
<li>都会缓存 <code>DependencyDescriptor</code></li>
<li>都会记录自动装配的 <code>bean</code>，用于判断是否使用 <code>DependencyDescriptor</code> 的变体 <code>ShortcutDependencyDescriptor</code> 优化缓存</li>
<li>都通过 <code>beanFactory.resolveDependency</code> 解析依赖</li>
</ul>
<h4 id="字段注入"><a href="#字段注入" class="headerlink" title="字段注入"></a>字段注入</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">AutowiredFieldElement</span> <span class="keyword">extends</span> <span class="title class_">InjectionMetadata</span>.InjectedElement &#123;</span><br><span class="line">    <span class="comment">// 是否必须</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> required;</span><br><span class="line">    <span class="comment">// 是否已缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">cached</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// Field 依赖描述符的缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Object cachedFieldValue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AutowiredFieldElement</span><span class="params">(Field field, <span class="type">boolean</span> required)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(field, <span class="literal">null</span>);</span><br><span class="line">        <span class="built_in">this</span>.required = required;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">inject</span><span class="params">(Object bean, String beanName, PropertyValues pvs)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 获取要注入的目标（Field 对象）</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> (Field) <span class="built_in">this</span>.member;</span><br><span class="line">        <span class="comment">// value</span></span><br><span class="line">        Object value;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.cached) &#123;</span><br><span class="line">            <span class="comment">// 如果已缓存，解析已缓存的参数</span></span><br><span class="line">            value = resolvedCachedArgument(beanName, <span class="built_in">this</span>.cachedFieldValue);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 创建依赖描述符</span></span><br><span class="line">            <span class="type">DependencyDescriptor</span> <span class="variable">desc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(field, <span class="built_in">this</span>.required);</span><br><span class="line">            desc.setContainingClass(bean.getClass());</span><br><span class="line">            Set&lt;String&gt; autowiredBeanNames = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;String&gt;(<span class="number">1</span>);</span><br><span class="line">            <span class="type">TypeConverter</span> <span class="variable">typeConverter</span> <span class="operator">=</span> beanFactory.getTypeConverter();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 通过 beanFactory 解析依赖得到 value</span></span><br><span class="line">                value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsatisfiedDependencyException</span>(<span class="literal">null</span>, beanName, <span class="keyword">new</span> <span class="title class_">InjectionPoint</span>(field), ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果未缓存，则缓存</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">this</span>.cached) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (value != <span class="literal">null</span> || <span class="built_in">this</span>.required) &#123;</span><br><span class="line">                        <span class="comment">// 缓存 DependencyDescriptor</span></span><br><span class="line">                        <span class="built_in">this</span>.cachedFieldValue = desc;</span><br><span class="line">                        <span class="comment">// 注册依赖关系，用于控制销毁顺序</span></span><br><span class="line">                        registerDependentBeans(beanName, autowiredBeanNames);</span><br><span class="line">                        <span class="comment">// 如果自动装配的 bean 刚好只有一个</span></span><br><span class="line">                        <span class="keyword">if</span> (autowiredBeanNames.size() == <span class="number">1</span>) &#123;</span><br><span class="line">                            <span class="type">String</span> <span class="variable">autowiredBeanName</span> <span class="operator">=</span> autowiredBeanNames.iterator().next();</span><br><span class="line">                            <span class="comment">// 检测工厂里存在 bean</span></span><br><span class="line">                            <span class="keyword">if</span> (beanFactory.containsBean(autowiredBeanName)) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (beanFactory.isTypeMatch(autowiredBeanName, field.getType())) &#123;</span><br><span class="line">                                    <span class="comment">// 替换为具有预先解析的目标 bean 名称的 DependencyDescriptor 变体</span></span><br><span class="line">                                    <span class="built_in">this</span>.cachedFieldValue = <span class="keyword">new</span> <span class="title class_">ShortcutDependencyDescriptor</span>(</span><br><span class="line">                                            desc, autowiredBeanName, field.getType());</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">this</span>.cachedFieldValue = <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">this</span>.cached = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 最后，通过反射将 value 设置到 field</span></span><br><span class="line">            ReflectionUtils.makeAccessible(field);</span><br><span class="line">            field.set(bean, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法注入"><a href="#方法注入" class="headerlink" title="方法注入"></a>方法注入</h4><blockquote>
<p>不理解缓存 <code>DependencyDescriptor</code> 代码上的注释：Shortcut for avoiding synchronization…</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">AutowiredMethodElement</span> <span class="keyword">extends</span> <span class="title class_">InjectionMetadata</span>.InjectedElement &#123;</span><br><span class="line">    <span class="comment">// 是否必须</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> required;</span><br><span class="line">    <span class="comment">// 是否已缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">cached</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// Method 参数依赖描述符的缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Object[] cachedMethodArguments;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AutowiredMethodElement</span><span class="params">(Method method, <span class="type">boolean</span> required, PropertyDescriptor pd)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(method, pd);</span><br><span class="line">        <span class="built_in">this</span>.required = required;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">inject</span><span class="params">(Object bean, String beanName, PropertyValues pvs)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">if</span> (checkPropertySkipping(pvs)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取要注入的目标（Method）</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> (Method) <span class="built_in">this</span>.member;</span><br><span class="line">        <span class="comment">// 方法的参数</span></span><br><span class="line">        Object[] arguments;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.cached) &#123;</span><br><span class="line">            <span class="comment">// Shortcut for avoiding synchronization...</span></span><br><span class="line">            <span class="comment">// 不理解这个注释</span></span><br><span class="line">            arguments = resolveCachedArguments(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取方法的参数类型数组</span></span><br><span class="line">            Class&lt;?&gt;[] paramTypes = method.getParameterTypes();</span><br><span class="line">            arguments = <span class="keyword">new</span> <span class="title class_">Object</span>[paramTypes.length];</span><br><span class="line">            DependencyDescriptor[] descriptors = <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>[paramTypes.length];</span><br><span class="line">            Set&lt;String&gt; autowiredBeans = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;String&gt;(paramTypes.length);</span><br><span class="line">            <span class="type">TypeConverter</span> <span class="variable">typeConverter</span> <span class="operator">=</span> beanFactory.getTypeConverter();</span><br><span class="line">            <span class="comment">// 遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arguments.length; i++) &#123;</span><br><span class="line">                <span class="type">MethodParameter</span> <span class="variable">methodParam</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodParameter</span>(method, i);</span><br><span class="line">                <span class="comment">// 为每个方法参数创建依赖描述符</span></span><br><span class="line">                <span class="type">DependencyDescriptor</span> <span class="variable">currDesc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(methodParam, <span class="built_in">this</span>.required);</span><br><span class="line">                currDesc.setContainingClass(bean.getClass());</span><br><span class="line">                descriptors[i] = currDesc;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 通过 beanFactory 解析依赖得到 value</span></span><br><span class="line">                    <span class="type">Object</span> <span class="variable">arg</span> <span class="operator">=</span> beanFactory.resolveDependency(currDesc, beanName, autowiredBeans, typeConverter);</span><br><span class="line">                    <span class="keyword">if</span> (arg == <span class="literal">null</span> &amp;&amp; !<span class="built_in">this</span>.required) &#123;</span><br><span class="line">                        arguments = <span class="literal">null</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 赋值</span></span><br><span class="line">                    arguments[i] = arg;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsatisfiedDependencyException</span>(<span class="literal">null</span>, beanName, <span class="keyword">new</span> <span class="title class_">InjectionPoint</span>(methodParam), ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果未缓存，则缓存</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">this</span>.cached) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (arguments != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="built_in">this</span>.cachedMethodArguments = <span class="keyword">new</span> <span class="title class_">Object</span>[paramTypes.length];</span><br><span class="line">                        <span class="comment">// 缓存 DependencyDescriptor</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arguments.length; i++) &#123;</span><br><span class="line">                            <span class="built_in">this</span>.cachedMethodArguments[i] = descriptors[i];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 注册依赖关系</span></span><br><span class="line">                        registerDependentBeans(beanName, autowiredBeans);</span><br><span class="line">                        <span class="comment">// 如果自动装配的 bean 数量等于参数的数量</span></span><br><span class="line">                        <span class="keyword">if</span> (autowiredBeans.size() == paramTypes.length) &#123;</span><br><span class="line">                            Iterator&lt;String&gt; it = autowiredBeans.iterator();</span><br><span class="line">                            <span class="comment">// 遍历</span></span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; paramTypes.length; i++) &#123;</span><br><span class="line">                                <span class="type">String</span> <span class="variable">autowiredBeanName</span> <span class="operator">=</span> it.next();</span><br><span class="line">                                <span class="comment">// 检测工厂里存在 bean</span></span><br><span class="line">                                <span class="keyword">if</span> (beanFactory.containsBean(autowiredBeanName)) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (beanFactory.isTypeMatch(autowiredBeanName, paramTypes[i])) &#123;</span><br><span class="line">                                        <span class="comment">// 替换为具有预先解析的目标 bean 名称的 DependencyDescriptor 变体</span></span><br><span class="line">                                        <span class="built_in">this</span>.cachedMethodArguments[i] = <span class="keyword">new</span> <span class="title class_">ShortcutDependencyDescriptor</span>(</span><br><span class="line">                                                descriptors[i], autowiredBeanName, paramTypes[i]);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">this</span>.cachedMethodArguments = <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">this</span>.cached = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arguments != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 通过反射调用方法</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ReflectionUtils.makeAccessible(method);</span><br><span class="line">                method.invoke(bean, arguments);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (InvocationTargetException ex)&#123;</span><br><span class="line">                <span class="keyword">throw</span> ex.getTargetException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object[] resolveCachedArguments(String beanName) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.cachedMethodArguments == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Object[] arguments = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="built_in">this</span>.cachedMethodArguments.length];</span><br><span class="line">        <span class="comment">// 遍历已缓存的方法参数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arguments.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 解析已缓存的参数</span></span><br><span class="line">            arguments[i] = resolvedCachedArgument(beanName, <span class="built_in">this</span>.cachedMethodArguments[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arguments;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解析已缓存的方法参数或字段"><a href="#解析已缓存的方法参数或字段" class="headerlink" title="解析已缓存的方法参数或字段"></a>解析已缓存的方法参数或字段</h4><blockquote>
<p>为什么在这里 <code>beanFactory.resolveDependency</code> 需要的参数和未缓存时不一样啊？虽然内部会通过相同的方式获得 <code>typeConverter</code>，但是很奇怪啊。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">resolvedCachedArgument</span><span class="params">(String beanName, Object cachedArgument)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cachedArgument <span class="keyword">instanceof</span> DependencyDescriptor) &#123;</span><br><span class="line">        <span class="type">DependencyDescriptor</span> <span class="variable">descriptor</span> <span class="operator">=</span> (DependencyDescriptor) cachedArgument;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.beanFactory.resolveDependency(descriptor, beanName, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cachedArgument;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解析依赖"><a href="#解析依赖" class="headerlink" title="解析依赖"></a>解析依赖</h3><p>解析依赖的过程暂不深入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">resolveDependency</span><span class="params">(DependencyDescriptor descriptor, String requestingBeanName,</span></span><br><span class="line"><span class="params">        Set&lt;String&gt; autowiredBeanNames, TypeConverter typeConverter)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">    descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());</span><br><span class="line">    <span class="keyword">if</span> (javaUtilOptionalClass == descriptor.getDependencyType()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OptionalDependencyFactory</span>().createOptionalDependency(descriptor, requestingBeanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ObjectFactory.class == descriptor.getDependencyType() ||</span><br><span class="line">            ObjectProvider.class == descriptor.getDependencyType()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DependencyObjectProvider</span>(descriptor, requestingBeanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (javaxInjectProviderClass == descriptor.getDependencyType()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jsr330ProviderFactory</span>().createDependencyProvider(descriptor, requestingBeanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果依赖是懒加载，创建一个代理对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(</span><br><span class="line">                descriptor, requestingBeanName);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 一般情况</span></span><br><span class="line">            result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">doResolveDependency</span><span class="params">(DependencyDescriptor descriptor, String beanName,</span></span><br><span class="line"><span class="params">        Set&lt;String&gt; autowiredBeanNames, TypeConverter typeConverter)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">InjectionPoint</span> <span class="variable">previousInjectionPoint</span> <span class="operator">=</span> ConstructorResolver.setCurrentInjectionPoint(descriptor);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">shortcut</span> <span class="operator">=</span> descriptor.resolveShortcut(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (shortcut != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> shortcut;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; type = descriptor.getDependencyType();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> getAutowireCandidateResolver().getSuggestedValue(descriptor);</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果 value 是 String 类型</span></span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                <span class="comment">// 解析给定的嵌入值，例如替换占位符 $&#123;&#125;，但不解析 SpEL 表达式</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">strVal</span> <span class="operator">=</span> resolveEmbeddedValue((String) value);</span><br><span class="line">                <span class="type">BeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> (beanName != <span class="literal">null</span> &amp;&amp; containsBean(beanName) ? getMergedBeanDefinition(beanName) : <span class="literal">null</span>);</span><br><span class="line">                <span class="comment">// 解析 SpEL 表达式</span></span><br><span class="line">                value = evaluateBeanDefinitionString(strVal, bd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">TypeConverter</span> <span class="variable">converter</span> <span class="operator">=</span> (typeConverter != <span class="literal">null</span> ? typeConverter : getTypeConverter());</span><br><span class="line">            <span class="keyword">return</span> (descriptor.getField() != <span class="literal">null</span> ?</span><br><span class="line">                    converter.convertIfNecessary(value, type, descriptor.getField()) :</span><br><span class="line">                    converter.convertIfNecessary(value, type, descriptor.getMethodParameter()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">multipleBeans</span> <span class="operator">=</span> resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);</span><br><span class="line">        <span class="keyword">if</span> (multipleBeans != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> multipleBeans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);</span><br><span class="line">        <span class="keyword">if</span> (matchingBeans.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isRequired(descriptor)) &#123;</span><br><span class="line">                raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String autowiredBeanName;</span><br><span class="line">        Object instanceCandidate;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (matchingBeans.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);</span><br><span class="line">            <span class="keyword">if</span> (autowiredBeanName == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isRequired(descriptor) || !indicatesMultipleBeans(type)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> descriptor.resolveNotUnique(type, matchingBeans);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// In case of an optional Collection/Map, silently ignore a non-unique case:</span></span><br><span class="line">                    <span class="comment">// possibly it was meant to be an empty collection of multiple regular beans</span></span><br><span class="line">                    <span class="comment">// (before 4.3 in particular when we didn&#x27;t even look for collection beans).</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            instanceCandidate = matchingBeans.get(autowiredBeanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// We have exactly one match.</span></span><br><span class="line">            Map.Entry&lt;String, Object&gt; entry = matchingBeans.entrySet().iterator().next();</span><br><span class="line">            autowiredBeanName = entry.getKey();</span><br><span class="line">            instanceCandidate = entry.getValue();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (autowiredBeanNames != <span class="literal">null</span>) &#123;</span><br><span class="line">            autowiredBeanNames.add(autowiredBeanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (instanceCandidate <span class="keyword">instanceof</span> Class ?</span><br><span class="line">                descriptor.resolveCandidate(autowiredBeanName, type, <span class="built_in">this</span>) : instanceCandidate);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        ConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构建自动装配元数据的时机"><a href="#构建自动装配元数据的时机" class="headerlink" title="构建自动装配元数据的时机"></a>构建自动装配元数据的时机</h3><p>你在 <code>Debug</code> 的时候也许会注意到，在第一次进入 <code>postProcessPropertyValues</code> 方法，查找自动装配元数据时，就已经是从缓存中获取的了。那么究竟是<strong>什么时候构建自动装配元数据并放入缓存的</strong>呢？这就需要我们目前一直没有讲到的 <code>MergedBeanDefinitionPostProcessor</code> 派上用场了。在 <code>postProcessMergedBeanDefinition</code> 方法中，也调用了 <code>findAutowiringMetadata</code> 方法，这才是真正的第一次查找自动装配元数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (beanType != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 查找自动装配元数据</span></span><br><span class="line">        <span class="type">InjectionMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> findAutowiringMetadata(beanName, beanType, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 检查配置成员</span></span><br><span class="line">        metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么 <strong><code>MergedBeanDefinitionPostProcessor</code> 又是什么时候被调用的</strong>呢？在 <code>doCreateBean</code> 方法中，创建实例后，填充属性前。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line">    <span class="comment">// 创建实例</span></span><br><span class="line">    <span class="comment">// 允许 post-processors 修改合并过的 bean definition</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">        <span class="comment">// 如果尚未被 MergedBeanDefinitionPostProcessor 应用过</span></span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 应用</span></span><br><span class="line">                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 修改为被应用过</span></span><br><span class="line">            mbd.postProcessed = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为 bean 填充属性值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="检测配置成员"><a href="#检测配置成员" class="headerlink" title="检测配置成员"></a>检测配置成员</h4><blockquote>
<p><code>configMember</code> 这个命名不太理解，指的是通过配置实现注入的 <code>Member</code> （<code>Filed</code> 和 <code>Method</code> 的父类）吗？</p>
</blockquote>
<p>检测配置成员，如果不是外部管理的配置成员，则注册为外部管理的配置成员。在合并后的 <code>bean</code> 定义中，<code>externallyManagedConfigMembers</code> 保存了外部管理的配置成员，用于标记一个配置成员是外部管理的。例如当一个字段同时标注了 <code>@Resource</code> 和 <code>@Autowired</code> 注解，当 <code>@Resouce</code> 注解被处理后，该字段已经被标记，当 <code>@Autowired</code> 注解被处理时，就会跳过该字段，避免重复注入造成冲突。</p>
<blockquote>
<p>这里的外部管理感觉有点指向依赖注入的控制反转思想。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkConfigMembers</span><span class="params">(RootBeanDefinition beanDefinition)</span> &#123;</span><br><span class="line">    Set&lt;InjectedElement&gt; checkedElements = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;InjectedElement&gt;(<span class="built_in">this</span>.injectedElements.size());</span><br><span class="line">    <span class="comment">// 遍历需要被注入的元素</span></span><br><span class="line">    <span class="keyword">for</span> (InjectedElement element : <span class="built_in">this</span>.injectedElements) &#123;</span><br><span class="line">        <span class="type">Member</span> <span class="variable">member</span> <span class="operator">=</span> element.getMember();</span><br><span class="line">        <span class="comment">// 如果不是外部管理的配置成员</span></span><br><span class="line">        <span class="keyword">if</span> (!beanDefinition.isExternallyManagedConfigMember(member)) &#123;</span><br><span class="line">            <span class="comment">// 注册为外部管理的配置成员</span></span><br><span class="line">            beanDefinition.registerExternallyManagedConfigMember(member);</span><br><span class="line">            checkedElements.add(element);</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Registered injected element on class [&quot;</span> + <span class="built_in">this</span>.targetClass.getName() + <span class="string">&quot;]: &quot;</span> + element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在 `InjectionMetadata#inject` 方法中，迭代的集合将会是它</span></span><br><span class="line">    <span class="built_in">this</span>.checkedElements = checkedElements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果不了解具体的场景，可能会比较难想象这个标记的用处是什么。</p>
</blockquote>
<blockquote>
<p>尽管 <code>@Autowired</code> 注解配合 <code>@Value</code> 注解可以很灵活，但是应尽量采取清晰明了的配置方式，让注入的结果一眼就能看出来。</p>
</blockquote>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>ConfigurationProperties 一定要搭配 EnableConfigurationProperties 使用吗</title>
    <url>/2023/12/10/is-it-necessary-to-use-ConfigurationProperties-with-EnableConfigurationProperties/</url>
    <content><![CDATA[<p><code>@ConfigurationProperties</code> 和 <code>@EnableConfigurationProperties</code> 是 <code>Spring Boot</code> 中常用的注解，提供了方便和强大的外部化配置支持。尽管它们常常一起出现，但是它们真的必须一起使用吗？<code>Spring Boot</code> 的灵活性常常让我们忽略配置背后产生的作用究竟是什么？本文将从源码角度出发分析两个注解的<strong>作用时机</strong>和<strong>工作原理</strong>。</p>
<span id="more"></span>

<ul>
<li>本文的写作动机继承自<a href="/2023/12/07/use-and-analysis-of-PropertySource-annotation-in-Spring/" title="Spring 中 @PropertySource 注解的使用和源码分析">Spring 中 @PropertySource 注解的使用和源码分析</a>，两者有点相似并且常被一起提及，都通过外部配置管理运行时的属性值，但实际的工作原理却并不相同。</li>
<li>本文没有介绍它们的使用方式，如有需要可以参考 <a href="https://www.baeldung.com/configuration-properties-in-spring-boot">Guide to @ConfigurationProperties in Spring Boot</a>。</li>
<li>理解 <code>@Import</code> 的工作原理对阅读本文的源码有非常大的帮助，可以参考<a href="/2023/12/04/use-and-analysis-of-Import-annotation-in-Spring/" title="Spring 中 @Import 注解的使用和源码分析">Spring 中 @Import 注解的使用和源码分析</a>。</li>
</ul>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p><code>ConfigurationProperties</code> 是用于<strong>外部化配置</strong>的注解。如果你想<strong>绑定</strong>和<strong>验证</strong>某些外部属性（例如来自 <code>.properties</code> 文件），就将其添加到<strong>类定义或 <code>@Configuration</code> 类中的 <code>@Bean</code> 方法</strong>。请注意，和 <code>@Value</code> 相反，<code>SpEL</code> 表达式不会被求值，因为属性值是外部化的。查看 <code>ConfigurationProperties</code> 注解的源码可知，该注解主要起到标记和存储一些信息的作用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConfigurationProperties &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可有效绑定到此对象的属性的名称前缀</span></span><br><span class="line">    <span class="meta">@AliasFor(&quot;prefix&quot;)</span></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可有效绑定到此对象的属性的名称前缀</span></span><br><span class="line">    <span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">    String <span class="title function_">prefix</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定到此对象时是否忽略无效字段</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">ignoreInvalidFields</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定到此对象时是否忽略未知字段</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">ignoreUnknownFields</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看 <code>EnableConfigurationProperties</code> 的源码，我们注意到它通过 <code>@Import</code> 导入了 <code>EnableConfigurationPropertiesImportSelector</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(EnableConfigurationPropertiesImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableConfigurationProperties &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Spring 快速注册标注了 @ConfigurationProperties 的 bean。无论 value 如何，标准的 Spring Bean 也将被扫描。</span></span><br><span class="line">    Class&lt;?&gt;[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注解的作用"><a href="#注解的作用" class="headerlink" title="注解的作用"></a>注解的作用</h2><p>查看 <code>EnableConfigurationPropertiesImportSelector</code> 的源码，关注 <code>selectImports</code> 方法。该方法返回了 <code>ConfigurationPropertiesBeanRegistrar</code> 和 <code>ConfigurationPropertiesBindingPostProcessorRegistrar</code> 的全限定类名，<code>Spring</code> 将注册它们。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EnableConfigurationPropertiesImportSelector</span> <span class="keyword">implements</span> <span class="title class_">ImportSelector</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] IMPORTS = &#123;</span><br><span class="line">            ConfigurationPropertiesBeanRegistrar.class.getName(),</span><br><span class="line">            ConfigurationPropertiesBindingPostProcessorRegistrar.class.getName() &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata metadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> IMPORTS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注册目标类"><a href="#注册目标类" class="headerlink" title="注册目标类"></a>注册目标类</h3><p><code>ConfigurationPropertiesBeanRegistrar</code> 是一个内部类，查看 <code>ConfigurationPropertiesBeanRegistrar</code> 的源码，关注 <code>registerBeanDefinitions</code> 方法。注册的目标来自于：</p>
<ul>
<li><code>@EnableConfigurationProperties</code> 的 <code>value</code> 所指定的类中</li>
<li>且标注了 <code>@ConfigurationProperties</code> 的类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ConfigurationPropertiesBeanRegistrar</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata,</span></span><br><span class="line"><span class="params">            BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 获取要注册的 Class</span></span><br><span class="line">        <span class="comment">// 2. 遍历获取的结果进行注册</span></span><br><span class="line">        getTypes(metadata).forEach((type) -&gt; register(registry,</span><br><span class="line">                (ConfigurableListableBeanFactory) registry, type));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Class&lt;?&gt;&gt; getTypes(AnnotationMetadata metadata) &#123;</span><br><span class="line">        <span class="comment">// 获取所有 @EnableConfigurationProperties 的属性</span></span><br><span class="line">        MultiValueMap&lt;String, Object&gt; attributes = metadata</span><br><span class="line">                .getAllAnnotationAttributes(</span><br><span class="line">                        EnableConfigurationProperties.class.getName(), <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 获取属性 value 的值，处理后返回</span></span><br><span class="line">        <span class="keyword">return</span> collectClasses(attributes == <span class="literal">null</span> ? Collections.emptyList()</span><br><span class="line">                : attributes.get(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 收集 Class</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Class&lt;?&gt;&gt; collectClasses(List&lt;?&gt; values) &#123;</span><br><span class="line">        <span class="keyword">return</span> values.stream().flatMap((value) -&gt; Arrays.stream((Object[]) value))</span><br><span class="line">                .map((o) -&gt; (Class&lt;?&gt;) o).filter((type) -&gt; <span class="keyword">void</span>.class != type)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册 Bean 定义</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(BeanDefinitionRegistry registry,</span></span><br><span class="line"><span class="params">            ConfigurableListableBeanFactory beanFactory, Class&lt;?&gt; type)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> getName(type);</span><br><span class="line">        <span class="comment">// 检测是否包含 Bean 定义</span></span><br><span class="line">        <span class="keyword">if</span> (!containsBeanDefinition(beanFactory, name)) &#123;</span><br><span class="line">            <span class="comment">// 如果没找到，则注册</span></span><br><span class="line">            registerBeanDefinition(registry, name, type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// beanName = prefix + 全限定类名 or 全限定类名</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getName</span><span class="params">(Class&lt;?&gt; type)</span> &#123;</span><br><span class="line">        <span class="type">ConfigurationProperties</span> <span class="variable">annotation</span> <span class="operator">=</span> AnnotationUtils.findAnnotation(type,</span><br><span class="line">                ConfigurationProperties.class);</span><br><span class="line">        <span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> (annotation != <span class="literal">null</span> ? annotation.prefix() : <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (StringUtils.hasText(prefix) ? prefix + <span class="string">&quot;-&quot;</span> + type.getName()</span><br><span class="line">                : type.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测是否包含 Bean 定义</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">containsBeanDefinition</span><span class="params">(</span></span><br><span class="line"><span class="params">            ConfigurableListableBeanFactory beanFactory, String name)</span> &#123;</span><br><span class="line">        <span class="comment">// 先检测当前工厂中是否包含</span></span><br><span class="line">        <span class="keyword">if</span> (beanFactory.containsBeanDefinition(name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没找到则检测父工厂是否包含</span></span><br><span class="line">        <span class="type">BeanFactory</span> <span class="variable">parent</span> <span class="operator">=</span> beanFactory.getParentBeanFactory();</span><br><span class="line">        <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">            <span class="keyword">return</span> containsBeanDefinition((ConfigurableListableBeanFactory) parent,</span><br><span class="line">                    name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册 Bean 定义</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinition</span><span class="params">(BeanDefinitionRegistry registry, String name,</span></span><br><span class="line"><span class="params">            Class&lt;?&gt; type)</span> &#123;</span><br><span class="line">        <span class="comment">// 断言目标类标注了 @ConfigurationProperties</span></span><br><span class="line">        assertHasAnnotation(type);</span><br><span class="line">        <span class="type">GenericBeanDefinition</span> <span class="variable">definition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericBeanDefinition</span>();</span><br><span class="line">        definition.setBeanClass(type);</span><br><span class="line">        <span class="comment">// registry 注册 Bean 定义</span></span><br><span class="line">        registry.registerBeanDefinition(name, definition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 断言目标类标注了 @ConfigurationProperties</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">assertHasAnnotation</span><span class="params">(Class&lt;?&gt; type)</span> &#123;</span><br><span class="line">        Assert.notNull(</span><br><span class="line">                AnnotationUtils.findAnnotation(type, ConfigurationProperties.class),</span><br><span class="line">                <span class="string">&quot;No &quot;</span> + ConfigurationProperties.class.getSimpleName()</span><br><span class="line">                        + <span class="string">&quot; annotation found on  &#x27;&quot;</span> + type.getName() + <span class="string">&quot;&#x27;.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注册后处理器"><a href="#注册后处理器" class="headerlink" title="注册后处理器"></a>注册后处理器</h3><p>查看 <code>ConfigurationPropertiesBindingPostProcessorRegistrar</code> 的源码，关注 <code>registerBeanDefinitions</code> 方法。该方法注册了 <code>ConfigurationPropertiesBindingPostProcessor</code> 和 <code>ConfigurationBeanFactoryMetadata</code>。</p>
<ul>
<li>前者顾名思义，用于处理 <code>ConfigurationProperties</code> 的绑定</li>
<li>后者是用于在 <code>Bean</code> 工厂初始化期间记住 <code>@Bean</code> 定义元数据的实用程序类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigurationPropertiesBindingPostProcessorRegistrar</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata,</span></span><br><span class="line"><span class="params">            BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!registry.containsBeanDefinition(</span><br><span class="line">                ConfigurationPropertiesBindingPostProcessor.BEAN_NAME)) &#123;</span><br><span class="line">            registerConfigurationPropertiesBindingPostProcessor(registry);</span><br><span class="line">            registerConfigurationBeanFactoryMetadata(registry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">registerConfigurationPropertiesBindingPostProcessor</span><span class="params">(</span></span><br><span class="line"><span class="params">            BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">        <span class="type">GenericBeanDefinition</span> <span class="variable">definition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericBeanDefinition</span>();</span><br><span class="line">        definition.setBeanClass(ConfigurationPropertiesBindingPostProcessor.class);</span><br><span class="line">        <span class="comment">// Bean 定义的角色为基础设施</span></span><br><span class="line">        definition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">        registry.registerBeanDefinition(</span><br><span class="line">                ConfigurationPropertiesBindingPostProcessor.BEAN_NAME, definition);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">registerConfigurationBeanFactoryMetadata</span><span class="params">(</span></span><br><span class="line"><span class="params">            BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">        <span class="type">GenericBeanDefinition</span> <span class="variable">definition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericBeanDefinition</span>();</span><br><span class="line">        definition.setBeanClass(ConfigurationBeanFactoryMetadata.class);</span><br><span class="line">        definition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">        registry.registerBeanDefinition(ConfigurationBeanFactoryMetadata.BEAN_NAME,</span><br><span class="line">                definition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h2><p><code>ConfigurationPropertiesBindingPostProcessor</code> 是用于 <code>ConfigurationProperties</code> 绑定的后处理器，关注 <code>afterPropertiesSet</code> 方法还有核心方法 <code>postProcessBeforeInitialization</code>。</p>
<ul>
<li>在 <code>afterPropertiesSet</code> 方法中，它获取到了和自己一起注册的 <code>ConfigurationBeanFactoryMetadata</code>。</li>
<li>在 <code>postProcessBeforeInitialization</code> 方法中，先获取 <code>@ConfigurationProperties</code>，再进行绑定。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigurationPropertiesBindingPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span>,</span><br><span class="line">        PriorityOrdered, ApplicationContextAware, InitializingBean &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BEAN_NAME</span> <span class="operator">=</span> ConfigurationPropertiesBindingPostProcessor.class</span><br><span class="line">            .getName();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">VALIDATOR_BEAN_NAME</span> <span class="operator">=</span> <span class="string">&quot;configurationPropertiesValidator&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConfigurationBeanFactoryMetadata beanFactoryMetadata;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConfigurationPropertiesBinder configurationPropertiesBinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span></span><br><span class="line">            <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="built_in">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// We can&#x27;t use constructor injection of the application context because</span></span><br><span class="line">        <span class="comment">// it causes eager factory bean initialization</span></span><br><span class="line">        <span class="comment">// 注入了 ConfigurationBeanFactoryMetadata（不理解注解描述的情况？）</span></span><br><span class="line">        <span class="built_in">this</span>.beanFactoryMetadata = <span class="built_in">this</span>.applicationContext.getBean(</span><br><span class="line">                ConfigurationBeanFactoryMetadata.BEAN_NAME,</span><br><span class="line">                ConfigurationBeanFactoryMetadata.class);</span><br><span class="line">        <span class="built_in">this</span>.configurationPropertiesBinder = <span class="keyword">new</span> <span class="title class_">ConfigurationPropertiesBinder</span>(</span><br><span class="line">                <span class="built_in">this</span>.applicationContext, VALIDATOR_BEAN_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Ordered.HIGHEST_PRECEDENCE + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span></span><br><span class="line">            <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">// 获取 @ConfigurationProperties</span></span><br><span class="line">        <span class="type">ConfigurationProperties</span> <span class="variable">annotation</span> <span class="operator">=</span> getAnnotation(bean, beanName,</span><br><span class="line">                ConfigurationProperties.class);</span><br><span class="line">        <span class="keyword">if</span> (annotation != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 绑定</span></span><br><span class="line">            bind(bean, beanName, annotation);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Object bean, String beanName, ConfigurationProperties annotation)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取 Bean 的类型</span></span><br><span class="line">        <span class="type">ResolvableType</span> <span class="variable">type</span> <span class="operator">=</span> getBeanType(bean, beanName);</span><br><span class="line">        <span class="comment">// 获取 @Validated 用于校验</span></span><br><span class="line">        <span class="type">Validated</span> <span class="variable">validated</span> <span class="operator">=</span> getAnnotation(bean, beanName, Validated.class);</span><br><span class="line">        Annotation[] annotations = (validated == <span class="literal">null</span> ? <span class="keyword">new</span> <span class="title class_">Annotation</span>[] &#123; annotation &#125;</span><br><span class="line">                : <span class="keyword">new</span> <span class="title class_">Annotation</span>[] &#123; annotation, validated &#125;);</span><br><span class="line">        <span class="comment">// 创建 Bindable 对象</span></span><br><span class="line">        Bindable&lt;?&gt; target = Bindable.of(type).withExistingValue(bean)</span><br><span class="line">                .withAnnotations(annotations);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 绑定</span></span><br><span class="line">            <span class="built_in">this</span>.configurationPropertiesBinder.bind(target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConfigurationPropertiesBindException</span>(beanName, bean, annotation,</span><br><span class="line">                    ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ResolvableType <span class="title function_">getBeanType</span><span class="params">(Object bean, String beanName)</span> &#123;</span><br><span class="line">        <span class="comment">// 先查找工厂方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">factoryMethod</span> <span class="operator">=</span> <span class="built_in">this</span>.beanFactoryMetadata.findFactoryMethod(beanName);</span><br><span class="line">        <span class="keyword">if</span> (factoryMethod != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果存在，返回工厂方法的返回值类型</span></span><br><span class="line">            <span class="keyword">return</span> ResolvableType.forMethodReturnType(factoryMethod);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则返回 bean 的类型（难道 bean 的类型不是工厂方法的返回值类型吗？）</span></span><br><span class="line">        <span class="keyword">return</span> ResolvableType.forClass(bean.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> &lt;A <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; A <span class="title function_">getAnnotation</span><span class="params">(Object bean, String beanName,</span></span><br><span class="line"><span class="params">            Class&lt;A&gt; type)</span> &#123;</span><br><span class="line">        <span class="comment">// 先到 @Bean 方法中获取</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">annotation</span> <span class="operator">=</span> <span class="built_in">this</span>.beanFactoryMetadata.findFactoryAnnotation(beanName, type);</span><br><span class="line">        <span class="keyword">if</span> (annotation == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果没有，再到类上获取</span></span><br><span class="line">            annotation = AnnotationUtils.findAnnotation(bean.getClass(), type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> annotation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ConfigurationBeanFactoryMetadata</code> 是用于在 <code>Bean</code> 工厂初始化期间记住 <code>@Bean</code> 定义元数据的实用程序类。在前面我们介绍过 <code>@ConfigurationProperties</code> 不仅可以添加到类定义，还可以用于标注 <code>@Bean</code> 方法，<code>ConfigurationBeanFactoryMetadata</code> 正是应用于在后者这类情况下获取 <code>@ConfigurationProperties</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigurationBeanFactoryMetadata</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, FactoryMetadata&gt; beansFactoryMetadata = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后处理 BeanFactory</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span></span><br><span class="line">            <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="built_in">this</span>.beanFactory = beanFactory;</span><br><span class="line">        <span class="comment">// 遍历 Bean 定义</span></span><br><span class="line">        <span class="keyword">for</span> (String name : beanFactory.getBeanDefinitionNames()) &#123;</span><br><span class="line">            <span class="type">BeanDefinition</span> <span class="variable">definition</span> <span class="operator">=</span> beanFactory.getBeanDefinition(name);</span><br><span class="line">            <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> definition.getFactoryMethodName();</span><br><span class="line">            <span class="type">String</span> <span class="variable">bean</span> <span class="operator">=</span> definition.getFactoryBeanName();、</span><br><span class="line">            <span class="comment">// 检测是否是一个 @Bean 方法对应的 Bean 定义</span></span><br><span class="line">            <span class="keyword">if</span> (method != <span class="literal">null</span> &amp;&amp; bean != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.beansFactoryMetadata.put(name, <span class="keyword">new</span> <span class="title class_">FactoryMetadata</span>(bean, method));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取工厂方法上的注解</span></span><br><span class="line">    <span class="keyword">public</span> &lt;A <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; A <span class="title function_">findFactoryAnnotation</span><span class="params">(String beanName,</span></span><br><span class="line"><span class="params">			Class&lt;A&gt; type)</span> &#123;</span><br><span class="line">		<span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> findFactoryMethod(beanName);</span><br><span class="line">		<span class="keyword">return</span> (method == <span class="literal">null</span> ? <span class="literal">null</span> : AnnotationUtils.findAnnotation(method, type));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取工厂方法</span></span><br><span class="line">	<span class="keyword">public</span> Method <span class="title function_">findFactoryMethod</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">this</span>.beansFactoryMetadata.containsKey(beanName)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		AtomicReference&lt;Method&gt; found = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(<span class="literal">null</span>);</span><br><span class="line">		<span class="type">FactoryMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> <span class="built_in">this</span>.beansFactoryMetadata.get(beanName);</span><br><span class="line">		Class&lt;?&gt; factoryType = <span class="built_in">this</span>.beanFactory.getType(metadata.getBean());</span><br><span class="line">		<span class="type">String</span> <span class="variable">factoryMethod</span> <span class="operator">=</span> metadata.getMethod();</span><br><span class="line">        <span class="comment">// 如果是代理类，获取其父类</span></span><br><span class="line">		<span class="keyword">if</span> (ClassUtils.isCglibProxyClass(factoryType)) &#123;</span><br><span class="line">			factoryType = factoryType.getSuperclass();</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 遍历声明的方法进行匹配（名字相同即可没问题吗？）</span></span><br><span class="line">		ReflectionUtils.doWithMethods(factoryType, (method) -&gt; &#123;</span><br><span class="line">			<span class="keyword">if</span> (method.getName().equals(factoryMethod)) &#123;</span><br><span class="line">				found.compareAndSet(<span class="literal">null</span>, method);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="keyword">return</span> found.get();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>@EnableConfigurationProperties</code> 的目的有两个：</p>
<ul>
<li>注册目标</li>
<li>注册后处理器用于在目标进行 <code>Bean</code> 初始化工作时，介入进行绑定</li>
</ul>
<p>尽管注册目标时的操作有些巧妙，但是还是要明白 <code>ConfigurationProperties</code> 类只是单纯的被注册了而已。对于后处理器而言，无论一个 <code>ConfigurationProperties</code> 类是不是通过注解注册，后处理器都会一视同仁地进行绑定。但同时，你又要知道后处理器也是通过 <code>@EnableConfigurationProperties</code> 注册的，因此你需要保证至少有一个 <code>@EnableConfigurationProperties</code> 标注的类被注册（并被处理了 <code>@Import</code>）。<br>在 <code>Spring Boot</code> 中，<code>@SpringBootApplication</code> 通过 <code>@EnableAutoConfiguration</code> 启用了自动配置，从而注册了 <code>ConfigurationPropertiesAutoConfiguration</code>，<code>ConfigurationPropertiesAutoConfiguration</code> 标注了 <code>@EnableConfigurationProperties</code>。因此，对于 <code>Spring Boot</code> 而言，扫描范围内的所有 <code>ConfigurationProperties</code> 类，其实都不需要 <code>@EnableAutoConfiguration</code>。事实上，由于默认生成的 <code>beanName</code> 不同，多余的配置还会重复注册两个 <code>Bean</code> 定义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigurationPropertiesAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>当 MySQL 以 skip-name-resolve 模式启动时如何使用 grant 命令</title>
    <url>/2023/12/13/how-to-grant-when-MySQL-started-with-skip-name-resolve-mode/</url>
    <content><![CDATA[<p>本文介绍了 <code>MySQL</code> 中 <code>skip-name-resolve</code> 参数<strong>对连接的优化作用</strong>，随之而来的权限表<strong>仅可使用 <code>IP</code> 的限制</strong>，以及如何在无法提前确定 <code>IP</code> 的情况下使用 <code>grant</code> 命令<strong>搭配通配符 <code>%</code> 进行授权</strong>。</p>
<span id="more"></span>

<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>在 <code>MySQL</code> 新建一个用户 <code>exporter</code> 给 <code>mysqld-exporter</code> 使用，然后通过 <code>grant</code> 命令授予该用户部分权限。执行命令如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;exporter&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;XXXXXXXX&#x27;</span> <span class="keyword">WITH</span> MAX_USER_CONNECTIONS <span class="number">3</span>;</span><br><span class="line"><span class="keyword">GRANT</span> PROCESS, REPLICATION CLIENT, <span class="keyword">SELECT</span> <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;exporter&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>在执行时提示“这次 <code>grant</code> 需要关闭 <code>skip-name-resolve</code> 参数然后重启 <code>MySQL</code> 才能生效”。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">0 row(s) affected, 1 warning(s): 1285 MySQL is started in --skip-name-resolve mode; you must restart it without this switch for this grant to work</span><br></pre></td></tr></table></figure>

<p>本着默认的参数不随便修改的想法，我们来看一看 <code>skip-name-resolve</code> 参数究竟有什么用。</p>
<h2 id="skip-name-resolve-的作用"><a href="#skip-name-resolve-的作用" class="headerlink" title="skip-name-resolve 的作用"></a>skip-name-resolve 的作用</h2><p><code>MySQL</code> 在启动时默认使用 <code>skip-name-resolve</code> 参数。顾名思义，该参数用于跳过 <code>MySQL</code> 的 <code>DNS</code> 解析。关于 <code>MySQL</code> 是如何使用 <code>DNS</code> 的，官方文档是这样介绍的：</p>
<p>当一个新线程连接到 <code>mysqld</code>，<code>mysqld</code> 会生成一个新线程去处理该请求。该线程首先检查主机名是否在主机名缓存中，如果没有那么该线程会调用 <code>gethostbyaddr_r()</code> 和 <code>gethostbyname_r()</code> 来解析主机名。如果操作系统不支持上述线程安全的调用，那么该线程会加锁然后调用 <code>gethostbyaddr()</code> 和 <code>gethostbyname()</code>。这种情况下，在第一个线程准备好之前，没有其他线程可以解析不在主机名缓存中的其他主机名。<code>MySQL</code> 允许通过 <code>skip-name-resolve</code> 参数禁用 <code>DNS</code> 解析，但是如果禁用的话，在 <code>MySQL</code> 的权限表中就只能使用 <code>IP</code>。</p>
<blockquote>
<p>获取 <code>IP</code> 和主机名可以用于在权限表中匹配权限，如果禁用 <code>DNS</code> 解析，在权限表中只能使用 <code>IP</code> 也就理所当然了。</p>
</blockquote>
<p>官方建议如果你的 <code>DNS</code> 解析非常慢或者你有非常多的主机，可以使用 <code>skip-name-resolve</code> 参数禁用 <code>DNS</code> 解析或者增加 <code>HOST_CACHE_SIZE</code>（默认值：<code>128</code>）并重新编译 <code>mysqld</code> 来获得更高的性能。以下文章的作者介绍了他们因为 <code>MySQL</code> <code>DNS</code> 解析遇到的连接慢的问题：</p>
<ul>
<li><a href="https://blog.csdn.net/hwhua1986/article/details/78188231">mysql中的 skip-name-resolve 问题</a></li>
<li><a href="https://www.vionblog.com/skip-name-resolve-to-speed-up-mysql-and-avoid-problems/">skip-name-resolve to speed up MySQL and avoid problems</a></li>
</ul>
<blockquote>
<p>因为缺乏对具体的 <code>MySQL</code> 代码实现的了解，所以没有办法对上述过程进行深入和准确的描述。在官方的表述中，根据 <code>IP</code> 查询主机名和根据主机名查询 <code>IP</code> 似乎都存在；但在查阅到的资料中，部分文章提到的一般是“反向解析”，也就是根据 <code>IP</code> 查询主机名；但是更多的文章对这部分比较含糊其辞。</p>
</blockquote>
<h2 id="怎么使用-grant-命令"><a href="#怎么使用-grant-命令" class="headerlink" title="怎么使用 grant 命令"></a>怎么使用 grant 命令</h2><p>如果你并不考虑对特定用户多加限制，那么使用通配符 <code>%</code> 即可，它将允许从任意 <code>IP</code> 连接 <code>MySQL</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;exporter&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;XXXXXXXX&#x27;</span> <span class="keyword">WITH</span> MAX_USER_CONNECTIONS <span class="number">3</span>;</span><br><span class="line"><span class="keyword">GRANT</span> PROCESS, REPLICATION CLIENT, <span class="keyword">SELECT</span> <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;exporter&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>但是在我的情况中，新建的用户是给 <code>mysqld-exporter</code> 获取 <code>MySQL</code> 的监控数据的，显然<strong>限制该用户的 <code>IP</code>、连接数以及权限</strong>很有必要。可是如果使用的是 <code>Docker</code> 或者其他无法提前确定 <code>IP</code> 的环境怎么办呢？还是可以<strong>使用通配符 <code>%</code> 限制为仅某一 <code>IP</code> 范围可以访问</strong>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;exporter&#x27;</span>@<span class="string">&#x27;172.19.%.%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;XXXXXXXX&#x27;</span> <span class="keyword">WITH</span> MAX_USER_CONNECTIONS <span class="number">3</span>;</span><br><span class="line"><span class="keyword">GRANT</span> PROCESS, REPLICATION CLIENT, <span class="keyword">SELECT</span> <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;exporter&#x27;</span>@<span class="string">&#x27;172.19.%.%&#x27;</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>ComponentScan 扫描路径覆盖的真相</title>
    <url>/2023/12/11/the-truth-about-override-of-ComponentScan-basePackages/</url>
    <content><![CDATA[<p><code>@ComponentScan</code> 注解是 <code>Spring</code> 中很常用的注解，用于扫描并加载指定类路径下的 <code>Bean</code>，而 <code>Spring Boot</code> 为了便捷使用 <code>@SpringBootApplication</code> 组合注解集成了 <code>@ComponentScan</code> 的能力。也许你听说过使用后者会覆盖前者中关于包扫描的设置，但你是否质疑过这个“不合常理”的结论？是否好奇过为什么它们不像其他注解在嵌套使用时可以同时生效？又是否好奇过 <code>@SpringBootApplication</code> 可以间接设置 <code>@ComponentScan</code> 属性的原因？本文从源码角度分析 <code>@ComponentScan</code> 的工作原理，揭示它独特的检索算法和注解层次结构中的属性覆盖机制。</p>
<span id="more"></span>

<ul>
<li>本文的写作动机继承自<a href="/2023/11/23/source-code-analysis-of-Spring-Configuration-annotation/" title="Spring @Configuration 注解的源码分析">Spring @Configuration 注解的源码分析</a>，处理 <code>@ComponentScan</code> 是处理 <code>@Configuration</code> 过程的一部分。</li>
</ul>
<h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><p>对于标注了 <code>@ComponentScan</code> 注解的配置类，处理过程如下：</p>
<ul>
<li>获取 <code>@ComponentScan</code> 的注解属性</li>
<li>遍历注解属性集合，依次根据其中的信息进行扫描，获取 <code>Bean</code> 定义</li>
<li>如果获取到的 <code>Bean</code> 定义中有任何其他配置类，将递归解析（处理配置类）</li>
</ul>
<blockquote>
<p>这里和处理 <code>@Import</code> 的过程很像，都出现了递归解析新获得的配置类。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> SourceClass <span class="title function_">doProcessConfigurationClass</span><span class="params">(ConfigurationClass configClass, SourceClass sourceClass)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 处理任何 @ComponentScan 注解</span></span><br><span class="line">    <span class="comment">// 获取 @ComponentScan 的注解属性，该注解是可重复的</span></span><br><span class="line">    Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">            sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);</span><br><span class="line">    <span class="keyword">if</span> (!componentScans.isEmpty() &amp;&amp;</span><br><span class="line">            !<span class="built_in">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line">            <span class="comment">// 如果配置类被标注了 @ComponentScan -&gt; 立即扫描</span></span><br><span class="line">            Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line">                    <span class="built_in">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line">            <span class="comment">// 检测被扫描到的 Bean 定义中是否有任何其他配置类，如有需要递归解析</span></span><br><span class="line">            <span class="keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(</span><br><span class="line">                        holder.getBeanDefinition(), <span class="built_in">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">                    <span class="comment">// 递归解析配置类</span></span><br><span class="line">                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="扫描获取-Bean-定义"><a href="#扫描获取-Bean-定义" class="headerlink" title="扫描获取 Bean 定义"></a>扫描获取 Bean 定义</h2><p>我们先跳过“获取 <code>@ComponentScan</code> 的注解属性”的过程，来看“扫描获取 <code>Bean</code> 定义”的过程。扫描是通过 <code>ComponentScanAnnotationParser</code> 的 <code>parse</code> 方法完成的，这个方法很长，但逻辑并不复杂，主要是为 <code>ClassPathBeanDefinitionScanner</code> 设置一些来自 <code>@ComponentScan</code> 的注解属性值，最终执行扫描。<code>ClassPathBeanDefinitionScanner</code> 顾名思义是基于类路径的 <code>Bean</code> 定义扫描器，真正的扫描工作全部委托给了它。在这些设置过程中，我们需要关注 <code>basePackages</code> 的设置：</p>
<ul>
<li>使用 Set 存储合并结果，用于去重</li>
<li>获取设置的 <code>basePackages</code> 值并添加</li>
<li>获取设置的 <code>basePackageClasses</code> 值，转换为它们所在的包名并添加</li>
<li>如果结果集现在还是空的，获取被标注的配置类所在的包名并添加</li>
</ul>
<blockquote>
<p>最后一条规则就是“默认情况下扫描配置类所在的包”的说法由来，并且根据代码可知，如果主动设置了值，这条规则就不起作用了。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">parse</span><span class="params">(AnnotationAttributes componentScan, <span class="keyword">final</span> String declaringClass)</span> &#123;</span><br><span class="line">    Assert.state(<span class="built_in">this</span>.environment != <span class="literal">null</span>, <span class="string">&quot;Environment must not be null&quot;</span>);</span><br><span class="line">    Assert.state(<span class="built_in">this</span>.resourceLoader != <span class="literal">null</span>, <span class="string">&quot;ResourceLoader must not be null&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建 ClassPathBeanDefinitionScanner</span></span><br><span class="line">    <span class="type">ClassPathBeanDefinitionScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(<span class="built_in">this</span>.registry,</span><br><span class="line">            componentScan.getBoolean(<span class="string">&quot;useDefaultFilters&quot;</span>), <span class="built_in">this</span>.environment, <span class="built_in">this</span>.resourceLoader);</span><br><span class="line">    <span class="comment">// Bean 名称生成器</span></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">BeanNameGenerator</span>&gt; generatorClass = componentScan.getClass(<span class="string">&quot;nameGenerator&quot;</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">useInheritedGenerator</span> <span class="operator">=</span> (BeanNameGenerator.class == generatorClass);</span><br><span class="line">    scanner.setBeanNameGenerator(useInheritedGenerator ? <span class="built_in">this</span>.beanNameGenerator :</span><br><span class="line">            BeanUtils.instantiateClass(generatorClass));</span><br><span class="line"></span><br><span class="line">    <span class="type">ScopedProxyMode</span> <span class="variable">scopedProxyMode</span> <span class="operator">=</span> componentScan.getEnum(<span class="string">&quot;scopedProxy&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (scopedProxyMode != ScopedProxyMode.DEFAULT) &#123;</span><br><span class="line">        scanner.setScopedProxyMode(scopedProxyMode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">ScopeMetadataResolver</span>&gt; resolverClass = componentScan.getClass(<span class="string">&quot;scopeResolver&quot;</span>);</span><br><span class="line">        scanner.setScopeMetadataResolver(BeanUtils.instantiateClass(resolverClass));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    scanner.setResourcePattern(componentScan.getString(<span class="string">&quot;resourcePattern&quot;</span>));</span><br><span class="line">    <span class="comment">// 设置 Filter</span></span><br><span class="line">    <span class="keyword">for</span> (AnnotationAttributes filter : componentScan.getAnnotationArray(<span class="string">&quot;includeFilters&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (TypeFilter typeFilter : typeFiltersFor(filter)) &#123;</span><br><span class="line">            scanner.addIncludeFilter(typeFilter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (AnnotationAttributes filter : componentScan.getAnnotationArray(<span class="string">&quot;excludeFilters&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (TypeFilter typeFilter : typeFiltersFor(filter)) &#123;</span><br><span class="line">            scanner.addExcludeFilter(typeFilter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否懒加载</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">lazyInit</span> <span class="operator">=</span> componentScan.getBoolean(<span class="string">&quot;lazyInit&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (lazyInit) &#123;</span><br><span class="line">        scanner.getBeanDefinitionDefaults().setLazyInit(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置 basePackages（使用 Set 去重）</span></span><br><span class="line">    Set&lt;String&gt; basePackages = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;String&gt;();</span><br><span class="line">    <span class="comment">// 获取设置的 basePackages 值</span></span><br><span class="line">    String[] basePackagesArray = componentScan.getStringArray(<span class="string">&quot;basePackages&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String pkg : basePackagesArray) &#123;</span><br><span class="line">        <span class="comment">// 允许占位符</span></span><br><span class="line">        String[] tokenized = StringUtils.tokenizeToStringArray(<span class="built_in">this</span>.environment.resolvePlaceholders(pkg),</span><br><span class="line">                ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);</span><br><span class="line">        basePackages.addAll(Arrays.asList(tokenized));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取 basePackageClasses，本质上是为了获取它们所在的包名</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; clazz : componentScan.getClassArray(<span class="string">&quot;basePackageClasses&quot;</span>)) &#123;</span><br><span class="line">        basePackages.add(ClassUtils.getPackageName(clazz));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果为空，获取被标注的配置类所在的包名</span></span><br><span class="line">    <span class="keyword">if</span> (basePackages.isEmpty()) &#123;</span><br><span class="line">        basePackages.add(ClassUtils.getPackageName(declaringClass));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 排除被标注的配置类本身</span></span><br><span class="line">    scanner.addExcludeFilter(<span class="keyword">new</span> <span class="title class_">AbstractTypeHierarchyTraversingFilter</span>(<span class="literal">false</span>, <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">matchClassName</span><span class="params">(String className)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> declaringClass.equals(className);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 执行扫描</span></span><br><span class="line">    <span class="keyword">return</span> scanner.doScan(StringUtils.toStringArray(basePackages));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>parse</code> 方法与其说是解析，不如说是封装了一些设置并最终调用 <code>ClassPathBeanDefinitionScanner</code>，而设置的属性值来源于 <code>@ComponentScan</code> 的注解属性。关于获取 <code>@ComponentScan</code> 的注解属性的方法 <code>AnnotationConfigUtils.attributesForRepeatable</code> 在分析 <code>@PropertySource</code> 时也曾经遇到过，顾名思义我们知道它应该是用于获取可重复的注解的属性。可是它和直接获取注解对象有什么区别呢？</p>
<blockquote>
<p>我们知道 <code>@SpringBootApplication</code> 拥有和 <code>@ComponentScan</code> 具备相似的功能，并且可以使用 <code>scanBasePackages</code> 和 <code>scanBasePackageClasses</code> 这两个属性设置扫描的包。也许你还知道 <code>@SpringBootApplication</code> 之所以如此是因为它被标注了 <code>@ComponentScan</code>，<code>scanBasePackages</code> 和 <code>scanBasePackageClasses</code> 分别是它的元注解 <code>@ComponentScan</code> 中 <code>basePackages</code> 和 <code>basePackageClasses</code> 的别名。你甚至可能知道<strong>如果在配置类上使用 <code>@ComponentScan</code> 设置包扫描后会导致 <code>@SpringBootApplication</code> 设置的包扫描失效</strong>。<br><strong>可是为什么呢？</strong>在 <code>Spring</code> 中我们会看到从指定类上直接获取目标注解的代码，我们还会看到递归地从元注解上获取目标注解的代码，我们使用 <code>@ComponentScan</code> 的经验告诉我们可重复注解不是覆盖彼此而是共同生效，那么为什么 <code>@SpringBootApplication</code> 上的 <code>@ComponentScan</code> 就被覆盖了呢？<strong>想当然的认为 <code>@SpringBootApplication</code> 上标注了 <code>@ComponentScan</code> 是一切的原因是不够的</strong>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123;</span></span><br><span class="line"><span class="meta">		@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@AliasFor(annotation = EnableAutoConfiguration.class)</span></span><br><span class="line">	Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@AliasFor(annotation = EnableAutoConfiguration.class)</span></span><br><span class="line">	String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackages&quot;)</span></span><br><span class="line">	String[] scanBasePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackageClasses&quot;)</span></span><br><span class="line">	Class&lt;?&gt;[] scanBasePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取注解属性"><a href="#获取注解属性" class="headerlink" title="获取注解属性"></a>获取注解属性</h2><p><code>attributesForRepeatable</code> 方法有两个重载方法，最终调用的版本如下。先后处理了 <code>@ComponentScan</code> 和 <code>@ComponentScans</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Set&lt;AnnotationAttributes&gt; <span class="title function_">attributesForRepeatable</span><span class="params">(AnnotationMetadata metadata,</span></span><br><span class="line"><span class="params">        String containerClassName, String annotationClassName)</span> &#123;</span><br><span class="line">    <span class="comment">// Set 用于存储结果</span></span><br><span class="line">    Set&lt;AnnotationAttributes&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;AnnotationAttributes&gt;();</span><br><span class="line">    <span class="comment">// 处理 @ComponentScan</span></span><br><span class="line">    addAttributesIfNotNull(result, metadata.getAnnotationAttributes(annotationClassName, <span class="literal">false</span>));</span><br><span class="line">    <span class="comment">// 处理 @ComponentScans</span></span><br><span class="line">    Map&lt;String, Object&gt; container = metadata.getAnnotationAttributes(containerClassName, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (container != <span class="literal">null</span> &amp;&amp; container.containsKey(<span class="string">&quot;value&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Map&lt;String, Object&gt; containedAttributes : (Map&lt;String, Object&gt;[]) container.get(<span class="string">&quot;value&quot;</span>)) &#123;</span><br><span class="line">            addAttributesIfNotNull(result, containedAttributes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableSet(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="检索注解的规则"><a href="#检索注解的规则" class="headerlink" title="检索注解的规则"></a>检索注解的规则</h3><p>根据注释，<code>getAnnotationAttributes</code> 方法检索给定类型的注解的属性，<strong>检索的目标可以是直接注解也可以是元注解</strong>，同时考虑<strong>组合注解上的属性覆盖</strong>。</p>
<ul>
<li>元注解指的是标注在其他注解上的注解，用于对被标注的注解进行说明，比如 <code>@SpringBootApplication</code> 上的 <code>@ComponentScan</code> 就被称为元注解，此时 <code>@SpringBootApplication</code> 被称为组合注解</li>
<li>组合注解中存在属性覆盖现象</li>
</ul>
<blockquote>
<p>其实这两点分别对应了我们想要探究的两个问题：<code>@ComponentScan</code> 究竟是如何被检索的？注解属性比如 <code>basePackages</code> 又是如何被覆盖的？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">getAnnotationAttributes</span><span class="params">(String annotationName, <span class="type">boolean</span> classValuesAsString)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取合并的注解属性</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span>.annotations.length &gt; <span class="number">0</span> ? AnnotatedElementUtils.getMergedAnnotationAttributes(</span><br><span class="line">            getIntrospectedClass(), annotationName, classValuesAsString, <span class="built_in">this</span>.nestedAnnotationsAsMap) : <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据注释，<code>getMergedAnnotationAttributes</code> 方法获取所提供元素上方的注解层次结构中指定的 <code>annotationName</code> 的第一个注解，并将该注解的属性与注解层次结构较低级别中的注解中的匹配属性合并。注解层次结构中较低级别的属性会覆盖较高级别中的同名属性，并且完全支持单个注解中或是注解层次结构中的 <code>@AliasFor</code> 语义。与 <code>getAllAnnotationAttributes</code> 方法相反，一旦找到指定 <code>annotationName</code> 的第一个注解，此方法使用的搜索算法将停止搜索注解层次结构。因此，指定的 <code>annotationName</code> 的附加注解将被忽略。</p>
<blockquote>
<p>这注释有点太抽象了，理解代码后再来回味吧。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> AnnotationAttributes <span class="title function_">getMergedAnnotationAttributes</span><span class="params">(AnnotatedElement element,</span></span><br><span class="line"><span class="params">        String annotationName, <span class="type">boolean</span> classValuesAsString, <span class="type">boolean</span> nestedAnnotationsAsMap)</span> &#123;</span><br><span class="line">    <span class="comment">// 以 get 语义进行搜索（是指找到即终止搜索？）</span></span><br><span class="line">    <span class="type">AnnotationAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> searchWithGetSemantics(element, <span class="literal">null</span>, annotationName,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">MergedAnnotationAttributesProcessor</span>(classValuesAsString, nestedAnnotationsAsMap));</span><br><span class="line">    <span class="comment">// 后处理注解属性</span></span><br><span class="line">    AnnotationUtils.postProcessAnnotationAttributes(element, attributes, classValuesAsString, nestedAnnotationsAsMap);</span><br><span class="line">    <span class="keyword">return</span> attributes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>searchWithGetSemantics</code> 方法有多个重载方法，最终调用的版本如下：</p>
<ul>
<li>先获取 <code>element</code> 上的所有注解（包括重复的，不包括继承的），<strong>这意味着可重复注解 <code>@ComponentScan</code> 标注了多个就会有多个实例</strong></li>
<li>在注解中搜索</li>
<li>如果没找到，就从继承的注解中继续搜索</li>
</ul>
<blockquote>
<p>本方法是一个会被递归调用的方法，在第一次调用时 <code>element</code> 是配置类，之后就是注解。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">searchWithGetSemantics</span><span class="params">(AnnotatedElement element,</span></span><br><span class="line"><span class="params">        <span class="meta">@Nullable</span> Class&lt;? extends Annotation&gt; annotationType, <span class="meta">@Nullable</span> String annotationName,</span></span><br><span class="line"><span class="params">        <span class="meta">@Nullable</span> Class&lt;? extends Annotation&gt; containerType, Processor&lt;T&gt; processor,</span></span><br><span class="line"><span class="params">        Set&lt;AnnotatedElement&gt; visited, <span class="type">int</span> metaDepth)</span> &#123;</span><br><span class="line">    <span class="comment">// 防止无限递归</span></span><br><span class="line">    <span class="keyword">if</span> (visited.add(element)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取 element 上的所有注解（包括重复，不包括继承的）</span></span><br><span class="line">            List&lt;Annotation&gt; declaredAnnotations = Arrays.asList(element.getDeclaredAnnotations());</span><br><span class="line">            <span class="comment">// 在获得的注解中搜索</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> searchWithGetSemanticsInAnnotations(element, declaredAnnotations,</span><br><span class="line">                    annotationType, annotationName, containerType, processor, visited, metaDepth);</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 表明在直接声明的注解中没有找到</span></span><br><span class="line">            <span class="comment">// 如果 element 是一个类</span></span><br><span class="line">            <span class="keyword">if</span> (element <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">                <span class="comment">// 获取所有的注解（包括重复的和继承的）</span></span><br><span class="line">                List&lt;Annotation&gt; inheritedAnnotations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span> (Annotation annotation : element.getAnnotations()) &#123;</span><br><span class="line">                    <span class="comment">// 排除已经搜索过的，只留下继承的注解</span></span><br><span class="line">                    <span class="keyword">if</span> (!declaredAnnotations.contains(annotation)) &#123;</span><br><span class="line">                        inheritedAnnotations.add(annotation);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 继续搜索</span></span><br><span class="line">                result = searchWithGetSemanticsInAnnotations(element, inheritedAnnotations,</span><br><span class="line">                        annotationType, annotationName, containerType, processor, visited, metaDepth);</span><br><span class="line">                <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            AnnotationUtils.handleIntrospectionFailure(element, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历注解进行搜索。</p>
<ul>
<li>先在注解中搜索，<strong>这意味着如果配置类标注了 <code>@ComponentScan</code>，直接就找到了</strong></li>
<li>如果没找到再在元注解中搜索，如果配置类只标注了 <code>@SpringBootApplication</code>，就是在这部分找到元注解 <code>@ComponentScan</code></li>
</ul>
<blockquote>
<p>严格意义上说，并不是直接标注的 <code>@ComponentScan</code> 会覆盖 <code>@SpringBootApplication</code> 上间接标注的 <code>@ComponentScan</code>，而是搜索在找到第一个注解后终止没有继续查找。这解答了我们的第一个疑问。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">searchWithGetSemanticsInAnnotations</span><span class="params">(<span class="meta">@Nullable</span> AnnotatedElement element,</span></span><br><span class="line"><span class="params">        List&lt;Annotation&gt; annotations, <span class="meta">@Nullable</span> Class&lt;? extends Annotation&gt; annotationType,</span></span><br><span class="line"><span class="params">        <span class="meta">@Nullable</span> String annotationName, <span class="meta">@Nullable</span> Class&lt;? extends Annotation&gt; containerType,</span></span><br><span class="line"><span class="params">        Processor&lt;T&gt; processor, Set&lt;AnnotatedElement&gt; visited, <span class="type">int</span> metaDepth)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历注解进行查找，如果同时标注 @SpringBootApplication 和 @ComponentScan，在这部分就会找到 @ComponentScan 就返回了</span></span><br><span class="line">    <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">        <span class="comment">// 获取注解的 Class</span></span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; currentAnnotationType = annotation.annotationType();</span><br><span class="line">        <span class="comment">// 检测是否属于 Java 语言注解包中（以 java.lang.annotation 开头）的注解，例如 @Documented，是的话跳过</span></span><br><span class="line">        <span class="keyword">if</span> (!AnnotationUtils.isInJavaLangAnnotationPackage(currentAnnotationType)) &#123;</span><br><span class="line">            <span class="comment">// 检测是否满足条件：等于 annotationType（传入 null），或者和目标的名字（@ComponentScan 全限定类名）相同，或者属于总是处理（默认 false）</span></span><br><span class="line">            <span class="keyword">if</span> (currentAnnotationType == annotationType ||</span><br><span class="line">                    currentAnnotationType.getName().equals(annotationName) ||</span><br><span class="line">                    processor.alwaysProcesses()) &#123;</span><br><span class="line">                <span class="comment">// 处理注解获得注解属性</span></span><br><span class="line">                <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> processor.process(element, annotation, metaDepth);</span><br><span class="line">                <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// processor.aggregates() 默认返回 false</span></span><br><span class="line">                    <span class="keyword">if</span> (processor.aggregates() &amp;&amp; metaDepth == <span class="number">0</span>) &#123;</span><br><span class="line">                        processor.getAggregatedResults().add(result);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 注意：难道标注多个 @ComponentScan 也只找到一个就返回了？</span></span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 容器里的可重复注解，因为 containerType 为 null，跳过</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (currentAnnotationType == containerType) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Annotation contained : getRawAnnotationsFromContainer(element, annotation)) &#123;</span><br><span class="line">                    <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> processor.process(element, contained, metaDepth);</span><br><span class="line">                    <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// No need to post-process since repeatable annotations within a</span></span><br><span class="line">                        <span class="comment">// container cannot be composed annotations.</span></span><br><span class="line">                        processor.getAggregatedResults().add(result);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在元注解中递归的搜索，@SpringBootApplication 中的 @ComponentScan 就是在这找到的</span></span><br><span class="line">    <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">        <span class="comment">// 获取注解的 Class</span></span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; currentAnnotationType = annotation.annotationType();</span><br><span class="line">        <span class="comment">// 检测是否属于 Java 语言注解包中</span></span><br><span class="line">        <span class="keyword">if</span> (!AnnotationUtils.isInJavaLangAnnotationPackage(currentAnnotationType)) &#123;</span><br><span class="line">            <span class="comment">// 递归到元注解中搜索，深度加 1</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> searchWithGetSemantics(currentAnnotationType, annotationType,</span><br><span class="line">                    annotationName, containerType, processor, visited, metaDepth + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 进行后处理，注解层次结构中较低级别的属性会覆盖较高级别中的同名属性就是在这发生的</span></span><br><span class="line">                processor.postProcess(element, annotation, result);</span><br><span class="line">                <span class="keyword">if</span> (processor.aggregates() &amp;&amp; metaDepth == <span class="number">0</span>) &#123;</span><br><span class="line">                    processor.getAggregatedResults().add(result);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理 <code>@ComponentScan</code> 获得 <code>AnnotationAttributes</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> AnnotationAttributes <span class="title function_">process</span><span class="params">(<span class="meta">@Nullable</span> AnnotatedElement annotatedElement, Annotation annotation, <span class="type">int</span> metaDepth)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> AnnotationUtils.retrieveAnnotationAttributes(annotatedElement, annotation,</span><br><span class="line">            <span class="built_in">this</span>.classValuesAsString, <span class="built_in">this</span>.nestedAnnotationsAsMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以 <code>AnnotationAttributes</code> 映射的形式检索给定注解的属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> AnnotationAttributes <span class="title function_">retrieveAnnotationAttributes</span><span class="params">(<span class="meta">@Nullable</span> Object annotatedElement, Annotation annotation,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> classValuesAsString, <span class="type">boolean</span> nestedAnnotationsAsMap)</span> &#123;</span><br><span class="line"></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; annotationType = annotation.annotationType();</span><br><span class="line">    <span class="type">AnnotationAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationAttributes</span>(annotationType);</span><br><span class="line">    <span class="comment">// 遍历属性方法</span></span><br><span class="line">    <span class="keyword">for</span> (Method method : getAttributeMethods(annotationType)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取属性值</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">attributeValue</span> <span class="operator">=</span> method.invoke(annotation);</span><br><span class="line">            <span class="comment">// 获取默认值</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">defaultValue</span> <span class="operator">=</span> method.getDefaultValue();</span><br><span class="line">            <span class="comment">// 如果默认值不为 null 且和属性值相同</span></span><br><span class="line">            <span class="keyword">if</span> (defaultValue != <span class="literal">null</span> &amp;&amp; ObjectUtils.nullSafeEquals(attributeValue, defaultValue)) &#123;</span><br><span class="line">                attributeValue = <span class="keyword">new</span> <span class="title class_">DefaultValueHolder</span>(defaultValue);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 属性名 -&gt; 属性值</span></span><br><span class="line">            attributes.put(method.getName(),</span><br><span class="line">                    adaptValue(annotatedElement, attributeValue, classValuesAsString, nestedAnnotationsAsMap));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> InvocationTargetException) &#123;</span><br><span class="line">                <span class="type">Throwable</span> <span class="variable">targetException</span> <span class="operator">=</span> ((InvocationTargetException) ex).getTargetException();</span><br><span class="line">                rethrowAnnotationConfigurationException(targetException);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Could not obtain annotation attribute value for &quot;</span> + method, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> attributes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取在所提供的 annotationType 中声明的与 Java 对注释属性的要求相匹配的所有方法</span></span><br><span class="line"><span class="keyword">static</span> List&lt;Method&gt; <span class="title function_">getAttributeMethods</span><span class="params">(Class&lt;? extends Annotation&gt; annotationType)</span> &#123;</span><br><span class="line">    <span class="comment">// 先从缓存中获取</span></span><br><span class="line">    List&lt;Method&gt; methods = attributeMethodsCache.get(annotationType);</span><br><span class="line">    <span class="keyword">if</span> (methods != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> methods;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历方法筛选</span></span><br><span class="line">    methods = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Method method : annotationType.getDeclaredMethods()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isAttributeMethod(method)) &#123;</span><br><span class="line">            ReflectionUtils.makeAccessible(method);</span><br><span class="line">            methods.add(method);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存入缓存</span></span><br><span class="line">    attributeMethodsCache.put(annotationType, methods);</span><br><span class="line">    <span class="keyword">return</span> methods;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确定提供的方法是否是注解的属性方法。</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isAttributeMethod</span><span class="params">(<span class="meta">@Nullable</span> Method method)</span> &#123;</span><br><span class="line">    <span class="comment">// 无参数 &amp;&amp; 返回值非 void</span></span><br><span class="line">    <span class="keyword">return</span> (method != <span class="literal">null</span> &amp;&amp; method.getParameterCount() == <span class="number">0</span> &amp;&amp; method.getReturnType() != <span class="keyword">void</span>.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组合注解的属性覆盖"><a href="#组合注解的属性覆盖" class="headerlink" title="组合注解的属性覆盖"></a>组合注解的属性覆盖</h3><p>在获得注解属性后还要进行后处理，使用注解层次结构中较低级别的属性覆盖较高级别中的同名（包括 <code>@AliasFor</code> 指定的）属性。比如使用 <code>@SpringBootApplication</code> 中的 <code>scanBasePackages</code> 的值覆盖 <code>@ComponentScan</code> 中的 <code>basePackages</code> 的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcess</span><span class="params">(<span class="meta">@Nullable</span> AnnotatedElement element, Annotation annotation, AnnotationAttributes attributes)</span> &#123;</span><br><span class="line">    annotation = AnnotationUtils.synthesizeAnnotation(annotation, element);</span><br><span class="line">    <span class="comment">// 获取 AnnotationAttributes 的注解类型（@ComponentScan）</span></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; targetAnnotationType = attributes.annotationType();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Track which attribute values have already been replaced so that we can short</span></span><br><span class="line">    <span class="comment">// circuit the search algorithms.</span></span><br><span class="line">    Set&lt;String&gt; valuesAlreadyReplaced = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 获取注解的属性方法（SpringBootApplication）</span></span><br><span class="line">    <span class="keyword">for</span> (Method attributeMethod : AnnotationUtils.getAttributeMethods(annotation.annotationType())) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">attributeName</span> <span class="operator">=</span> attributeMethod.getName();</span><br><span class="line">        <span class="comment">// 获取被覆盖的别名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">attributeOverrideName</span> <span class="operator">=</span> AnnotationUtils.getAttributeOverrideName(attributeMethod, targetAnnotationType);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Explicit annotation attribute override declared via @AliasFor</span></span><br><span class="line">        <span class="keyword">if</span> (attributeOverrideName != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 被覆盖的属性的值是否已经被替换</span></span><br><span class="line">            <span class="keyword">if</span> (valuesAlreadyReplaced.contains(attributeOverrideName)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            List&lt;String&gt; targetAttributeNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            targetAttributeNames.add(attributeOverrideName);</span><br><span class="line">            valuesAlreadyReplaced.add(attributeOverrideName);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 确保覆盖目标注解中的所有别名属性。 (SPR-14069)</span></span><br><span class="line">            List&lt;String&gt; aliases = AnnotationUtils.getAttributeAliasMap(targetAnnotationType).get(attributeOverrideName);</span><br><span class="line">            <span class="keyword">if</span> (aliases != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!valuesAlreadyReplaced.contains(alias)) &#123;</span><br><span class="line">                        targetAttributeNames.add(alias);</span><br><span class="line">                        valuesAlreadyReplaced.add(alias);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            overrideAttributes(element, annotation, attributes, attributeName, targetAttributeNames);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Implicit annotation attribute override based on convention</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!AnnotationUtils.VALUE.equals(attributeName) &amp;&amp; attributes.containsKey(attributeName)) &#123;</span><br><span class="line">            overrideAttribute(element, annotation, attributes, attributeName, attributeName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据提供的注解属性方法的 @AliasFor，获取被覆盖的属性的名称</span></span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">getAttributeOverrideName</span><span class="params">(Method attribute, <span class="meta">@Nullable</span> Class&lt;? extends Annotation&gt; metaAnnotationType)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取别名描述符</span></span><br><span class="line">    <span class="type">AliasDescriptor</span> <span class="variable">descriptor</span> <span class="operator">=</span> AliasDescriptor.from(attribute);</span><br><span class="line">    <span class="comment">// 从元注解中被覆盖的属性名</span></span><br><span class="line">    <span class="keyword">return</span> (descriptor != <span class="literal">null</span> &amp;&amp; metaAnnotationType != <span class="literal">null</span> ?</span><br><span class="line">            descriptor.getAttributeOverrideName(metaAnnotationType) : <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取在提供的注解类型中通过 @AliasFor 声明的所有属性别名的映射。该映射由属性名称作为键，每个值代表别名属性的名称列表。空返回值意味着注解没有声明任何属性别名。</span></span><br><span class="line"><span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; <span class="title function_">getAttributeAliasMap</span><span class="params">(<span class="meta">@Nullable</span> Class&lt;? extends Annotation&gt; annotationType)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (annotationType == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyMap();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从缓存中获取</span></span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; map = attributeAliasesCache.get(annotationType);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 遍历属性方法</span></span><br><span class="line">    <span class="keyword">for</span> (Method attribute : getAttributeMethods(annotationType)) &#123;</span><br><span class="line">        <span class="comment">// 获取别名列表</span></span><br><span class="line">        List&lt;String&gt; aliasNames = getAttributeAliasNames(attribute);</span><br><span class="line">        <span class="keyword">if</span> (!aliasNames.isEmpty()) &#123;</span><br><span class="line">            map.put(attribute.getName(), aliasNames);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存入缓存</span></span><br><span class="line">    attributeAliasesCache.put(annotationType, map);</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取通过提供的注解属性的 @AliasFor 配置的别名属性的名称列表</span></span><br><span class="line"><span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getAttributeAliasNames</span><span class="params">(Method attribute)</span> &#123;</span><br><span class="line">    <span class="type">AliasDescriptor</span> <span class="variable">descriptor</span> <span class="operator">=</span> AliasDescriptor.from(attribute);</span><br><span class="line">    <span class="keyword">return</span> (descriptor != <span class="literal">null</span> ? descriptor.getAttributeAliasNames() : Collections.&lt;String&gt; emptyList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆盖属性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">overrideAttributes</span><span class="params">(<span class="meta">@Nullable</span> AnnotatedElement element, Annotation annotation,</span></span><br><span class="line"><span class="params">        AnnotationAttributes attributes, String sourceAttributeName, List&lt;String&gt; targetAttributeNames)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">adaptedValue</span> <span class="operator">=</span> getAdaptedValue(element, annotation, sourceAttributeName);</span><br><span class="line">    <span class="comment">// 遍历目标属性中的所有应被覆盖的属性（本尊+别名）</span></span><br><span class="line">    <span class="keyword">for</span> (String targetAttributeName : targetAttributeNames) &#123;</span><br><span class="line">        attributes.put(targetAttributeName, adaptedValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在代码的注释中我们留下过一个疑问，如果找到了第一个注解就立即返回，那么标注了多个 <code>@ComponentScan</code> 呢？当你 <code>Debug</code> 时，你会发现并没有走出现直接标注了 <code>@ComponentScan</code> 的处理，其实看到反编译后的代码你就知道了，多个 <code>@ComponentScan</code> 被合成了一个 <code>@ComponentScans</code>，甚至此时设置的三个 <code>basePackages</code> 都是生效的。在 <code>JDK 8</code> 引入的重复注解机制，并非一个语言层面上的改动，而是编译器层面的改动。在编译后，多个可重复注解 <code>@ComponentScan</code> 会被合并到一个容器注解 <code>@ComponentScans</code> 中。</p>
<blockquote>
<p>因此，“<code>@ComponentScan</code> 的配置会覆盖 <code>@SpringBootApplication</code> 关于包扫描的配置”这句话既对又不对，它在一个常见的个例上表现出的现象是对的，在更普遍的情况中以及本质上是错误的。你也许可以再根据一些情况罗列出类似的“<code>@ComponentScan</code> 使用规则”，但是如果你不明白背后的本质，那么这些只是一些死记硬背的陈述，甚至会带给你错误的认知。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 标注了两个 `@ComponentScan`，对编译后的字节码进行反编译</span></span><br><span class="line"><span class="meta">@SpringBootApplication(</span></span><br><span class="line"><span class="meta">    scanBasePackages = &#123;&quot;com.example&quot;&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@ComponentScans(&#123;@ComponentScan(</span></span><br><span class="line"><span class="meta">    basePackages = &#123;&quot;com.example.demo&quot;&#125;</span></span><br><span class="line"><span class="meta">), @ComponentScan(&#123;&quot;com&quot;&#125;)&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DemoApplication</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注解内的别名属性"><a href="#注解内的别名属性" class="headerlink" title="注解内的别名属性"></a>注解内的别名属性</h3><p><code>postProcess</code> 方法完成了组合注解的属性覆盖，可是对于 <code>@ComponentScan</code> 注解而言，它没有被 <code>postProcess</code> 方法处理，它又是如何做到设置 <code>basePackages</code> 等于设置 <code>value</code> 呢？其实这发生在后处理注解属性方法中，该方法会对注解中标注了 <code>@AliasFor</code> 的属性强制执行别名语义。通俗地讲，就是<strong>统一</strong>或<strong>校验</strong>互为别名的属性值，要么只设置了其中一个属性的值，其他别名属性会被赋值为相同的值，要么设置为相同的值，否则会报错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> AnnotationAttributes <span class="title function_">getMergedAnnotationAttributes</span><span class="params">(AnnotatedElement element,</span></span><br><span class="line"><span class="params">        String annotationName, <span class="type">boolean</span> classValuesAsString, <span class="type">boolean</span> nestedAnnotationsAsMap)</span> &#123;</span><br><span class="line">    <span class="comment">// 以 get 语义进行搜索（是指找到即终止搜索？）</span></span><br><span class="line">    <span class="type">AnnotationAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> searchWithGetSemantics(element, <span class="literal">null</span>, annotationName,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">MergedAnnotationAttributesProcessor</span>(classValuesAsString, nestedAnnotationsAsMap));</span><br><span class="line">    <span class="comment">// 后处理注解属性</span></span><br><span class="line">    AnnotationUtils.postProcessAnnotationAttributes(element, attributes, classValuesAsString, nestedAnnotationsAsMap);</span><br><span class="line">    <span class="keyword">return</span> attributes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">postProcessAnnotationAttributes</span><span class="params">(<span class="meta">@Nullable</span> Object annotatedElement,</span></span><br><span class="line"><span class="params">        <span class="meta">@Nullable</span> AnnotationAttributes attributes, <span class="type">boolean</span> classValuesAsString, <span class="type">boolean</span> nestedAnnotationsAsMap)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (attributes == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取 AnnotationAttributes 的注解类型（@ComponentScan）</span></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; annotationType = attributes.annotationType();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Track which attribute values have already been replaced so that we can short</span></span><br><span class="line">    <span class="comment">// circuit the search algorithms.</span></span><br><span class="line">    Set&lt;String&gt; valuesAlreadyReplaced = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!attributes.validated) &#123;</span><br><span class="line">        <span class="comment">// 校验 @AliasFor 配置</span></span><br><span class="line">        <span class="comment">// 获取别名映射</span></span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; aliasMap = getAttributeAliasMap(annotationType);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (String attributeName : aliasMap.keySet()) &#123;</span><br><span class="line">            <span class="comment">// 跳过已处理的</span></span><br><span class="line">            <span class="keyword">if</span> (valuesAlreadyReplaced.contains(attributeName)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> attributes.get(attributeName);</span><br><span class="line">            <span class="comment">// 属性是否已有值</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">valuePresent</span> <span class="operator">=</span> (value != <span class="literal">null</span> &amp;&amp; !(value <span class="keyword">instanceof</span> DefaultValueHolder));</span><br><span class="line">            <span class="comment">// 遍历属性的别名列表</span></span><br><span class="line">            <span class="keyword">for</span> (String aliasedAttributeName : aliasMap.get(attributeName)) &#123;</span><br><span class="line">                <span class="comment">// 跳过已处理的</span></span><br><span class="line">                <span class="keyword">if</span> (valuesAlreadyReplaced.contains(aliasedAttributeName)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 获取别名属性的值</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">aliasedValue</span> <span class="operator">=</span> attributes.get(aliasedAttributeName);</span><br><span class="line">                <span class="comment">// 别名属性是否已有值</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">aliasPresent</span> <span class="operator">=</span> (aliasedValue != <span class="literal">null</span> &amp;&amp; !(aliasedValue <span class="keyword">instanceof</span> DefaultValueHolder));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Something to validate or replace with an alias?</span></span><br><span class="line">                <span class="keyword">if</span> (valuePresent || aliasPresent) &#123;</span><br><span class="line">                    <span class="comment">// 如果属性已有值且别名属性也有值，校验是否相等</span></span><br><span class="line">                    <span class="keyword">if</span> (valuePresent &amp;&amp; aliasPresent) &#123;</span><br><span class="line">                        <span class="comment">// Since annotation attributes can be arrays, we must use ObjectUtils.nullSafeEquals().</span></span><br><span class="line">                        <span class="keyword">if</span> (!ObjectUtils.nullSafeEquals(value, aliasedValue)) &#123;</span><br><span class="line">                            <span class="type">String</span> <span class="variable">elementAsString</span> <span class="operator">=</span></span><br><span class="line">                                    (annotatedElement != <span class="literal">null</span> ? annotatedElement.toString() : <span class="string">&quot;unknown element&quot;</span>);</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigurationException</span>(String.format(</span><br><span class="line">                                    <span class="string">&quot;In AnnotationAttributes for annotation [%s] declared on %s, &quot;</span> +</span><br><span class="line">                                    <span class="string">&quot;attribute &#x27;%s&#x27; and its alias &#x27;%s&#x27; are declared with values of [%s] and [%s], &quot;</span> +</span><br><span class="line">                                    <span class="string">&quot;but only one is permitted.&quot;</span>, attributes.displayName, elementAsString,</span><br><span class="line">                                    attributeName, aliasedAttributeName, ObjectUtils.nullSafeToString(value),</span><br><span class="line">                                    ObjectUtils.nullSafeToString(aliasedValue)));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (aliasPresent) &#123;</span><br><span class="line">                        <span class="comment">// 复制别名属性的值给属性</span></span><br><span class="line">                        attributes.put(attributeName,</span><br><span class="line">                                adaptValue(annotatedElement, aliasedValue, classValuesAsString, nestedAnnotationsAsMap));</span><br><span class="line">                        valuesAlreadyReplaced.add(attributeName);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 复制属性的值给别名属性</span></span><br><span class="line">                        attributes.put(aliasedAttributeName,</span><br><span class="line">                                adaptValue(annotatedElement, value, classValuesAsString, nestedAnnotationsAsMap));</span><br><span class="line">                        valuesAlreadyReplaced.add(aliasedAttributeName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 校验完毕</span></span><br><span class="line">        attributes.validated = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 `value` 从 `DefaultValueHolder` 替换为原始的 `value`</span></span><br><span class="line">    <span class="keyword">for</span> (String attributeName : attributes.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (valuesAlreadyReplaced.contains(attributeName)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> attributes.get(attributeName);</span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> DefaultValueHolder) &#123;</span><br><span class="line">            value = ((DefaultValueHolder) value).defaultValue;</span><br><span class="line">            attributes.put(attributeName,</span><br><span class="line">                    adaptValue(annotatedElement, value, classValuesAsString, nestedAnnotationsAsMap));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>又是一篇在写之前自认心里有数，以为可以很快总结完，却不知不觉写了很久，也收获了很多的文章。在刚开始，我只是想接续分析 <code>@Configuration</code> 的思路补充关于 <code>@ComponentScan</code> 的内容，但是渐渐地我又想要回应心里的疑问，<code>@ComponentScan</code> 和 <code>@SpringBootApplication</code> 一起使用的问题的本质原因是什么？<code>Spring</code> 框架真的很好用，好用到你不用太关心背后的原理，好用到你有时候用一个本质上不太正确的结论“走遍天下却几乎不会遇到问题”。说实话，研究完也有点索然无味，尤其是花了这么多时间看自己很讨厌的关于解析的代码，只能说解开了一个卡点也算疏通了一口气，但是时间成本好大啊，得多看点能“面试”的技术啊！！！</p>
</blockquote>
<p>综上分析，<code>@SpringBootApplication</code> 的包扫描功能本质上还是 <code>@ComponentScan</code> 提供的，但是和常见的嵌套注解不同，检索 <code>@ComponentScan</code> 有一套独特的算法，导致 <code>@SpringBootApplication</code> 和 <code>@ComponentScan</code> 并非简单的叠加效果。</p>
<ul>
<li><code>Spring</code> 会先获取 <code>@ComponentScan</code> 的注解属性再获取 <code>@ComponentScans</code> 的注解属性</li>
<li>以 <code>@ComponentScan</code> 为例，只获取给定配置类上的注解层次结构中的<strong>第一个</strong> <code>@ComponentScan</code></li>
<li>先从直接标注的注解开始，再递归地搜索元注解，这一点决定了 <code>@ComponentScan</code> 优先级高于 <code>@SpringBootApplication</code></li>
<li>使用注解层次结构中较低级别的属性覆盖较高级别的同名（支持 <code>@AliasFor</code>）属性，这一点决定了 <code>@SpringBootApplication</code> 可以设置扫描路径</li>
<li>多个 <code>@ComponentScan</code> 在编译后隐式生成 <code>@ComponentScans</code>，这一点决定多个 <code>@ComponentScan</code> 彼此之间以及和 <code>@SpringBootApplication</code> 互不冲突</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Docker Compose 安装 ELK</title>
    <url>/2023/12/14/install-ELK-using-Docker-Compose/</url>
    <content><![CDATA[<p>印象里每次安装 <code>ElK</code> 组件的体验都不是很好，或多或少都遇到过奇奇怪怪的问题。本文几乎完全按照官方文档：<a href="https://www.elastic.co/cn/blog/getting-started-with-the-elastic-stack-and-docker-compose">Getting started with the Elastic Stack and Docker Compose: Part 1</a> 通过 <code>docker compose</code> 安装 <code>elasticsearch</code>、<code>kibana</code>、<code>metricbeat</code>、<code>filebeat</code> 和 <code>logstash</code>，但是移除了 <code>ssl</code> 相关的配置。你可以直接按照原文档进行安装，但是对照本文可以帮助你更快速地移除不需要的配置以及绕开可能踩到的坑。<br>此安装方式尽量<strong>使用环境变量代替编写配置文件</strong>，便于在备份和分享时将敏感信息留存在本地。本次安装时间为 <code>2023-12-14</code>，使用官方镜像，版本为 <code>8.11.2</code>。</p>
<span id="more"></span>

<blockquote>
<p>如果不考虑持久化配置，直接进入容器手动修改配置文件可能也很合适。</p>
</blockquote>
<p><strong>文件结构</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">├── .env</span><br><span class="line"></span><br><span class="line">├── docker-compose.yml</span><br><span class="line"></span><br><span class="line">├── filebeat.yml</span><br><span class="line"></span><br><span class="line">├── logstash.conf</span><br><span class="line"></span><br><span class="line">└── metricbeat.yml</span><br></pre></td></tr></table></figure>

<h2 id="环境文件"><a href="#环境文件" class="headerlink" title="环境文件"></a>环境文件</h2><p>我们可以在 <code>.env</code> 文件中定义一些准备传递给 <code>docker-compose</code> 文件的变量，比如密码、版本和端口号等等。</p>
<blockquote>
<p>将敏感或者重复使用的信息放在 <code>.env</code> 文件中，并在 <code>.gitignore</code> 文件中忽略该文件，就可以更方便地将 <code>docker-compose</code> 文件备份到 <code>GitHub</code> 或者分享给他人。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Project namespace (defaults to the current folder name if not set)</span><br><span class="line">#COMPOSE_PROJECT_NAME=myproject</span><br><span class="line"></span><br><span class="line"># &#x27;elastic&#x27; 用户的密码 (至少 6 字符)</span><br><span class="line">ELASTIC_PASSWORD=changeme</span><br><span class="line"></span><br><span class="line"># &#x27;kibana_system&#x27; 用户的密码 (至少 6 字符)</span><br><span class="line">KIBANA_PASSWORD=changeme</span><br><span class="line"></span><br><span class="line"># Elastic 产品的版本</span><br><span class="line">STACK_VERSION=8.11.2</span><br><span class="line"></span><br><span class="line"># 设置集群的名称</span><br><span class="line">CLUSTER_NAME=docker-cluster</span><br><span class="line"></span><br><span class="line"># Set to &#x27;basic&#x27; or &#x27;trial&#x27; to automatically start the 30-day trial</span><br><span class="line">LICENSE=basic</span><br><span class="line">#LICENSE=trial</span><br><span class="line"></span><br><span class="line"># Elasticsearch HTTP API 暴露的端口</span><br><span class="line">ES_PORT=9200</span><br><span class="line"></span><br><span class="line"># Kibana 暴露的端口</span><br><span class="line">KIBANA_PORT=5601</span><br><span class="line"></span><br><span class="line"># ES、KIBANA、LOGSTASH 的内存限制（byte），根据主机可用的内存增加或降低。</span><br><span class="line">ES_MEM_LIMIT=1073741824</span><br><span class="line">KB_MEM_LIMIT=1073741824</span><br><span class="line">LS_MEM_LIMIT=1073741824</span><br><span class="line"></span><br><span class="line"># 密钥（起先以为是可选的，其实后面会用到）</span><br><span class="line">ENCRYPTION_KEY=c34d38b3a14956121ff2170e5030b471551370178f43e5626eec58b04a30fae2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在官方文档中，使用了一个名为 <code>setup</code> 的容器，用于做一些前置准备工作，比如 <code>ssl</code> 相关的配置和账号密码的设置。以下因为不需要配置 <code>ssl</code> 所以不使用 <code>setup</code> 容器，<code>Kibana</code> 的账号密码另行手动设置。</p>
</blockquote>
<h2 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h2><p>在 <code>docker-compose.yml</code> 文件中添加 <code>ElasticSearch</code> 部分。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.8&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">elasticsearch:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">elasticsearch:8.11.1</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">elasticsearch</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;$&#123;ES_PORT&#125;:9200&#x27;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node.name=elasticsearch</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.name=$&#123;CLUSTER_NAME&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">discovery.type=single-node</span></span><br><span class="line">      <span class="comment"># 设置密码</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ELASTIC_PASSWORD=$&#123;ELASTIC_PASSWORD&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line">      <span class="comment"># 启用  X-Pack 必须登录</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">xpack.security.enabled=true</span></span><br><span class="line">      <span class="comment"># 关闭 ssl</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">xpack.security.http.ssl.enabled=false</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">xpack.security.transport.ssl.enabled=false</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">xpack.license.self_generated.type=$&#123;LICENSE&#125;</span></span><br><span class="line">    <span class="comment"># 限制内存</span></span><br><span class="line">    <span class="attr">mem_limit:</span> <span class="string">$&#123;ES_MEM_LIMIT&#125;</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">memlock:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">-1</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elasticsearch-data:/usr/share/elasticsearch/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elasticsearch-plugins:/usr/share/elasticsearch/plugins</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my-network</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="comment"># 健康检测：</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span></span><br><span class="line">        [</span><br><span class="line">          <span class="string">&quot;CMD-SHELL&quot;</span>,</span><br><span class="line">          <span class="string">&quot;curl -s http://localhost:9200 | grep -q &#x27;missing authentication credentials&#x27;&quot;</span>,</span><br><span class="line">        ]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">10s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">10s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">120</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">elasticsearch-data:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">elasticsearch-plugins:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span></span><br><span class="line">  <span class="comment"># kibana-data:</span></span><br><span class="line">  <span class="comment">#   driver: local</span></span><br><span class="line">  <span class="comment"># metricbeat-data:</span></span><br><span class="line">  <span class="comment">#   driver: local</span></span><br><span class="line">  <span class="comment"># filebeat-data:</span></span><br><span class="line">  <span class="comment">#   driver: local</span></span><br><span class="line">  <span class="comment"># logstash-data:</span></span><br><span class="line">  <span class="comment">#   driver: local</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">my-network:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="健康检测"><a href="#健康检测" class="headerlink" title="健康检测"></a>健康检测</h3><p>对 <code>Elasticsearch</code> 进行健康检测的方式是对其发起 <code>HTTP</code> 请求，在本示例中目标地址为 <code>http://localhost:9200</code>，因为启用了密码，因此返回结果里会带有 ‘missing authentication credentials’ 字样，成功匹配。</p>
<p>在官方文档中的示例是携带 <code>--cacert</code> 参数发起 <code>HTTPS</code> 请求：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -s --cacert config/certs/ca/ca.crt https://localhost:9200</span><br></pre></td></tr></table></figure>

<p>如果在后续启动时发现 <code>elasticsearch</code> 容器长时间处于 <code>waiting</code> 状态，不能转为 <code>healthy</code>：</p>
<ul>
<li>检查是不是写成 <code>https</code></li>
<li>手动执行命令查看返回结果是否符合期望，像我原先复制了 <code>Kibana</code> 中配置的测试命令，最后发现多了一个 <code>-I</code> 参数导致启动一直不能完成。</li>
</ul>
<h3 id="限制内存失败"><a href="#限制内存失败" class="headerlink" title="限制内存失败"></a>限制内存失败</h3><p>你可能会遇到以下警告：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">WARNING: Your kernel does not support cgroup swap limit. WARNING: Your</span><br><span class="line">kernel does not support swap limit capabilities. Limitation discarded.</span><br><span class="line">To prevent these messages, enable memory and swap accounting on your system. To enable these on system using GNU GRUB (GNU GRand Unified Bootloader), do the following.</span><br></pre></td></tr></table></figure>

<p>原因是系统默认未开启 <code>swap</code> 限制。开启后即使 <code>Docker</code> 未运行，内存和交换计算也会产生约 <code>1%</code> 的总可用内存的开销和 <code>10%</code> 的整体性能下降。开启方式如下：</p>
<ul>
<li>编辑配置文件 <code>sudo vim /etc/default/grub</code></li>
<li>设置 <code>GRUB_CMDLINE_LINUX=&quot;cgroup_enable=memory swapaccount=1</code></li>
<li><code>sudo update-grub</code></li>
<li>重启 <code>sudo reboot</code>（<strong>直接关闭虚拟机再启动似乎不能生效</strong>）</li>
</ul>
<h3 id="验证-Elasticsearch-启动成功"><a href="#验证-Elasticsearch-启动成功" class="headerlink" title="验证 Elasticsearch 启动成功"></a>验证 Elasticsearch 启动成功</h3><p>在启动后，访问 <code>http://localhost:9200/</code>，会弹出验证登录对话框，代表 <code>elasticsearch</code> 启动成功</p>
<div style="width:80%;margin:auto"><img src="/2023/12/14/install-ELK-using-Docker-Compose/Snipaste_2023-12-15_04-35-10.png" class="" title="ES 登录对话框"></div>

<p>输入账号密码后显示 <code>Elasticsearch</code> 信息，代表正常运行。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;elasticsearch&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;cluster_name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;docker-cluster&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;cluster_uuid&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;MlwsEv3-SYqGkm2B_uqg4Q&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;number&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;8.11.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build_flavor&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;default&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build_type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;docker&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build_hash&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;6f9ff581fbcde658e6f69d6ce03050f060d1fd0c&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build_date&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;2023-11-11T10:05:59.421038163Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build_snapshot&quot;</span> <span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;lucene_version&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;9.8.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;minimum_wire_compatibility_version&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;7.17.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;minimum_index_compatibility_version&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;7.0.0&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tagline&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;You Know, for Search&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h2><p>在 <code>docker-compose.yml</code> 文件中添加 <code>Kibana</code> 部分。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kibana:</span></span><br><span class="line">  <span class="comment"># 依赖于 elasticsearch，检测其健康状态</span></span><br><span class="line">  <span class="attr">depends_on:</span></span><br><span class="line">    <span class="attr">elasticsearch:</span></span><br><span class="line">      <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">&#x27;kibana:8.11.1&#x27;</span></span><br><span class="line">  <span class="attr">container_name:</span> <span class="string">kibana</span></span><br><span class="line">  <span class="attr">ports:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">$&#123;KIBANA_PORT&#125;:5601</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">SERVERNAME=kibana</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ELASTICSEARCH_HOSTS=http://elasticsearch:9200</span></span><br><span class="line">    <span class="comment"># Kibana 连接 Elasticsearch 的账号密码，不可用于登录</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ELASTICSEARCH_USERNAME=kibana_system</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ELASTICSEARCH_PASSWORD=$&#123;KIBANA_PASSWORD&#125;</span></span><br><span class="line">    <span class="comment"># 密钥</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">XPACK_SECURITY_ENCRYPTIONKEY=$&#123;ENCRYPTION_KEY&#125;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">XPACK_ENCRYPTEDSAVEDOBJECTS_ENCRYPTIONKEY=$&#123;ENCRYPTION_KEY&#125;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">XPACK_REPORTING_ENCRYPTIONKEY=$&#123;ENCRYPTION_KEY&#125;</span></span><br><span class="line">    <span class="comment"># 切换成中文</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">I18N_LOCALE=zh-CN</span></span><br><span class="line">  <span class="attr">mem_limit:</span> <span class="string">$&#123;KB_MEM_LIMIT&#125;</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">kibana-data:/usr/share/kibana/data</span></span><br><span class="line">  <span class="attr">networks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">my-network</span></span><br><span class="line">  <span class="comment"># 健康检测，发起 HTTP 请求，匹配返回结果中有指定字符串</span></span><br><span class="line">  <span class="attr">healthcheck:</span></span><br><span class="line">    <span class="attr">test:</span></span><br><span class="line">      [</span><br><span class="line">        <span class="string">&quot;CMD-SHELL&quot;</span>,</span><br><span class="line">        <span class="string">&quot;curl -s -I http://localhost:5601 | grep -q &#x27;HTTP/1.1 302 Found&#x27;&quot;</span>,</span><br><span class="line">      ]</span><br><span class="line">    <span class="attr">interval:</span> <span class="string">10s</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="string">10s</span></span><br><span class="line">    <span class="attr">retries:</span> <span class="number">120</span></span><br><span class="line">  <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br></pre></td></tr></table></figure>

<h3 id="设置-Kibana-密码"><a href="#设置-Kibana-密码" class="headerlink" title="设置 Kibana 密码"></a>设置 Kibana 密码</h3><p>配置的账号密码是给 <code>Kibana</code> 用于连接 <code>Elasticsearch</code> 的，并非用于登录 <code>Kibana</code> 的，也不可用于登录。<code>elastic</code> 的账号密码才是登录 <code>Kibana</code> 的账号密码。</p>
<p>在官方文档中，是通过 <code>setup</code> 容器完成 <code>kibana_system</code> 账号的密码设置，脚本中执行的命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -s -X POST --cacert config/certs/ca/ca.crt -u &quot;elastic:$&#123;ELASTIC_PASSWORD&#125;&quot; -H &quot;Content-Type: application/json&quot; https://es01:9200/_security/user/kibana_system/_password -d &quot;&#123;\&quot;password\&quot;:\&quot;$&#123;KIBANA_PASSWORD&#125;\&quot;&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>仿照脚本手动发起请求，设置 <code>kibana_system</code> 的密码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -s -X POST -u &quot;elastic:$&#123;ELASTIC_PASSWORD&#125;&quot; -H &quot;Content-Type: application/json&quot; http://localhost:9200/_security/user/kibana_system/_password -d &quot;&#123;\&quot;password\&quot;:\&quot;$&#123;KIBANA_PASSWORD&#125;\&quot;&#125;&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>你也可以进入容器使用 <code>elasticsearch-setup-passwords</code> 设置密码。</p>
</blockquote>
<h3 id="设置密钥"><a href="#设置密钥" class="headerlink" title="设置密钥"></a>设置密钥</h3><p>密钥部分如果不配置，会影响 <code>Kibana</code> 的功能使用：</p>
<ul>
<li><a href="https://www.elastic.co/guide/en/kibana/current/xpack-security-secure-saved-objects.html">Secure saved objects</a></li>
<li><a href="https://www.elastic.co/guide/en/kibana/current/kibana-encryption-keys.html">kibana-encryption-keys</a></li>
</ul>
<p>查看日志会看到以下报错信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[2023-12-14T18:02:17.493+00:00][ERROR][plugins.observabilityAIAssistant] Error: Unable to create actions client because the Encrypted Saved Objects plugin is missing encryption key. Please set xpack.encryptedSavedObjects.encryptionKey in the kibana.yml or use the bin/kibana-encryption-keys command.</span><br><span class="line">kibana         |     at getActionsClientWithRequest (/usr/share/kibana/node_modules/@kbn/actions-plugin/server/plugin.js:329:15)</span><br><span class="line">kibana         |     at Object.secureGetActionsClientWithRequest [as getActionsClientWithRequest] (/usr/share/kibana/node_modules/@kbn/actions-plugin/server/plugin.js:384:58)</span><br><span class="line">kibana         |     at handler (/usr/share/kibana/node_modules/@kbn/observability-ai-assistant-plugin/server/routes/connectors/route.js:25:65)</span><br><span class="line">kibana         |     at processTicksAndRejections (node:internal/process/task_queues:95:5)</span><br><span class="line">kibana         |     at wrappedHandler (/usr/share/kibana/node_modules/@kbn/server-route-repository/src/register_routes.js:57:13)</span><br><span class="line">kibana         |     at Router.handle (/usr/share/kibana/node_modules/@kbn/core-http-router-server-internal/src/router.js:154:30)</span><br><span class="line">kibana         |     at handler (/usr/share/kibana/node_modules/@kbn/core-http-router-server-internal/src/router.js:113:50)</span><br><span class="line">kibana         |     at exports.Manager.execute (/usr/share/kibana/node_modules/@hapi/hapi/lib/toolkit.js:60:28)</span><br><span class="line">kibana         |     at Object.internals.handler (/usr/share/kibana/node_modules/@hapi/hapi/lib/handler.js:46:20)</span><br><span class="line">kibana         |     at exports.execute (/usr/share/kibana/node_modules/@hapi/hapi/lib/handler.js:31:20)</span><br><span class="line">kibana         |     at Request._lifecycle (/usr/share/kibana/node_modules/@hapi/hapi/lib/request.js:371:32)</span><br><span class="line">kibana         |     at Request._execute (/usr/share/kibana/node_modules/@hapi/hapi/lib/request.js:281:9)</span><br></pre></td></tr></table></figure>

<p>你可以通过以下方式自己生成：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入 kibana 容器</span></span><br><span class="line">docker exec -it kibana bash</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行命令</span></span><br><span class="line">bin/kibana-encryption-keys generate</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Kibana is currently running with legacy OpenSSL providers enabled! For details and instructions on how to disable see https://www.elastic.co/guide/en/kibana/8.11/production.html#openssl-legacy-provider</span><br><span class="line">## Kibana Encryption Key Generation Utility</span><br><span class="line"></span><br><span class="line">The &#x27;generate&#x27; command guides you through the process of setting encryption keys for:</span><br><span class="line"></span><br><span class="line">xpack.encryptedSavedObjects.encryptionKey</span><br><span class="line">    Used to encrypt stored objects such as dashboards and visualizations</span><br><span class="line">    https://www.elastic.co/guide/en/kibana/current/xpack-security-secure-saved-objects.html#xpack-security-secure-saved-objects</span><br><span class="line"></span><br><span class="line">xpack.reporting.encryptionKey</span><br><span class="line">    Used to encrypt saved reports</span><br><span class="line">    https://www.elastic.co/guide/en/kibana/current/reporting-settings-kb.html#general-reporting-settings</span><br><span class="line"></span><br><span class="line">xpack.security.encryptionKey</span><br><span class="line">    Used to encrypt session information</span><br><span class="line">    https://www.elastic.co/guide/en/kibana/current/security-settings-kb.html#security-session-and-cookie-settings</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Already defined settings are ignored and can be regenerated using the --force flag.  Check the documentation links for instructions on how to rotate encryption keys.</span><br><span class="line">Definitions should be set in the kibana.yml used configure Kibana.</span><br><span class="line"></span><br><span class="line">Settings:</span><br><span class="line">xpack.encryptedSavedObjects.encryptionKey: 8bd58432fa60321fc44cd1953b0468b9</span><br><span class="line">xpack.reporting.encryptionKey: eb360c607b1643e1739fcf8d587b2d42</span><br><span class="line">xpack.security.encryptionKey: ffe9139e6955daaa6cff13050978c3e8</span><br></pre></td></tr></table></figure>

<h3 id="Kibana-未准备就绪"><a href="#Kibana-未准备就绪" class="headerlink" title="Kibana 未准备就绪"></a>Kibana 未准备就绪</h3><p>你可能访问 <code>Kibana</code> 时还会遇到 <code>Kibana server is not ready yet</code> 的报错信息，这次我在使用原先的 <code>bitnami</code> 的镜像时怎么都解决不了这个问题。可以参考<a href="https://zhuanlan.zhihu.com/p/641274429">Kibana 最常见的“启动报错”或“无法连接ES集群服务”的故障原因及解决方案汇总</a>，或者像我一样直接换镜像换版本试试。</p>
<blockquote>
<p>如果成功完成以上安装，几乎就没有硬坑了。<strong>以下部分是完全照搬官方文档</strong>，可以不安装。如果想要快速在视觉上有一些感受，也可以安装体验。</p>
</blockquote>
<h2 id="metricbeat"><a href="#metricbeat" class="headerlink" title="metricbeat"></a>metricbeat</h2><p>在 <code>docker-compose.yml</code> 文件中添加 <code>metricbeat</code> 部分。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">metricbeat:</span></span><br><span class="line">  <span class="attr">depends_on:</span></span><br><span class="line">    <span class="attr">elasticsearch:</span></span><br><span class="line">      <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br><span class="line">    <span class="attr">kibana:</span></span><br><span class="line">      <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">elastic/metricbeat:$&#123;STACK_VERSION&#125;</span></span><br><span class="line">  <span class="attr">container_name:</span> <span class="string">metricbeat</span></span><br><span class="line">  <span class="attr">user:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">metricbeat-data:/usr/share/metricbeat/data</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;./metricbeat.yml:/usr/share/metricbeat/metricbeat.yml:ro&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;/var/run/docker.sock:/var/run/docker.sock:ro&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;/sys/fs/cgroup:/hostfs/sys/fs/cgroup:ro&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;/proc:/hostfs/proc:ro&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;/:/hostfs:ro&quot;</span></span><br><span class="line">  <span class="attr">networks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">my-network</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ELASTIC_USER=elastic</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ELASTIC_PASSWORD=$&#123;ELASTIC_PASSWORD&#125;</span></span><br><span class="line">    <span class="comment"># 注意：改为 http</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ELASTIC_HOSTS=http://elasticsearch:9200</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">KIBANA_HOSTS=http://kibana:5601</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">LOGSTASH_HOSTS=http://logstash:9600</span></span><br></pre></td></tr></table></figure>

<h3 id="metricbeat-yml"><a href="#metricbeat-yml" class="headerlink" title="metricbeat.yml"></a>metricbeat.yml</h3><p>和官方文档相比，移除了 <code>ssl</code> 相关的配置。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">metricbeat.config.modules:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">$&#123;path.config&#125;/modules.d/*.yml</span></span><br><span class="line">  <span class="attr">reload.enabled:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">metricbeat.modules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">module:</span> <span class="string">elasticsearch</span></span><br><span class="line">  <span class="attr">xpack.enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">period:</span> <span class="string">10s</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">$&#123;ELASTIC_HOSTS&#125;</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">$&#123;ELASTIC_USER&#125;</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">$&#123;ELASTIC_PASSWORD&#125;</span></span><br><span class="line">  <span class="attr">ssl.enabled:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">module:</span> <span class="string">logstash</span></span><br><span class="line">  <span class="attr">xpack.enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">period:</span> <span class="string">10s</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">$&#123;LOGSTASH_HOSTS&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">module:</span> <span class="string">kibana</span></span><br><span class="line">  <span class="attr">metricsets:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">stats</span></span><br><span class="line">  <span class="attr">period:</span> <span class="string">10s</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">$&#123;KIBANA_HOSTS&#125;</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">$&#123;ELASTIC_USER&#125;</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">$&#123;ELASTIC_PASSWORD&#125;</span></span><br><span class="line">  <span class="attr">xpack.enabled:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">module:</span> <span class="string">docker</span></span><br><span class="line">  <span class="attr">metricsets:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;container&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;cpu&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;diskio&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;healthcheck&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;info&quot;</span></span><br><span class="line">    <span class="comment"># - &quot;image&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;memory&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;network&quot;</span></span><br><span class="line">  <span class="attr">hosts:</span> [<span class="string">&quot;unix:///var/run/docker.sock&quot;</span>]</span><br><span class="line">  <span class="attr">period:</span> <span class="string">10s</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">processors:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">add_host_metadata:</span> <span class="string">~</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">add_docker_metadata:</span> <span class="string">~</span></span><br><span class="line"></span><br><span class="line"><span class="attr">output.elasticsearch:</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">$&#123;ELASTIC_HOSTS&#125;</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">$&#123;ELASTIC_USER&#125;</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">$&#123;ELASTIC_PASSWORD&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="容器退出"><a href="#容器退出" class="headerlink" title="容器退出"></a>容器退出</h3><p>你可能会遇到 <code>metricbeat</code> 容器启动完毕就立即退出的问题，查看容器日志可知，<code>metricbeat.yml</code> 文件必须属于 <code>uid=0</code> 的用户或者 <code>root</code> 用户。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Exiting: error loading config file: config file (&quot;metricbeat.yml&quot;) must be owned by the user identifier (uid=0) or root</span><br></pre></td></tr></table></figure>

<p>执行命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chown root metricbeat.yml</span><br></pre></td></tr></table></figure>

<p>在修改完你可能会发现问题还是没有被解决，再次查看日志可知，<code>metricbeat.yml</code> 文件的权限必须为 “<code>-rw-rw-r--</code>“。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Exiting: error loading config file: config file (&quot;metricbeat.yml&quot;) can only be writable by the owner but the permissions are &quot;-rw-rw-r--&quot; (to fix the permissions use: &#x27;chmod go-w /usr/share/metricbeat/metricbeat.yml&#x27;)</span><br></pre></td></tr></table></figure>

<p>执行命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chmod 0644 metricbeat.yml</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong><code>filebeat.yml</code> 文件存在相同的问题，可以提前解决</strong>。</p>
</blockquote>
<p>前往“左侧菜单栏-&gt;Management-&gt;堆栈监测” 查看集群概览，<code>Kibana</code> 会提示可以使用开箱即用的规则。</p>
<div style="width:80%;margin:auto"><img src="/2023/12/14/install-ELK-using-Docker-Compose/Snipaste_2023-12-15_05-55-46.png" class="" title="集群概览"></div>

<h3 id="控制数据的增长速度"><a href="#控制数据的增长速度" class="headerlink" title="控制数据的增长速度"></a>控制数据的增长速度</h3><p>发现数据量增长有点快，感觉哪天不留神分配的存储空间就耗尽了。如果只是用于本地测试体验的话可以适当调大周期 <code>period: 10s</code>，效果明显。</p>
<div style="width:80%;margin:auto"><img src="/2023/12/14/install-ELK-using-Docker-Compose/Snipaste_2023-12-15_18-03-21.png" class="" title="降低数据的增长速度 metricbeat"></div>

<div style="width:80%;margin:auto"><img src="/2023/12/14/install-ELK-using-Docker-Compose/Snipaste_2023-12-15_18-09-20.png" class="" title="降低数据的增长速度 filebeat"></div>


<h2 id="filebeat"><a href="#filebeat" class="headerlink" title="filebeat"></a>filebeat</h2><p>在 <code>docker-compose.yml</code> 文件中添加 <code>filebeat</code> 部分。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">filebeat:</span></span><br><span class="line">  <span class="attr">depends_on:</span></span><br><span class="line">    <span class="attr">elasticsearch:</span></span><br><span class="line">      <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">elastic/filebeat:$&#123;STACK_VERSION&#125;</span></span><br><span class="line">  <span class="attr">container_name:</span> <span class="string">filebeat</span></span><br><span class="line">  <span class="attr">user:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">filebeat-data:/usr/share/filebeat/data</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;./filebeat_ingest_data/:/usr/share/filebeat/ingest_data/&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;./filebeat.yml:/usr/share/filebeat/filebeat.yml:ro&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;/var/lib/docker/containers:/var/lib/docker/containers:ro&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;/var/run/docker.sock:/var/run/docker.sock:ro&quot;</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ELASTIC_USER=elastic</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ELASTIC_PASSWORD=$&#123;ELASTIC_PASSWORD&#125;</span></span><br><span class="line">    <span class="comment"># 注意：改用 http</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ELASTIC_HOSTS=http://elasticsearch:9200</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">KIBANA_HOSTS=http://kibana:5601</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">LOGSTASH_HOSTS=http://logstash:9600</span></span><br><span class="line">  <span class="attr">networks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">my-network</span></span><br></pre></td></tr></table></figure>

<h3 id="filebeat-yaml"><a href="#filebeat-yaml" class="headerlink" title="filebeat.yaml"></a>filebeat.yaml</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">filebeat.inputs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">filestream</span></span><br><span class="line">  <span class="attr">id:</span> <span class="string">default-filestream</span></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ingest_data/*.log</span></span><br><span class="line"></span><br><span class="line"><span class="attr">filebeat.autodiscover:</span></span><br><span class="line">  <span class="attr">providers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">docker</span></span><br><span class="line">      <span class="attr">hints.enabled:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">processors:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">add_docker_metadata:</span> <span class="string">~</span></span><br><span class="line"></span><br><span class="line"><span class="attr">setup.kibana:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">$&#123;KIBANA_HOSTS&#125;</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">$&#123;ELASTIC_USER&#125;</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">$&#123;ELASTIC_PASSWORD&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">output.elasticsearch:</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">$&#123;ELASTIC_HOSTS&#125;</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">$&#123;ELASTIC_USER&#125;</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">$&#123;ELASTIC_PASSWORD&#125;</span></span><br><span class="line">  <span class="attr">ssl.enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>前往“左侧菜单栏-&gt;Observability-&gt;日志-&gt;Stream” 查看流式传输。</p>
<div style="width:80%;margin:auto"><img src="/2023/12/14/install-ELK-using-Docker-Compose/Snipaste_2023-12-15_05-59-47.png" class="" title="流式传输"></div>

<h2 id="logstash"><a href="#logstash" class="headerlink" title="logstash"></a>logstash</h2><p>在 <code>docker-compose.yml</code> 文件中添加 <code>logstash</code> 部分。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logstash:</span></span><br><span class="line">  <span class="attr">depends_on:</span></span><br><span class="line">    <span class="attr">elasticsearch:</span></span><br><span class="line">      <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br><span class="line">    <span class="attr">kibana:</span></span><br><span class="line">      <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">logstash:$&#123;STACK_VERSION&#125;</span></span><br><span class="line">  <span class="attr">container_name:</span> <span class="string">logstash</span></span><br><span class="line">  <span class="attr">user:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">logstash-data:/usr/share/logstash/data</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;./logstash_ingest_data/:/usr/share/logstash/ingest_data/&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;./logstash.conf:/usr/share/logstash/pipeline/logstash.conf:ro&quot;</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">xpack.monitoring.enabled=false</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ELASTIC_USER=elastic</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ELASTIC_PASSWORD=$&#123;ELASTIC_PASSWORD&#125;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ELASTIC_HOSTS=http://elasticsearch:9200</span></span><br><span class="line">  <span class="attr">networks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">my-network</span></span><br></pre></td></tr></table></figure>

<h3 id="logstash-conf"><a href="#logstash-conf" class="headerlink" title="logstash.conf"></a>logstash.conf</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  file &#123;</span><br><span class="line">    mode =&gt; &quot;tail&quot;</span><br><span class="line">    path =&gt; &quot;/usr/share/logstash/ingest_data/*&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    index =&gt; &quot;logstash-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class="line">    hosts =&gt; &quot;$&#123;ELASTIC_HOSTS&#125;&quot;</span><br><span class="line">    user =&gt; &quot;$&#123;ELASTIC_USER&#125;&quot;</span><br><span class="line">    password =&gt; &quot;$&#123;ELASTIC_PASSWORD&#125;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前往“左侧菜单栏-&gt;Analytics-&gt;Discover”，查看数据视图。</p>
<div style="width:80%;margin:auto"><img src="/2023/12/14/install-ELK-using-Docker-Compose/Snipaste_2023-12-15_06-03-42.png" class="" title="数据视图"></div>

<blockquote>
<p>每一次不顺利的安装都是一场折磨。</p>
</blockquote>
]]></content>
      <tags>
        <tag>docker</tag>
        <tag>elasticsearch</tag>
        <tag>kibana</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 类 Reference 的源码分析</title>
    <url>/2023/12/27/source-code-analysis-of-Java-class-Reference/</url>
    <content><![CDATA[<p>我们知道 <code>Java</code> 扩充了“引用”的概念，引入了软引用、弱引用和虚引用，它们都属于 <code>Reference</code> 类型，也都可以配合 <code>ReferenceQueue</code> 使用。你是否好奇常常被一笔带过的“<code>引用对象</code>的处理过程”？你是否在探究 <code>NIO</code> 堆外内存的自动释放时看到了 <code>Cleaner</code> 的关键代码但不太能梳理整个过程？你是否好奇在研究 <code>JVM</code> 时偶尔看到的 <code>Reference Handler</code> 线程？本文将分析 <code>Reference</code> 和 <code>ReferenceQueue</code> 的源码带你理解<code>引用对象</code>的工作机制。</p>
<span id="more"></span>

<blockquote>
<p>事实上，个人感觉在无相关前置知识的情况下，单纯看 <code>JDK</code> 的 <code>Java</code> 代码是没办法很好地理解<code>引用对象</code>是如何被添加到<code>引用队列</code>中的。因为 <code>Reference</code> 的 <code>pending</code> 字段的含义和赋值操作是隐藏在 <code>JVM</code> 的 <code>C++</code> 代码中，本文搁置了其中的细节，仅分析 <code>JDK</code> 中相关的 <code>Java</code> 代码。</p>
</blockquote>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><code>Reference</code> 是<code>引用对象</code>的抽象基类。此类定义了所有引用对象通用的操作。由于引用对象是与垃圾收集器密切合作实现的，因此该类可能无法直接子类化。</p>
<div style="width:70%;margin:auto"><img src="/2023/12/27/source-code-analysis-of-Java-class-Reference/Pasted%20image%2020231227230915.png" class="" title="Reference 相关类图"></div>

<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul>
<li><code>referent</code>: <code>引用对象</code>关联的对象</li>
<li><code>queue</code>: <code>引用对象</code>准备注册到的<code>引用队列</code></li>
</ul>
<p><code>Reference</code> 提供了两个构造函数，一个需要传入<code>引用队列</code>（<code>ReferenceQueue</code>），一个不需要。如果一个<code>引用对象</code>（<code>Reference</code>）注册到一个<code>引用队列</code>，在检测到关联对象有适当的可达性变化后，垃圾收集器将把该<code>引用对象</code>添加到该引用队列。</p>
<blockquote>
<p>“关联对象有适当的可达性变化”并不容易理解，在很多表述中它很容易被简化为“可以被回收”，但是同时我们又拥有另一条规则，即“一个对象是否可回收的判断依据是是否从 <code>Root</code> 对象可达”。在面对 <code>Reference</code> 的子类时，我们有种割裂感，好像一条和谐的规则出现了特殊条例。<a href="/2023/12/28/explore-the-Java-classes-Cleaner-and-Finalizer/" title="探索 Java 类 Cleaner 和 Finalizer">探索 Java 类 Cleaner 和 Finalizer</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Reference(T referent) &#123;</span><br><span class="line">    <span class="built_in">this</span>(referent, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Reference(T referent, ReferenceQueue&lt;? <span class="built_in">super</span> T&gt; queue) &#123;</span><br><span class="line">    <span class="built_in">this</span>.referent = referent;</span><br><span class="line">    <span class="comment">// ReferenceQueue.NULL 表示没有注册到引用队列</span></span><br><span class="line">    <span class="built_in">this</span>.queue = (queue == <span class="literal">null</span>) ? ReferenceQueue.NULL : queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><ul>
<li><code>referent</code>: <code>引用对象</code>关联的对象，<strong>该对象将被垃圾收集器特殊对待</strong>。我们很难直观地感受何谓“被垃圾收集器特殊对待”，它对应着“在检测到关联对象有适当的可达性变化后，垃圾收集器将把<code>引用对象</code>添加到该引用队列”。</li>
<li><code>queue</code>: <code>引用对象</code>注册到的<code>引用队列</code></li>
<li><code>next</code>: 用于指向下一个<code>引用对象</code>，当<code>引用对象</code>已经添加到<code>引用队列</code>中，<code>next</code> 指向<code>引用队列</code>中的下一个<code>引用对象</code></li>
<li><code>discovered</code>: 用于指向下一个<code>引用对象</code>，用于在全局的 <code>pending</code> 链表中，指向下一个待添加到<code>引用队列</code>的<code>引用对象</code></li>
</ul>
<div style="width:60%;margin:auto"><img src="/2023/12/27/source-code-analysis-of-Java-class-Reference/Pasted%20image%2020231227192404.png" class="" title="引用对象"></div>

<h4 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h4><blockquote>
<p>注意：<code>lock</code> 和 <code>pending</code> 是全局共享的。</p>
</blockquote>
<ul>
<li><code>lock</code>: 用于与垃圾收集器同步的对象，<strong>垃圾收集器必须在每个收集周期开始时获取此锁</strong>。因此至关重要的是持有此锁的任何代码必须尽快运行完，不分配新对象并避免调用用户代码。</li>
<li><code>pending</code>: 等待加入<code>引用队列</code>的<code>引用对象</code>链表。垃圾收集器将<code>引用对象</code>添加到 <code>pending</code> 链表中，而 <code>Reference-Handler</code> 线程将删除它们，并做清理或入队操作。<code>pending</code> 链表受上述 <code>lock</code> 对象的保护，并使用 <code>discovered</code> 字段来链接下一个元素。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Reference</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T referent;         <span class="comment">/* Treated specially by GC */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> ReferenceQueue&lt;? <span class="built_in">super</span> T&gt; queue;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line">    <span class="keyword">volatile</span> Reference next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">private</span> Reference&lt;T&gt; discovered;  <span class="comment">/* used by VM */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Lock</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Reference&lt;Object&gt; pending = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Reference</code> 其实可以理解为单链表中的一个节点，除了核心的 <code>referent</code> 和 <code>queue</code>，<code>next</code> 和 <code>discovered</code> 都用于指向下一个<code>引用对象</code>，只是分别用于两条不同的单链表上。</p>
</blockquote>
<p><code>pending</code> 链表：</p>
<div style="width:70%;margin:auto"><img src="/2023/12/27/source-code-analysis-of-Java-class-Reference/Pasted%20image%2020231227191324.png" class="" title="pending 链表"></div>

<p><code>ReferenceQueue</code>：</p>
<div style="width:70%;margin:auto"><img src="/2023/12/27/source-code-analysis-of-Java-class-Reference/Pasted%20image%2020231227191330.png" class="" title="ReferenceQueue"></div>

<h3 id="ReferenceHandler-线程"><a href="#ReferenceHandler-线程" class="headerlink" title="ReferenceHandler 线程"></a>ReferenceHandler 线程</h3><p>启动任意一个非常简单的 <code>Java</code> 程序，通过 <code>JVM</code> 相关的工具，比如 <code>JConsole</code>，你都能看到一个名为 <code>Reference Handler</code> 的线程。</p>
<div style="width:60%;margin:auto"><img src="/2023/12/27/source-code-analysis-of-Java-class-Reference/Snipaste_2023-12-27_19-41-19.png" class="" title="Reference-Handler 线程"></div>

<p><code>ReferenceHandler</code> 类本身的代码并不复杂。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReferenceHandler</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="comment">// 确保类已经初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">ensureClassInitialized</span><span class="params">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(clazz.getName(), <span class="literal">true</span>, clazz.getClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (Error) <span class="keyword">new</span> <span class="title class_">NoClassDefFoundError</span>(e.getMessage()).initCause(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 预加载和初始化 InterruptedException 和 Cleaner，以避免在 run 方法中懒加载发生内存不足时陷入麻烦（咱也不知道具体啥麻烦）</span></span><br><span class="line">        ensureClassInitialized(InterruptedException.class);</span><br><span class="line">        ensureClassInitialized(Cleaner.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ReferenceHandler(ThreadGroup g, String name) &#123;</span><br><span class="line">        <span class="built_in">super</span>(g, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// run 方法循环调用 tryHandlePending</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            tryHandlePending(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建线程并启动"><a href="#创建线程并启动" class="headerlink" title="创建线程并启动"></a>创建线程并启动</h4><p><code>Reference-Handler</code> 线程是通过静态代码块创建并启动的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 不断获取父线程组，直到最高的系统线程组</span></span><br><span class="line">    <span class="type">ThreadGroup</span> <span class="variable">tg</span> <span class="operator">=</span> Thread.currentThread().getThreadGroup();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">ThreadGroup</span> <span class="variable">tgn</span> <span class="operator">=</span> tg;</span><br><span class="line">            tgn != <span class="literal">null</span>;</span><br><span class="line">            tg = tgn, tgn = tg.getParent());</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceHandler</span>(tg, <span class="string">&quot;Reference Handler&quot;</span>);</span><br><span class="line">    <span class="comment">// 设置为最高优先级</span></span><br><span class="line">    handler.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">    <span class="comment">// 设置为守护线程</span></span><br><span class="line">    handler.setDaemon(<span class="literal">true</span>);</span><br><span class="line">    handler.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// provide access in SharedSecrets</span></span><br><span class="line">    <span class="comment">// 不懂，看到一个说法覆盖 JVM 的默认处理方式</span></span><br><span class="line">    SharedSecrets.setJavaLangRefAccess(<span class="keyword">new</span> <span class="title class_">JavaLangRefAccess</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryHandlePendingReference</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> tryHandlePending(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="run-处理逻辑"><a href="#run-处理逻辑" class="headerlink" title="run 处理逻辑"></a>run 处理逻辑</h4><p><code>run</code> 方法的核心处理逻辑。本质上，<code>ReferenceHandler</code> 线程将 <code>pending</code> 链表上的<code>引用对象</code>分发到各自注册的<code>引用队列</code>中。如果理解了 <code>Reference</code> 作为单链表节点的一面，这部分代码不难理解，反而是其中应对 <code>OOME</code> 的处理很值得关注，但更多的可能是看了个寂寞，不好重现问题并验证。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">tryHandlePending</span><span class="params">(<span class="type">boolean</span> waitForNotify)</span> &#123;</span><br><span class="line">    Reference&lt;Object&gt; r;</span><br><span class="line">    Cleaner c;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 加锁（和垃圾回收共用一个锁）</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 如果不为 null</span></span><br><span class="line">            <span class="keyword">if</span> (pending != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取头节点</span></span><br><span class="line">                r = pending;</span><br><span class="line">                <span class="comment">// instanceof 可能抛出 OutOfMemoryError，因此在把 r 从 pending 链表中移除前进行</span></span><br><span class="line">                <span class="comment">// 如果是 Cleaner 类型，进行类型转换，后续有特殊处理</span></span><br><span class="line">                c = r <span class="keyword">instanceof</span> Cleaner ? (Cleaner) r : <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 从 pending 链表移除 r</span></span><br><span class="line">                pending = r.discovered;</span><br><span class="line">                r.discovered = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 等待锁可能抛出 OutOfMemoryError，因为可能需要分配 exception 对象</span></span><br><span class="line">                <span class="keyword">if</span> (waitForNotify) &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// retry if waited</span></span><br><span class="line">                <span class="keyword">return</span> waitForNotify;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        <span class="comment">// 给其他线程 CPU 时间，以便它们能够丢弃一些存活的引用，然后通过 GC 回收一些空间</span></span><br><span class="line">        <span class="comment">// 还可以防止 CPU 密集运行以至于上面的“r instanceof Cleaner”在一段时间内持续抛出 OOME</span></span><br><span class="line">        Thread.<span class="keyword">yield</span>();</span><br><span class="line">        <span class="comment">// retry</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">        <span class="comment">// retry</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是 Cleaner 类型，快速清理并返回</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="literal">null</span>) &#123;</span><br><span class="line">        c.clean();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 Reference 对象关联了引用队列，则添加到队列</span></span><br><span class="line">    ReferenceQueue&lt;? <span class="built_in">super</span> Object&gt; q = r.queue;</span><br><span class="line">    <span class="keyword">if</span> (q != ReferenceQueue.NULL) q.enqueue(r);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关联对象和队列相关方法"><a href="#关联对象和队列相关方法" class="headerlink" title="关联对象和队列相关方法"></a>关联对象和队列相关方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- Referent accessor and setters -- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取关联对象</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.referent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理关联对象，该操作不会导致引用对象入队</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.referent = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Queue operations -- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断引用对象是否已入队，如果未关联引用队列，则返回 false</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEnqueued</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span>.queue == ReferenceQueue.ENQUEUED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将引用对象添加到其注册的引用队列中，该方法仅 Java 代码调用，JVM 不需要调用本方法可以直接进行入队操作（什么情况下？）</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">enqueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.queue.enqueue(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ReferenceQueue"><a href="#ReferenceQueue" class="headerlink" title="ReferenceQueue"></a>ReferenceQueue</h2><p><code>引用队列</code>，在检测到适当的可达性更改后，垃圾收集器将已注册的<code>引用对象</code>添加到该队列。</p>
<h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceQueue</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReferenceQueue</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一个不可入队的队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Null</span>&lt;S&gt; <span class="keyword">extends</span> <span class="title class_">ReferenceQueue</span>&lt;S&gt; &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="title function_">enqueue</span><span class="params">(Reference&lt;? extends S&gt; r)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用于表示一个引用对象没有注册到引用队列</span></span><br><span class="line">    <span class="keyword">static</span> ReferenceQueue&lt;Object&gt; NULL = <span class="keyword">new</span> <span class="title class_">Null</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 用于表示一个引用对象已经添加到引用队列</span></span><br><span class="line">    <span class="keyword">static</span> ReferenceQueue&lt;Object&gt; ENQUEUED = <span class="keyword">new</span> <span class="title class_">Null</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 锁对象</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Lock</span> &#123; &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lock</span>();</span><br><span class="line">    <span class="comment">// 头节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Reference&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; head = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 队列长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">queueLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><p><code>enqueue</code> 只能由 <code>Reference</code> 类调用。</p>
<p><code>引用对象</code>的 <code>queue</code> 字段可以表达<code>引用对象</code>的状态：</p>
<ul>
<li><code>NULL</code>：表示没有注册到<code>引用队列</code>或者已经从<code>引用队列</code>中移除</li>
<li><code>ENQUEUED</code>：表示已经添加到<code>引用队列</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">enqueue</span><span class="params">(Reference&lt;? extends T&gt; r)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="comment">// 检查引用对象的状态是否可以入队</span></span><br><span class="line">        ReferenceQueue&lt;?&gt; queue = r.queue;</span><br><span class="line">        <span class="keyword">if</span> ((queue == NULL) || (queue == ENQUEUED)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查注册的 queue 和调用的 queue 是否相同</span></span><br><span class="line">        <span class="keyword">assert</span> queue == <span class="built_in">this</span>;</span><br><span class="line">        <span class="comment">// 标记为已入队</span></span><br><span class="line">        r.queue = ENQUEUED;</span><br><span class="line">        <span class="comment">// 头插法，最后一个节点的 next 指向自身（为什么？）</span></span><br><span class="line">        r.next = (head == <span class="literal">null</span>) ? r : head;</span><br><span class="line">        head = r;</span><br><span class="line">        <span class="comment">// 队列长度加一</span></span><br><span class="line">        queueLength++;</span><br><span class="line">        <span class="keyword">if</span> (r <span class="keyword">instanceof</span> FinalReference) &#123;</span><br><span class="line">            sun.misc.VM.addFinalRefCount(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通知等待的线程</span></span><br><span class="line">        lock.notifyAll();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><p>轮询队列以查看是否有引用对象可用，如果存在可用的引用对象则将其从队列中删除并返回，否则该方法立即返回 <code>null</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Reference&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; poll() &#123;</span><br><span class="line">    <span class="comment">// 缩小锁的范围</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">return</span> reallyPoll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Reference&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; reallyPoll() &#123;</span><br><span class="line">    Reference&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; r = head;</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Reference&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; rn = r.next;</span><br><span class="line">        <span class="comment">// 因为尾节点的 next 指向自身</span></span><br><span class="line">        head = (rn == r) ? <span class="literal">null</span> : rn;</span><br><span class="line">        <span class="comment">// 标记为 NULL，避免再次入队</span></span><br><span class="line">        r.queue = NULL;</span><br><span class="line">        <span class="comment">// next 指向自己</span></span><br><span class="line">        r.next = r;</span><br><span class="line">        <span class="comment">// 队列长度减一</span></span><br><span class="line">        queueLength--;</span><br><span class="line">        <span class="keyword">if</span> (r <span class="keyword">instanceof</span> FinalReference) &#123;</span><br><span class="line">            sun.misc.VM.addFinalRefCount(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>出队操作提供了等待的选项。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从队列中移除下一个元素，阻塞直到有元素可用。</span></span><br><span class="line"><span class="keyword">public</span> Reference&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; remove() <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">return</span> remove(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队列中移除下一个元素，阻塞直到超时或有元素可用，timeout 以毫秒为单位。</span></span><br><span class="line"><span class="keyword">public</span> Reference&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; remove(<span class="type">long</span> timeout)</span><br><span class="line">    <span class="keyword">throws</span> IllegalArgumentException, InterruptedException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Negative timeout value&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        Reference&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; r = reallyPoll();</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="literal">null</span>) <span class="keyword">return</span> r;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> (timeout == <span class="number">0</span>) ? <span class="number">0</span> : System.nanoTime();</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            lock.wait(timeout);</span><br><span class="line">            r = reallyPoll();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="literal">null</span>) <span class="keyword">return</span> r;</span><br><span class="line">            <span class="comment">// 如果 timeout 大于 0</span></span><br><span class="line">            <span class="keyword">if</span> (timeout != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                <span class="comment">// 计算下一轮等待时间</span></span><br><span class="line">                timeout -= (end - start) / <span class="number">1000_000</span>;</span><br><span class="line">                <span class="comment">// 到时间直接返回 null</span></span><br><span class="line">                <span class="keyword">if</span> (timeout &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 更新开始时间</span></span><br><span class="line">                start = end;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="状态变化"><a href="#状态变化" class="headerlink" title="状态变化"></a>状态变化</h3><p><code>Reference</code> 实例（引用对象）可能处于四种内部状态之一：</p>
<ul>
<li><code>Active</code>: 新创建的实例处于 <code>Active</code> 状态，受到垃圾收集器的特殊处理。收集器在检测到<code>关联对象</code>的可达性变为适当状态后的一段时间，会将实例的状态更改为 <code>Pending</code> 或 <code>Inactive</code>，具体取决于实例在创建时是否注册到<code>引用队列</code>中。在前一种情况下，它还会将实例添加到待 <code>pending-Reference</code> 列表中。</li>
<li><code>Pending</code>: 实例处在 <code>pending-Reference</code> 列表中，等待 <code>Reference-Handler</code> 线程将其加入<code>引用队列</code>。未注册到<code>引用队列</code>的实例永远不会处于这种状态。</li>
<li><code>Enqueued</code>: 处在创建实例时注册到的<code>引用队列</code>中。当实例从引用队列中删除时，该实例将变为 <code>Inactive</code> 状态。未注册到<code>引用队列</code>的实例永远不会处于这种状态。</li>
<li><code>Inactive</code>: 没有进一步的操作。一旦实例变为 <code>Inactive</code> 状态，其状态将永远不会再改变。</li>
</ul>
<p><code>Reference</code> 实例（引用对象）的状态由 <code>queue</code> 和 <code>next</code> 字段共同表达：</p>
<ul>
<li><code>Active</code>: <code>(queue == ReferenceQueue || queue == ReferenceQueue.NULL) &amp;&amp; next == null</code></li>
<li><code>Pending</code>: <code>queue == ReferenceQueue &amp;&amp; next == this</code></li>
<li><code>Enqueued</code>: <code>queue == ReferenceQueue.ENQUEUED &amp;&amp; (next == Following || this)</code>（在队列末尾时，<code>next</code> 指向自身，目前没有体现出这么设计的必要性啊？）</li>
<li><code>Inactive</code>: <code>queue == ReferenceQueue.NULL &amp;&amp; next == this</code></li>
</ul>
<div style="width:70%;margin:auto"><img src="/2023/12/27/source-code-analysis-of-Java-class-Reference/Pasted%20image%2020231227235157.png" class="" title="Reference 相关类图"></div>

<h2 id="Reference-的子类"><a href="#Reference-的子类" class="headerlink" title="Reference 的子类"></a>Reference 的子类</h2><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://cloud.tencent.com/developer/article/1366147">你不可不知的Java引用类型之——Reference源码解析</a></li>
<li><a href="https://www.jianshu.com/p/9fd68714c366">Java引用类型之：Reference源码解析</a></li>
<li><a href="https://juejin.cn/post/6942026483489734693">JVM之Reference源码分析</a></li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized 锁机制的分析和验证</title>
    <url>/2023/12/19/analysis-and-verification-of-the-synchronized-lock-mechanism/</url>
    <content><![CDATA[<p>本文详细介绍了 <code>Java</code> 中 <code>synchronized</code> 锁的机制、存储结构、优化措施以及升级过程，并通过 <code>jol-core</code> 演示 <code>Mark Word</code> 的变化来验证锁升级的多个 <code>case</code>。</p>
<span id="more"></span>

<blockquote>
<p>待完善</p>
</blockquote>
<p>利用 <code>synchronized</code> 实现同步的基础：<code>Java</code> 中的每一个对象都可以作为锁。具体表现为以下 <code>3</code> 种形式。</p>
<ul>
<li>对于普通同步方法，锁是当前实例对象。</li>
<li>对于静态同步方法，锁是当前类的 <code>Class</code> 对象。</li>
<li>对于同步方法块，锁是 <code>synchronized</code> 括号里配置的对象。</li>
</ul>
<p>当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。</p>
<ul>
<li>在 <code>JVM</code> 层面，<code>synchronized</code> 锁是基于进入和退出 <code>Monitor</code> 来实现的，每一个对象都有一个 <code>Monitor</code> 与之相关联。</li>
<li>在字节码层面，同步方法块是使用 <code>monitorenter</code> 和 <code>monitorexit</code> 指令实现的，前者在编译后插入到同步方法块的开始位置，后者插入到同步方法块的结束位置和异常位置。</li>
</ul>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><blockquote>
<p>锁存在哪里呢？锁里面又会存储什么信息呢？</p>
</blockquote>
<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p><code>synchronized</code> 用的锁是存在 <code>Java</code> 对象头（<code>object header</code>）里的。如果对象是数组类型，则虚拟机用 <code>3</code> 字宽（<code>Word</code>）存储对象头，如果对象是非数组类型，则用 <code>2</code> 字宽存储对象头。在 <code>32</code> 位虚拟机中，<code>1</code> 字宽等于 <code>4</code> 字节，即 <code>32bit</code>。在 <code>64</code> 位虚拟机中，<code>1</code> 字宽等于 <code>8</code> 字节，即 <code>64bit</code>。</p>
<p><code>Java</code> 对象头的组成结构如下：</p>
<table>
<thead>
<tr>
<th>长度</th>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>32/64bit</code></td>
<td><code>Mark Word</code></td>
<td><strong>存储对象的 <code>hashCode</code> 或锁信息</strong></td>
</tr>
<tr>
<td><code>32/64bit</code></td>
<td><code>Class Metadata Address</code></td>
<td>存储指向对象类型数据的指针</td>
</tr>
<tr>
<td><code>32/64bit</code></td>
<td><code>Array length</code></td>
<td>数组的长度（如果当前对象是数组）</td>
</tr>
</tbody></table>
<h3 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h3><p><code>Java</code> 对象头里的 <code>Mark Word</code> 里默认存储对象的 <code>HashCode</code>，分代年龄和锁标记位。在运行期间，<code>Mark Word</code> 里存储的数据会随着锁标志位的变化而变化。<code>Mark Word</code> 可能变化为另外 <code>4</code> 种数据。</p>
<p>以 <code>32</code> 位虚拟机为例：</p>
<table>
  <tr>
    <th rowspan="2">锁状态</th>
    <th colspan="2">25bit</th>
    <th rowspan="2">4bit</th>
    <th>1bit</th>
    <th>2bit</th>
  </tr>
  <tr>
    <td>23bit</td>
    <td>2bit</td>
    <td>是否是偏向锁</td>
    <td>锁标志位</td>
  </tr>
  <tr>
    <td>无锁状态</td>
    <td colspan="2">对象的 hashCode</td>
    <td>对象分代年龄</td>
    <td>0</td>
    <td>01</td>
  </tr>
  <tr>
    <td>偏向锁</td>
    <td>线程 ID</td>
    <td>Epoch</td>
    <td>对象分代年龄</td>
    <td>1</td>
    <td>01</td>
  </tr>
  <tr>
    <td>轻量级锁</td>
    <td colspan="4">指向栈中锁记录的指针</td>
    <td>00</td>
  </tr>
  <tr>
    <td>重量级锁</td>
    <td colspan="4">指向互斥量（重量级锁）的指针</td>
    <td>10</td>
  </tr>
  <tr>
    <td>GC 标记</td>
    <td colspan="4">空</td>
    <td>11</td>
  </tr>
</table>

<p>以 <code>64</code> 位虚拟机为例：</p>
<table>
  <tr>
    <th rowspan="2">锁状态</th>
    <th colspan="2">56bit</th>
    <th>1bit</th>
    <th>4bit</th>
    <th>1bit</th>
    <th>2bit</th>
  </tr>
  <tr>
    <td>25bit</td>
    <td>31bit</td>
    <td>-</td>
    <td>-</td>
    <td>是否是偏向锁</td>
    <td>锁标志位</td>
  </tr>
  <tr>
    <td>无锁状态</td>
    <td>unused</td>
    <td>对象的 hashCode</td>
    <td>cms_free</td>
    <td>对象分代年龄</td>
    <td>0</td>
    <td>01</td>
  </tr>
  <tr>
    <td>偏向锁</td>
    <td  colspan="2">线程 ID(54bit) | Epoch(2bit)</td>
    <td>cms_free</td>
    <td>对象分代年龄</td>
    <td>1</td>
    <td>01</td>
  </tr>
  <tr>
    <td>轻量级锁</td>
    <td colspan="5">指向栈中锁记录的指针</td>
    <td>00</td>
  </tr>
  <tr>
    <td>重量级锁</td>
    <td colspan="5">指向互斥量（重量级锁）的指针</td>
    <td>10</td>
  </tr>
  <tr>
    <td>GC 标记</td>
    <td colspan="5">空</td>
    <td>11</td>
  </tr>
</table>

<blockquote>
<p>在上述表述中，很容易让人产生困惑的地方是 <code>hashCode</code> 和分代年龄是对象的固有属性，当 <code>Mark Word</code> 中存储的数据发生变化时，这些重要的数据去哪了？</p>
</blockquote>
<h3 id="内部结构可视化"><a href="#内部结构可视化" class="headerlink" title="内部结构可视化"></a>内部结构可视化</h3><p>“百闻不如一见”，<code>jol-core</code> 提供了打印对象内部结构的能力。</p>
<ol>
<li>添加依赖，新版本比旧版本打印结果的可读性更好<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;org.openjdk.jol.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>使用 <code>ClassLayout.parseInstance(objectExample).toPrintable()</code> 打印<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectInternalTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span> aByte;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> aInt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ObjectInternalTest</span> <span class="variable">objectInternalTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInternalTest</span>();</span><br><span class="line">        log.info(ClassLayout.parseInstance(objectInternalTest).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>打印结果：<code>mark|class|fields|alignment</code>。这样我们就能通过查看 <code>Mark Word</code> 的值更直观地确定当前锁的状态。<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">2023-12-23 20:21:02 - com.moralok.concurrency.ch2.ObjectExample object internals:</span><br><span class="line">OFF  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8        (object header: mark)     0x0000000000000001 (non-biasable; age: 0)</span><br><span class="line">  8   4        (object header: class)    0x00060828</span><br><span class="line"> 12   4    int ObjectExample.aInt        0</span><br><span class="line"> 16   1   byte ObjectExample.aByte       0</span><br><span class="line"> 17   7        (object alignment gap)    </span><br><span class="line">Instance size: 24 bytes</span><br><span class="line">Space losses: 0 bytes internal + 7 bytes external = 7 bytes total</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="指针压缩和-cms-free"><a href="#指针压缩和-cms-free" class="headerlink" title="指针压缩和 cms_free"></a>指针压缩和 cms_free</h3><p>注意到指向对象类型数据的指针仅 <code>4</code> 个字节，这是因为默认情况下 <code>JVM</code> 参数 <code>UseCompressedOops</code> 是启用的。</p>
<p><a href="https://hg.openjdk.org/jdk8/jdk8/hotspot/file/87ee5ee27509/src/share/vm/oops/markOop.hpp">markOop.hpp</a></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">|--------------------------------------------------------------------------------------------------------------|--------------------|</span><br><span class="line">|                                            Object Header (96 bits)                                           |        State       |</span><br><span class="line">|--------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">|                                  Mark Word (64 bits)                           |    Klass Word (32 bits)     |                    |</span><br><span class="line">|--------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">| unused:25 | identity_hashcode:31 | cms_free:1 | age:4 | biased_lock:1 | lock:2 |    OOP to metadata object   |       Normal       |</span><br><span class="line">|--------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">| thread:54 |       epoch:2        | cms_free:1 | age:4 | biased_lock:1 | lock:2 |    OOP to metadata object   |       Biased       |</span><br><span class="line">|--------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">|                         ptr_to_lock_record                            | lock:2 |    OOP to metadata object   | Lightweight Locked |</span><br><span class="line">|--------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">|                     ptr_to_heavyweight_monitor                        | lock:2 |    OOP to metadata object   | Heavyweight Locked |</span><br><span class="line">|--------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">|                                                                       | lock:2 |    OOP to metadata object   |    Marked for GC   |</span><br><span class="line">|--------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br></pre></td></tr></table></figure>

<p>使用 <code>-XX:-UseCompressedOops</code> 关闭指针压缩，指向对象类型数据的指针才会变回 <code>8</code> 个字节</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">|------------------------------------------------------------------------------------------------------------|--------------------|</span><br><span class="line">|                                            Object Header (128 bits)                                        |        State       |</span><br><span class="line">|------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">|                                  Mark Word (64 bits)                         |    Klass Word (64 bits)     |                    |</span><br><span class="line">|------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">| unused:25 | identity_hashcode:31 | unused:1 | age:4 | biased_lock:1 | lock:2 |    OOP to metadata object   |       Normal       |</span><br><span class="line">|------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">| thread:54 |       epoch:2        | unused:1 | age:4 | biased_lock:1 | lock:2 |    OOP to metadata object   |       Biased       |</span><br><span class="line">|------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">|                       ptr_to_lock_record:62                         | lock:2 |    OOP to metadata object   | Lightweight Locked |</span><br><span class="line">|------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">|                     ptr_to_heavyweight_monitor:62                   | lock:2 |    OOP to metadata object   | Heavyweight Locked |</span><br><span class="line">|------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">|                                                                     | lock:2 |    OOP to metadata object   |    Marked for GC   |</span><br><span class="line">|------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br></pre></td></tr></table></figure>

<p>你可能还会注意到开启和关闭指针压缩时，还有一个 <code>bit</code> 从 <code>cms_free</code> 变成 <code>unused</code>。这个 <code>cms_free</code> 是做什么用的呢？在未开启指针压缩的情况下，指针的低位因为内存对齐的缘故往往是 <code>0</code>，我们可以给这些 <code>bit</code> 设置 <code>1</code> 用于标记特殊状态。<code>CMS</code> 将 <code>Klass</code> 指针的最低位设置为 <code>1</code> 用于表示特定的内存块不是一个对象，而是空闲的内存。在开启指针压缩后，<code>JVM</code> 通过右移移除指针中没用到的低位，因此 <code>CMS</code> 需要一个地方存储这个表示是否为空闲内存的 <code>bit</code>，就是 <code>cms_free</code>。</p>
<blockquote>
<p>这在一定程度上解决了我心中的一个问题：<code>JVM</code> 是怎么判断一个空闲的内存块的？</p>
</blockquote>
<p><a href="https://hg.openjdk.org/jdk8/jdk8/hotspot/file/87ee5ee27509/src/share/vm/gc_implementation/concurrentMarkSweep/concurrentMarkSweepGeneration.cpp">concurrentMarkSweepGeneration.cpp</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A block of storage in the CMS generation is always in</span></span><br><span class="line"><span class="comment">// one of three states. A free block (FREE), an allocated</span></span><br><span class="line"><span class="comment">// object (OBJECT) whose size() method reports the correct size,</span></span><br><span class="line"><span class="comment">// and an intermediate state (TRANSIENT) in which its size cannot</span></span><br><span class="line"><span class="comment">// be accurately determined.</span></span><br><span class="line"><span class="comment">// STATE IDENTIFICATION:   (32 bit and 64 bit w/o COOPS)</span></span><br><span class="line"><span class="comment">// -----------------------------------------------------</span></span><br><span class="line"><span class="comment">// FREE:      klass_word &amp; 1 == 1; mark_word holds block size</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// OBJECT:    klass_word installed; klass_word != 0 &amp;&amp; klass_word &amp; 1 == 0;</span></span><br><span class="line"><span class="comment">//            obj-&gt;size() computes correct size</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// TRANSIENT: klass_word == 0; size is indeterminate until we become an OBJECT</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// STATE IDENTIFICATION: (64 bit+COOPS)</span></span><br><span class="line"><span class="comment">// ------------------------------------</span></span><br><span class="line"><span class="comment">// FREE:      mark_word &amp; CMS_FREE_BIT == 1; mark_word &amp; ~CMS_FREE_BIT gives block_size</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// OBJECT:    klass_word installed; klass_word != 0;</span></span><br><span class="line"><span class="comment">//            obj-&gt;size() computes correct size</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// TRANSIENT: klass_word == 0; size is indeterminate until we become an OBJECT</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>java -cp .\sa-jdi.jar sun.jvm.hotspot.HSDB</code> 开启 <code>HotSpot Debugger</code>，比对 <code>ClassLayout</code> 打印的 <code>Klass</code> 指针和 <code>Class Browser</code> 中的指针。</p>
<table>
<thead>
<tr>
<th>指针压缩</th>
<th>关闭</th>
<th>开启</th>
</tr>
</thead>
<tbody><tr>
<td>ClassLayout</td>
<td>0xf800c105</td>
<td>0x00000245eb873d20</td>
</tr>
<tr>
<td>二进制表达</td>
<td>11111000000000001100000100000101</td>
<td>00100100010111101011100001110011110100100000</td>
</tr>
<tr>
<td>HotSpot Debugger</td>
<td>0x00000007c0060828</td>
<td>0x00000245EB873D20</td>
</tr>
<tr>
<td>二进制表达</td>
<td>011111000000000001100000100000101000</td>
<td>00100100010111101011100001110011110100100000</td>
</tr>
</tbody></table>
<h3 id="对象分代年龄"><a href="#对象分代年龄" class="headerlink" title="对象分代年龄"></a>对象分代年龄</h3><p>通过以下示例可以测试和验证对象分代年龄的变化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    log.info(<span class="string">&quot;测试 Mark Word 中的分代年龄&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    log.info(<span class="string">&quot;Mark Word 初始为 =====&gt; 无锁状态，age: 0&quot;</span>);</span><br><span class="line">    log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line">    System.gc();</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    log.info(<span class="string">&quot;GC 后 =====&gt; 无锁状态，age: 1&quot;</span>);</span><br><span class="line">    log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p><code>Java 6</code> 为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，在 <code>Java 6</code> 中，锁一共有 <code>4</code> 种状态，级别从低到高依次是：<strong>无锁状态</strong>、<strong>偏向锁状态</strong>、<strong>轻量级锁状态</strong>和<strong>重量级锁状态</strong>，锁的状态会随着竞争的激化逐渐升级。<strong>锁状态可以升级但不能降级</strong>，举例来说偏向锁状态升级成轻量级锁状态后不能降级成偏向锁状态。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。</p>
<blockquote>
<p>上述的表述并不容易理解，甚至容易让人产生误解。锁状态描述的是锁本身的状态，和是否处于加锁状态无关。以下列表格举例说明，一个偏向锁状态的对象，即使未加锁，也是偏向锁状态，而非无锁状态。</p>
</blockquote>
<table>
<thead>
<tr>
<th>层次</th>
<th>未加锁</th>
<th>加锁</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>匿名偏向锁状态 or 偏向锁状态</td>
<td>偏向锁状态</td>
</tr>
<tr>
<td>2</td>
<td>无锁状态</td>
<td>轻量级锁状态</td>
</tr>
<tr>
<td>3</td>
<td>重要级锁状态</td>
<td>重要级锁状态</td>
</tr>
</tbody></table>
<blockquote>
<p>在查阅的众多资料中，关于锁升级过程的介绍并不详尽和准确，虽然大体上大家的观点是比较一致的，但是在一些细节的描述上却有些模糊不清，有些观点自相矛盾，有些观点互相矛盾，有些观点和我的知识或者测试结果矛盾，甚至有些逻辑不通顺以至于不能相互联系形成和谐的整体。以下内容尽可能结合相对权威和详细的资料，补充个人的思考和猜想作为缝合剂，并通过一些测试用例验证部分猜想，试图建立更加连续平滑以及可信服的知识面。</p>
</blockquote>
<h3 id="锁升级变化图"><a href="#锁升级变化图" class="headerlink" title="锁升级变化图"></a>锁升级变化图</h3><p>提前放出锁升级变化图，用于在后续分析和测试过程中对照查看。重点关注以下可能引起锁状态变化的事件：</p>
<ol>
<li>获取锁和释放锁</li>
<li>竞争，其中弱竞争是指线程交替进入同步块，没有发生直接冲突；强竞争是指线程在同步块内的时候有其他线程想要进入同步块</li>
<li>调用特殊方法，比如计算 <code>hashCode</code>（非自定义）或者 <code>wait</code> 方法</li>
</ol>
<div style="width:80%;margin:auto"><img src="/2023/12/19/analysis-and-verification-of-the-synchronized-lock-mechanism/Pasted%20image%2020231224002101.png" class="" title="锁升级变化图"></div>

<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p><code>HotSpot</code> 的作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。</p>
<p>偏向锁在 <code>Java 6</code> 之后是默认开启的，可以通过 <code>JVM</code> 参数 <code>-XX:-UseBiasedLocking</code> 关闭偏向锁。尽管偏向锁是默认开启的，但是它在应用程序启动几秒钟之后才激活，延迟时间可以通过 <code>JVM</code> 参数 <code>-XX:BiasedLockingStartupDelay</code> 设置，默认情况下是 <code>4000ms</code>。</p>
<h4 id="测试偏向锁配置"><a href="#测试偏向锁配置" class="headerlink" title="测试偏向锁配置"></a>测试偏向锁配置</h4><h5 id="延迟偏向"><a href="#延迟偏向" class="headerlink" title="延迟偏向"></a>延迟偏向</h5><p>通过以下示例测试并验证延迟偏向。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">    log.info(<span class="string">&quot;测试：偏向锁是延迟激活的&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    log.info(<span class="string">&quot;Mark Word 初始为 =====&gt; 无锁状态（非可偏向的）&quot;</span>);</span><br><span class="line">    log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认情况下偏向延迟的设置为 -XX:BiasedLockingStartupDelay=4000</span></span><br><span class="line">    log.info(<span class="string">&quot;sleep 4000ms，等待偏向锁激活&quot;</span>);</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">4000</span>);</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;偏向锁激活之后，新创建的对象的对象头的 Mark Word 是 =====&gt; 匿名偏向锁&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">biasedLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    log.info(ClassLayout.parseInstance(biasedLock).toPrintable());</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;偏向锁激活之前创建的对象的对象头的 Mark Word 仍然是 =====&gt; 无锁状态&quot;</span>);</span><br><span class="line">    log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">OFF  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8        (object header: mark)     0x0000000000000001 (non-biasable; age: 0)</span><br><span class="line"></span><br><span class="line">  0   8        (object header: mark)     0x0000000000000005 (biasable; age: 0)</span><br><span class="line"></span><br><span class="line">  0   8        (object header: mark)     0x0000000000000001 (non-biasable; age: 0)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>JVM</code> 启动后，<strong>偏向锁尚未激活前</strong>，创建的对象的 <code>Mark Word</code> 的末尾 <code>3</code> 位为 <code>0|01</code>，<code>non-biasable</code>，表示无锁状态（非可偏向的）。</li>
<li>在 <code>4000</code> 毫秒后，<strong>新创建</strong>的对象的 <code>Mark Word</code> 的末尾 <code>3</code> 位为 <code>1|01</code>，<code>biasable</code>，表示匿名偏向锁（可偏向的）。</li>
<li><strong>偏向锁尚未激活前</strong>创建的对象的对象头的 <code>Mark Word</code> 的末尾 <code>3</code> 位<strong>仍然</strong>是 <code>0|01</code>。</li>
</ul>
<blockquote>
<p>在虚拟机启动后，偏向锁激活前，创建的对象的锁标记位为 <code>1|01</code>，此时记录线程 <code>ID</code> 的 <code>bit</code> 全是 <code>0</code>（代表指向 <code>null</code>），没有偏向任何一个线程，该状态称之为匿名偏向锁。</p>
</blockquote>
<h5 id="关闭偏向延迟"><a href="#关闭偏向延迟" class="headerlink" title="关闭偏向延迟"></a>关闭偏向延迟</h5><p>通过以下示例测试关闭偏向延迟：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JVM 参数设置为 -XX:BiasedLockingStartupDelay=0</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">    log.info(<span class="string">&quot;测试：关闭偏向锁的延迟偏向&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    log.info(<span class="string">&quot;在虚拟机一启动，新创建的对象的对象头的 Mark Word 就是 =====&gt; 匿名偏向锁&quot;</span>);</span><br><span class="line">    log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="关闭偏向锁"><a href="#关闭偏向锁" class="headerlink" title="关闭偏向锁"></a>关闭偏向锁</h5><p>通过以下示例测试关闭偏向锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JVM 参数设置为 -XX:-UseBiasedLocking</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    log.info(<span class="string">&quot;测试：关闭偏向锁&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    log.info(<span class="string">&quot;Mark Word 初始为 =====&gt; 无锁状态（非可偏向的）&quot;</span>);</span><br><span class="line">    log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;sleep 4000ms&quot;</span>);</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">4000</span>);</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;即使过了偏向延迟时间，创建的对象的对象头的 Mark Word 仍然是 =====&gt; 无锁状态（非可偏向的）&quot;</span>);</span><br><span class="line">    log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>《Java 并发编程的艺术》中写的是 <code>-XX:-UseBiasedLocking=false</code>，测试中报错：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Error: Could not create the Java Virtual Machine.</span><br><span class="line">Error: A fatal exception has occurred. Program will exit.</span><br><span class="line">Improperly specified VM option &#x27;UseBiasedLocking=false&#x27;</span><br></pre></td></tr></table></figure>

<p>另外书中说“在关闭偏向锁后程序默认会进入轻量级锁状态”，个人认为可能会让人产生误解，默认在未获取锁时为无锁状态，获取锁将变为轻量级锁状态。</p>
<h4 id="偏向锁加锁"><a href="#偏向锁加锁" class="headerlink" title="偏向锁加锁"></a>偏向锁加锁</h4><p>当一个线程访问同步块时，先测试 <code>Mark Word</code> 里是否存储着当前线程 <code>ID</code>：</p>
<ul>
<li>如果否，则再测试 <code>Mark Word</code> 中偏向锁的标识是否设置成 <code>1</code><ul>
<li>如果为 <code>0</code>，则说明不是偏向锁状态 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; <em>获取偏向锁失败后续处理一</em></li>
<li>如果为 <code>1</code>，则说明是偏向锁状态，<strong>通过 <code>CAS</code> 操作设置偏向锁</strong><ul>
<li>如果成功，说明获得偏向锁</li>
<li>如果失败，说明发生竞争 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; <em>获取偏向锁失败后续处理二</em></li>
</ul>
</li>
</ul>
</li>
<li>如果是，则说明当前线程就是之前获得偏向锁的线程，此刻再次获得锁</li>
</ul>
<blockquote>
<p>在<strong>通过 <code>CAS</code> 操作设置偏向锁</strong>中，<code>Compare</code> 操作是“测试 <code>Mark Word</code> 存储线程 <code>ID</code> 的 <code>bit</code> 是否全部为 <code>0</code>，代表偏向的线程 <code>ID</code> 为 <code>null</code>”，<code>Swap</code> 操作是将当前线程 <code>ID</code> 设置到 <code>Mark Word</code> 的相应位置。</p>
</blockquote>
<p>补充思考：</p>
<ul>
<li>“通过 <code>CAS</code> 操作将当前线程 <code>ID</code> 设置到 <code>Mark Word</code>”在偏向锁状态下是有且仅有一次的“偏向”动作。（此观点存疑，在《Java 并发编程的艺术》一书中有“重新偏向于其他线程”这样的描述，但是关于竞争偏向锁部分的原理难以理解。个人在测试中，不论是持有偏向锁的线程仍存活但已离开同步块，还是已死亡，后续线程都无法再获取到偏向锁，唯一一种不同线程获取到同一个偏向锁的情况是两个线程可以复用同一个局部变量表槽位，它们的 <code>tid</code> 相同，这代表着本质上 <code>Mark Word</code> 并无变化）</li>
<li>当获得偏向锁的线程离开同步块时，没有“解锁操作”，<code>Mark Word</code> 维持不变。个人也不知道如何更准确地描述这个现象，从 <code>synchronized</code> 的语义来说，进出同步块代表着获取锁和释放锁；但是从偏向锁的实现来说，即便离开同步方法块，它仍然偏向原先获得锁的线程，甚至在讨论偏向锁发生竞争时，书中提到“检查持有偏向锁的线程是否存活”。个人更倾向于使用“撤销锁”一词描述偏向锁面临竞争时的处理，使用“释放锁”描述线程离开同步块时的处理。</li>
<li>当获得偏向锁的线程再次访问同步块时，简单测试 <code>Mark Word</code> 里存储着当前线程 <code>ID</code>，如果成功即可进入同步块。</li>
<li>计算过 <code>hashCode</code> 后偏向锁状态会变为其他状态，比如无锁状态，或者升级为轻量级锁甚至重量级锁，这符合 <code>CAS</code> 操作的判断条件。</li>
</ul>
<h4 id="偏向锁撤销"><a href="#偏向锁撤销" class="headerlink" title="偏向锁撤销"></a>偏向锁撤销</h4><p>偏向锁使用了一种等到竞争出现才撤销的机制，当获得偏向锁的线程离开同步块时，并没有“解锁操作”，<code>Mark Word</code> 将维持不变。当竞争出现时，从现象上说，如果持有偏向锁的线程已经离开同步块，则锁升级为轻量级锁；如果持有锁的线程尚未离开同步块，则锁直接升级为重量级锁。</p>
<blockquote>
<p>关于偏向锁的撤销，其原理晦涩难懂，个人仍有很多疑问：锁记录中存储偏向的线程 <code>ID</code> 的作用，检查持有偏向锁的线程是否存活的作用不符合测试结果，重新偏向于其他线程的复现条件。因为理解有限，不多赘述。</p>
</blockquote>
<h4 id="测试偏向锁升级"><a href="#测试偏向锁升级" class="headerlink" title="测试偏向锁升级"></a>测试偏向锁升级</h4><h5 id="匿名偏向锁-偏向锁"><a href="#匿名偏向锁-偏向锁" class="headerlink" title="匿名偏向锁-&gt;偏向锁"></a>匿名偏向锁-&gt;偏向锁</h5><blockquote>
<p>在一个匿名偏向锁状态的对象第一次被作为锁获取时，<code>Mark Word</code> 就会从匿名偏向锁变成偏向锁，并且再也不会变回到匿名偏向锁。</p>
</blockquote>
<p>测试在匿名偏向锁状态下获取锁将变成偏向锁状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">    log.info(<span class="string">&quot;偏向锁基础测试：匿名偏向锁 -&gt; 偏向锁&quot;</span>);</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;sleep 4000ms，等待偏向锁激活&quot;</span>);</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">4000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    log.info(<span class="string">&quot;Mark Word 初始为 =====&gt; 匿名偏向锁&quot;</span>);</span><br><span class="line">    log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125; 获取锁 =====&gt; 偏向锁&quot;</span>, Thread.currentThread().getName());</span><br><span class="line">        log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;暂停，输入任意字符回车继续，可以使用 jstack 查看线程 tid 和 Mark Word 进行对比&quot;</span>);</span><br><span class="line">        scanner.next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;偏向锁等到竞争出现才释放锁，因此离开同步方法块后，Mark Word 仍然不变&quot;</span>);</span><br><span class="line">    log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">2023-12-21 00:34:39 - 偏向锁基础测试：匿名偏向锁 -&gt; 偏向锁</span><br><span class="line">2023-12-21 00:34:39 - sleep 4000ms，等待偏向锁激活</span><br><span class="line">2023-12-21 00:34:43 - Mark Word 初始为 =====&gt; 匿名偏向锁</span><br><span class="line">2023-12-21 00:34:45 - java.lang.Object object internals:</span><br><span class="line">OFF  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8        (object header: mark)     0x0000000000000005 (biasable; age: 0)</span><br><span class="line">  8   4        (object header: class)    0xf80001e5</span><br><span class="line"> 12   4        (object alignment gap)    </span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="line"></span><br><span class="line">2023-12-21 00:34:45 - main 获取锁 =====&gt; 偏向锁</span><br><span class="line">2023-12-21 00:34:45 - java.lang.Object object internals:</span><br><span class="line">OFF  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8        (object header: mark)     0x0000028761af3005 (biased: 0x00000000a1d86bcc; epoch: 0; age: 0)</span><br><span class="line">  8   4        (object header: class)    0xf80001e5</span><br><span class="line"> 12   4        (object alignment gap)    </span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="line"></span><br><span class="line">2023-12-21 00:34:45 - 暂停，输入任意字符回车继续，可以使用 jstack 查看线程 tid 和 Mark Word 进行对比</span><br><span class="line">2023-12-21 00:34:55 - 偏向锁等到竞争出现才释放锁，因此离开同步方法块后，Mark Word 仍然不变</span><br><span class="line">2023-12-21 00:34:55 - java.lang.Object object internals:</span><br><span class="line">OFF  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8        (object header: mark)     0x0000028761af3005 (biased: 0x00000000a1d86bcc; epoch: 0; age: 0)</span><br><span class="line">  8   4        (object header: class)    0xf80001e5</span><br><span class="line"> 12   4        (object alignment gap)    </span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br></pre></td></tr></table></figure>

<p>通过 <code>jstack</code> 获取线程 <code>tid</code>（以 <code>Windows</code> 为例）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jps | findstr &quot;BiasedLockingBaseTest&quot; | ForEach-Object &#123; jstack $_.Split()[0]&#125; | findstr &quot;main&quot;</span><br><span class="line">&quot;main&quot; #1 prio=5 os_prio=0 tid=0x0000028761af3000 nid=0x8668 waiting on condition [0x000000ff7b8ff000]</span><br><span class="line">        at com.moralok.concurrency.ch2.BiasedLockingBaseTest.main(BiasedLockingBaseTest.java:27)</span><br></pre></td></tr></table></figure>

<p>关注 <code>Mark Word</code> 并转换为二进制表达：</p>
<table>
<thead>
<tr>
<th></th>
<th>二进制表达</th>
</tr>
</thead>
<tbody><tr>
<td>匿名偏向锁 <code>Mark Word</code></td>
<td>00000000000000000000000000000000000000000101</td>
</tr>
<tr>
<td>偏向锁状态 <code>Mark Word</code></td>
<td>00101000011101100001101011110011000000000101</td>
</tr>
<tr>
<td><code>biased</code></td>
<td>00000000000010100001110110000110101111001100</td>
</tr>
<tr>
<td><code>main</code> 线程 <code>tid</code></td>
<td>00101000011101100001101011110011000000000000</td>
</tr>
</tbody></table>
<ul>
<li><strong>注意</strong>：存储的所谓“线程 <code>ID</code>”并非平时所说的线程 <code>ID</code>，该值左移可以得到 <code>jstack</code> 的返回结果中的 <code>tid</code>，<code>jol-core</code> 打印了一个名为 <code>biased</code> 的值与之相同</li>
<li>在离开同步方法块后，<code>Mark Word</code> 不变</li>
</ul>
<h5 id="偏向锁-轻量级锁"><a href="#偏向锁-轻量级锁" class="headerlink" title="偏向锁-&gt;轻量级锁"></a>偏向锁-&gt;轻量级锁</h5><p>测试当拥有偏向锁的线程已经离开同步块，其他线程尝试获取偏向锁（弱竞争），锁将升级为轻量级锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    log.info(<span class="string">&quot;测试：当持有偏向锁的线程已经离开同步块，其他线程尝试获取偏向锁时，将获得轻量级锁&quot;</span>);</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;sleep 4000ms，等待偏向锁激活&quot;</span>);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    log.info(<span class="string">&quot;Mark Word 初始为 =====&gt; 匿名偏向锁&quot;</span>);</span><br><span class="line">    log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;第一个线程 &#123;&#125; 获取锁 =====&gt; 偏向锁&quot;</span>, Thread.currentThread().getName());</span><br><span class="line">        log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">&quot;第二个线程 &#123;&#125; 尝试获取锁&quot;</span>, Thread.currentThread().getName());</span><br><span class="line">        log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;第二个线程 &#123;&#125; 获取锁 =====&gt; 轻量级锁&quot;</span>, Thread.currentThread().getName());</span><br><span class="line">            log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">    thread.start();</span><br><span class="line">    thread.join();</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;离开同步块后轻量级锁释放 =====&gt; 无锁状态（可偏向的）&quot;</span>);</span><br><span class="line">    log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有相关资料提到在拥有偏向锁的线程死亡后，锁可以偏向新的线程，但是验证失败。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">    log.info(<span class="string">&quot;测试：之前获得偏向锁的线程已死时，新线程获得的仍然是偏向锁&quot;</span>);</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;sleep 4000ms，等待偏向锁激活&quot;</span>);</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">4000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    log.info(<span class="string">&quot;Mark Word 初始为 =====&gt; 匿名偏向锁&quot;</span>);</span><br><span class="line">    log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;第一个线程 &#123;&#125; 获取锁 =====&gt; 偏向锁&quot;</span>, Thread.currentThread().getName());</span><br><span class="line">            log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">    thread1.start();</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thread1.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">alive</span> <span class="operator">=</span> thread1.isAlive();</span><br><span class="line">        log.info(<span class="string">&quot;第一个线程 &#123;&#125; 是否存活 &#123;&#125;&quot;</span>, thread1.getName(), alive);</span><br><span class="line">        log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;即使第一个线程已死亡，第二个线程 &#123;&#125; 获取锁 =====&gt; 轻量级锁&quot;</span>, Thread.currentThread().getName());</span><br><span class="line">            log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;thread2&quot;</span>);</span><br><span class="line">    thread2.start();</span><br><span class="line">    thread2.join();</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;离开同步块后轻量级锁释放 =====&gt; 无锁状态（可偏向的）&quot;</span>);</span><br><span class="line">    log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="偏向锁-重量级锁"><a href="#偏向锁-重量级锁" class="headerlink" title="偏向锁-&gt;重量级锁"></a>偏向锁-&gt;重量级锁</h5><p>测试当拥有偏向锁的线程尚未离开同步块，其他线程尝试获取偏向锁（强竞争），锁将升级为重量级锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    log.info(<span class="string">&quot;测试：当持有偏向锁的线程尚未离开同步块，其他线程尝试获取偏向锁时，将升级为重量级锁&quot;</span>);</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;sleep 4000ms，等待偏向锁激活&quot;</span>);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    log.info(<span class="string">&quot;Mark Word 初始为 =====&gt; 匿名偏向锁&quot;</span>);</span><br><span class="line">    log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;第一个线程 &#123;&#125; 获取锁 =====&gt; 偏向锁&quot;</span>, Thread.currentThread().getName());</span><br><span class="line">            log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line"></span><br><span class="line">            log.info(<span class="string">&quot;暂停，输入任意字符回车继续&quot;</span>);</span><br><span class="line">            scanner.next();</span><br><span class="line"></span><br><span class="line">            log.info(<span class="string">&quot;第一个线程 &#123;&#125; 持有偏向锁，在同步块内发生竞争 =====&gt; 升级为重量级锁&quot;</span>, Thread.currentThread().getName());</span><br><span class="line">            log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;第一个线程 &#123;&#125; 结束&quot;</span>, Thread.currentThread().getName());</span><br><span class="line">    &#125;, <span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">    thread1.start();</span><br><span class="line"></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">&quot;第二个线程 &#123;&#125; 尝试获取偏向锁失败&quot;</span>, Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;第二个线程 &#123;&#125; 获取锁 =====&gt; 重量级锁&quot;</span>, Thread.currentThread().getName());</span><br><span class="line">            log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;thread2&quot;</span>);</span><br><span class="line">    thread2.start();</span><br><span class="line">    thread2.join();</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;即使离开同步块后 =====&gt; 重量级锁&quot;</span>);</span><br><span class="line">    log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="偏向锁-偏向锁（特例）"><a href="#偏向锁-偏向锁（特例）" class="headerlink" title="偏向锁-&gt;偏向锁（特例）"></a>偏向锁-&gt;偏向锁（特例）</h5><p>这是一个很奇怪的测试用例，它是在测试中唯一发生不同线程对同一个锁获得偏向锁的情况。但是排查过程中发现两个线程的 <code>tid</code> 相同，猜测是局部变量表槽位复用时有什么优化机制。</p>
<blockquote>
<p>卡了我好久，也没有探究到实质的新信息。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">    log.info(<span class="string">&quot;测试：之前获得偏向锁的线程已死时，新线程获得的仍然是偏向锁&quot;</span>);</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;sleep 4000ms，等待偏向锁激活&quot;</span>);</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">4000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    log.info(<span class="string">&quot;Mark Word 初始为 =====&gt; 匿名偏向锁&quot;</span>);</span><br><span class="line">    log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;第一个线程 &#123;&#125; 获取锁 =====&gt; 偏向锁&quot;</span>, Thread.currentThread().getName());</span><br><span class="line">            log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread1.join();</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;第二个线程 &#123;&#125; 获取锁，=====&gt; 偏向锁&quot;</span>, Thread.currentThread().getName());</span><br><span class="line">            log.info(<span class="string">&quot;震惊！！！为什么两个 tid 相同啊，有什么复用机制吗&quot;</span>);</span><br><span class="line">            log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;thread2&quot;</span>);</span><br><span class="line">    thread2.start();</span><br><span class="line">    thread2.join();</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;偏向锁等到竞争出现才释放锁，因此离开同步方法块后，Mark Word 不变&quot;</span>);</span><br><span class="line">    log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="匿名偏向锁状态计算-hashCode"><a href="#匿名偏向锁状态计算-hashCode" class="headerlink" title="匿名偏向锁状态计算 hashCode"></a>匿名偏向锁状态计算 hashCode</h5><p>在匿名偏向锁状态计算 <code>hashCode</code>，锁将变为无锁状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    log.info(<span class="string">&quot;测试：在匿名偏向锁状态计算 hashCode&quot;</span>);</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;sleep 4000ms，等待偏向锁激活&quot;</span>);</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">4000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    log.info(<span class="string">&quot;Mark Word 初始为 =====&gt; 匿名偏向锁&quot;</span>);</span><br><span class="line">    log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">hashCode</span> <span class="operator">=</span> lock.hashCode();</span><br><span class="line">    log.info(<span class="string">&quot;在计算 hashCode 后：Mark Word =====&gt; 无锁状态（hash|age|0|01）&quot;</span>);</span><br><span class="line">    log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;获取锁 =====&gt; 轻量级锁&quot;</span>);</span><br><span class="line">        log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;离开同步块后轻量级锁释放 =====&gt; 无锁状态（hash|age|0|01）&quot;</span>);</span><br><span class="line">    log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="偏向锁状态无锁时计算-hashCode"><a href="#偏向锁状态无锁时计算-hashCode" class="headerlink" title="偏向锁状态无锁时计算 hashCode"></a>偏向锁状态无锁时计算 hashCode</h5><p>在偏向锁状态无锁时计算 <code>hashCode</code>，锁将变为无锁状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    log.info(<span class="string">&quot;测试：在偏向锁状态无锁时计算 hashCode&quot;</span>);</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;sleep 4000ms，等待偏向锁激活&quot;</span>);</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">4000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    log.info(<span class="string">&quot;Mark Word 初始为 =====&gt; 匿名偏向锁&quot;</span>);</span><br><span class="line">    log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;获取锁 =====&gt; 偏向锁&quot;</span>);</span><br><span class="line">        log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">hashCode</span> <span class="operator">=</span> lock.hashCode();</span><br><span class="line">    log.info(<span class="string">&quot;离开同步块后再计算 hashCode：Mark Word =====&gt; 无锁状态&quot;</span>);</span><br><span class="line">    log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="偏向锁状态加锁时计算-hashCode"><a href="#偏向锁状态加锁时计算-hashCode" class="headerlink" title="偏向锁状态加锁时计算 hashCode"></a>偏向锁状态加锁时计算 hashCode</h5><p>在偏向锁状态加锁时计算 <code>hashCode</code>，锁将升级为重量级锁状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    log.info(<span class="string">&quot;测试：在偏向锁状态计算 hashCode&quot;</span>);</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;sleep 4000ms，等待偏向锁激活&quot;</span>);</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">4000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    log.info(<span class="string">&quot;Mark Word 初始为 =====&gt; 匿名偏向锁&quot;</span>);</span><br><span class="line">    log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;获取锁 =====&gt; 偏向锁&quot;</span>);</span><br><span class="line">        log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">hashCode</span> <span class="operator">=</span> lock.hashCode();</span><br><span class="line">        log.info(<span class="string">&quot;在计算 hashCode 后：Mark Word =====&gt; 重量级锁&quot;</span>);</span><br><span class="line">        log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;即使离开同步块后 =====&gt; 重量级锁&quot;</span>);</span><br><span class="line">    log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><h4 id="轻量级锁加锁"><a href="#轻量级锁加锁" class="headerlink" title="轻量级锁加锁"></a>轻量级锁加锁</h4><p>获取偏向锁失败后续处理一（是否是偏向锁为 <code>0</code>）：</p>
<ul>
<li>检测锁标志位是否为 <code>01</code> 或者 <code>00</code><ul>
<li>如果否，则说明是重量级锁状态 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; <em>获取轻量级锁失败后续处理一</em></li>
<li>如果是，则说明是无锁状态或者轻量级锁状态，尝试<strong>通过 <code>CAS</code> 操作设置轻量级锁</strong><ul>
<li>如果成功，说明获得轻量级锁</li>
<li>如果失败，说明发生竞争 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; <em>获取轻量级锁失败后续处理二</em></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>在<strong>通过 <code>CAS</code> 操作设置轻量级锁</strong>中，<code>Compare</code> 操作是“测试 <code>Mark Word</code> 的锁标志位是否为 <code>01</code>，代表处于无锁状态”，<code>Swap</code> 操作是将 <code>Mark Word</code> 复制到栈中锁记录，并将指向栈中锁记录的指针设置到 <code>Mark Word</code> 的相应位置以及修改锁标志位。所谓“栈中锁记录”又称为 <code>Displaced Mark Word</code>，<code>JVM</code> 会在当前线程的栈帧中创建用于存储锁记录的空间，用于在轻量级锁状态下临时存放 <code>Mark Word</code>。</p>
</blockquote>
<blockquote>
<p>在轻量级锁状态下，明确提及了锁记录的作用，但偏向锁状态下，提及锁记录却并未加以解释。</p>
</blockquote>
<p>获取偏向锁失败后续处理一：</p>
<ul>
<li>已经升级为重量级锁</li>
</ul>
<p>获取偏向锁失败后续处理二（通过 <code>CAS</code> 加偏向锁失败）：</p>
<ul>
<li>获取锁失败的线程将锁升级为重量级锁，修改 <code>Mark Word</code> 为<code>指向互斥量（重量级锁）的指针|10</code>（这个操作将影响到持有轻量级锁的线程的解锁）</li>
<li>线程阻塞，等待唤醒</li>
</ul>
<p>补充思考：</p>
<ul>
<li>有相关资料提及偏向锁并非直接升级到重量级锁，无法验证是否总是有轻量级锁作为中间状态</li>
<li>轻量级锁面临竞争时升级为重量级锁的过程相比于偏向锁面临竞争时的升级过程，更加容易理解，后者好多细节没有找到令人信服的答案。</li>
</ul>
<h4 id="轻量级锁解锁"><a href="#轻量级锁解锁" class="headerlink" title="轻量级锁解锁"></a>轻量级锁解锁</h4><p>轻量级锁解锁时，会通过 <code>CAS</code> 操作解锁，<code>Compare</code> 操作是“测试 <code>Mark Word</code> 的锁标志位是否为 <code>00</code>，代表处于轻量级锁状态，<code>Swap</code> 操作是将栈中锁记录 <code>Dispaced Mark Word</code> 替换回对象头的 <code>Mark Word</code> 以及修改锁标志位。<br>如果 <code>Compare</code> 操作失败，则代表发生竞争，此时锁已经被其他线程升级为重量级锁以及 <code>Mark Word</code> 被修改为<code>指向互斥量（重量级锁）的指针|10</code>。持有轻量级锁的线程会释放锁（直接将 <code>Dispaced Mark Word</code> 替换回 <code>Mark Word</code>？）并唤醒等待的线程，开启新的一轮争抢。</p>
<h4 id="测试轻量级锁升级"><a href="#测试轻量级锁升级" class="headerlink" title="测试轻量级锁升级"></a>测试轻量级锁升级</h4><h5 id="无锁-轻量级锁"><a href="#无锁-轻量级锁" class="headerlink" title="无锁-&gt;轻量级锁"></a>无锁-&gt;轻量级锁</h5><p>测试在无锁状态下获取锁，锁将变成轻量级锁状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    log.info(<span class="string">&quot;轻量级锁基础测试：无锁状态 -&gt; 轻量级锁&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    log.info(<span class="string">&quot;在偏向锁激活之前创建的对象为 =====&gt; 无锁状态（可偏向额）&quot;</span>);</span><br><span class="line">    log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;即使是单线程无竞争获取锁，=====&gt; 轻量级锁&quot;</span>);</span><br><span class="line">        log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line">        log.info(<span class="string">&quot;暂停，回车继续&quot;</span>);</span><br><span class="line">        scanner.nextLine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;离开同步块后，-&gt; 无锁状态（可偏向的）&quot;</span>);</span><br><span class="line">    log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="无锁状态计算-hashCode"><a href="#无锁状态计算-hashCode" class="headerlink" title="无锁状态计算 hashCode"></a>无锁状态计算 hashCode</h5><p>在无锁状态计算 <code>hashCode</code>，仍然是无锁状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    log.info(<span class="string">&quot;测试：在无锁状态计算 hashCode&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    log.info(<span class="string">&quot;Mark Word 初始为 =====&gt; 无锁状态&quot;</span>);</span><br><span class="line">    log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">hashCode</span> <span class="operator">=</span> lock.hashCode();</span><br><span class="line">    log.info(<span class="string">&quot;在计算 hashCode 后：Mark Word =====&gt; 无锁状态（hash|age|0|01）&quot;</span>);</span><br><span class="line">    log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;获取锁 =====&gt; 轻量级锁&quot;</span>);</span><br><span class="line">        log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;离开同步块后轻量级锁释放 =====&gt; 无锁状态（hash|age|0|01）&quot;</span>);</span><br><span class="line">    log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="轻量级锁加锁时计算-hashCode"><a href="#轻量级锁加锁时计算-hashCode" class="headerlink" title="轻量级锁加锁时计算 hashCode"></a>轻量级锁加锁时计算 hashCode</h5><p>在轻量级锁状态加锁时计算 <code>hashCode</code>，锁将升级为重量级锁状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    log.info(<span class="string">&quot;测试：在轻量级锁状态计算 hashCode&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    log.info(<span class="string">&quot;Mark Word 初始为 =====&gt; 无锁状态&quot;</span>);</span><br><span class="line">    log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;获取锁 =====&gt; 轻量级锁&quot;</span>);</span><br><span class="line">        log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">hashCode</span> <span class="operator">=</span> lock.hashCode();</span><br><span class="line">        log.info(<span class="string">&quot;在计算 hashCode 后：Mark Word =====&gt; 重量级锁&quot;</span>);</span><br><span class="line">        log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;即使离开同步块后 =====&gt; 重量级锁&quot;</span>);</span><br><span class="line">    log.info(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li>《Java 并发编程的艺术》</li>
<li><a href="https://www.cnblogs.com/FraserYu/p/15743542.html">难搞的偏向锁终于被 Java 移除了</a></li>
<li><a href="https://stackoverflow.com/questions/60985782/details-about-mark-word-of-java-object-header">Details about mark word of java object header</a></li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>lock</tag>
        <tag>synchronized</tag>
      </tags>
  </entry>
  <entry>
    <title>Unsafe，一个“反 Java”的 class</title>
    <url>/2023/12/25/Unsafe-an-anti-Java-class/</url>
    <content><![CDATA[<p><code>Unsafe</code> 类位于 <code>sun.misc</code> 包中，它提供了一组用于执行低级别、不安全操作的方法。尽管 <code>Unsafe</code> 类及其所有方法都是公共的，但它的使用受到限制，因为只有受信任的代码才能获取其实例。这个类通常被用于一些底层的、对性能敏感的操作，比如直接内存访问、<code>CAS</code>（<code>Compare and Swap</code>）操作等。本文将介绍这个“反 <code>Java</code>”的类及其方法的典型使用场景。</p>
<span id="more"></span>

<blockquote>
<p>由于 <code>Unsafe</code> 类涉及到直接内存访问和其他底层操作，使用它需要极大的谨慎，因为它可以绕过 <code>Java</code> 语言的一些安全性和健壮性检查。在正常的应用程序代码中，最好避免直接使用 <code>Unsafe</code> 类，以确保代码的可读性和可维护性。在一些特殊情况下，比如一些高性能库的实现，可能会使用 <code>Unsafe</code> 类来进行一些性能优化。</p>
</blockquote>
<blockquote>
<p>尽管在生产中需要谨慎使用 <code>Unsafe</code>，但是可以在测试中使用它来更真实地接触 <code>Java</code> 对象在内存中的存储结构，验证自己的理论知识。</p>
</blockquote>
<h2 id="获取-Unsafe-实例"><a href="#获取-Unsafe-实例" class="headerlink" title="获取 Unsafe 实例"></a>获取 Unsafe 实例</h2><blockquote>
<p>在 <code>Java 9</code> 及之后的版本中，<code>Unsafe</code> 类中的 <code>getUnsafe()</code> 方法被标记为不安全（<code>Unsafe</code>），不再允许普通的 <code>Java</code> 应用程序代码通过此方法获取 <code>Unsafe</code> 实例。这是为了提高 <code>Java</code> 的安全性，防止滥用 <code>Unsafe</code> 类的功能。</p>
</blockquote>
<p>在正常的 <code>Java</code> 应用程序中，获取 <code>Unsafe</code> 实例是不被推荐的，因为它违反了 <code>Java</code> 语言的安全性和封装原则。<code>Unsafe</code> 类的设计本意是为了 <code>Java</code> 库和虚拟机的实现使用，而不是为了普通应用程序开发者使用。<code>Unsafe</code> 对象为调用者提供了执行不安全操作的能力，它可用于在任意内存地址读取和写入数据，因此返回的 <code>Unsafe</code> 对象应由调用者仔细保护。它绝不能传递给不受信任的代码。此类中的大多数方法都是非常低级的，并且对应于少量硬件指令。</p>
<p>获取 <code>Unsafe</code> 实例的静态方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">    Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">    <span class="comment">// 检查调用方法的类是被引导类加载器所加载</span></span><br><span class="line">    <span class="keyword">if</span> (!VM.isSystemDomainLoader(caller.getClassLoader()))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(<span class="string">&quot;Unsafe&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> theUnsafe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Unsafe</code> 使用单例模式，可以通过静态方法 <code>getUnsafe</code> 获取 <code>Unsafe</code> 实例，并且调用方法的类为启动类加载器所加载才不会抛出异常。获取 <code>Unsafe</code> 实例有以下两种可行方案：</p>
<ol>
<li>通过 <code>-Xbootclasspath/a:$&#123;path&#125;</code> 把调用方法的类所在的 <code>jar</code> 包路径追加到启动类路径中，使该类被启动类加载器加载。关于启动类路径的信息可以参考<a href="https://www.moralok.com/2023/07/13/Java-class-loader-source-code-analysis/#ClassLoader-%E7%9A%84%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84">Java 类加载器源码分析 | ClassLoader 的搜索路径</a></li>
<li>通过反射获取 <code>Unsafe</code> 类中的 <code>Unsafe</code> 实例<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">        f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> (Unsafe) f.get(<span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="内存操作"><a href="#内存操作" class="headerlink" title="内存操作"></a>内存操作</h2><p><code>Unsafe</code> 类中包含了一些关于内存操作的方法，这些方法通常被认为是不安全的，因为它们可以绕过 <code>Java</code> 语言的内置安全性和类型检查。以下是一些常见的 <code>Unsafe</code> 类中关于内存操作的方法：</p>
<ul>
<li><code>allocateMemory</code>: 分配一个给定大小（以字节为单位）的本地内存块，内容未初始化，通常是垃圾。生成的本地指针永远不会为零，并且将针对所有类型进行对齐。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">allocateMemory</span><span class="params">(<span class="type">long</span> bytes)</span>;</span><br></pre></td></tr></table></figure></li>
<li><code>reallocateMemory</code>: 将本地内存块的大小调整为给定大小（以字节为单位），超过旧内存块大小的内容未初始化，通常是垃圾。当且仅当请求的大小为零时，生成的本地指针才为零。传递给此方法的地址可能为空，在这种情况下将执行分配。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">reallocateMemory</span><span class="params">(<span class="type">long</span> address, <span class="type">long</span> bytes)</span>;</span><br></pre></td></tr></table></figure></li>
<li><code>freeMemory</code>: 释放之前由 <code>allocateMemory</code> 或 <code>reallocateMemory</code> 分配的内存。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">freeMemory</span><span class="params">(<span class="type">long</span> address)</span>;</span><br></pre></td></tr></table></figure></li>
<li><code>setMemory</code>: 将给定内存块中的所有字节设置为固定值（通常为零）。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">setMemory</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">long</span> bytes, <span class="type">byte</span> value)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMemory</span><span class="params">(<span class="type">long</span> address, <span class="type">long</span> bytes, <span class="type">byte</span> value)</span> &#123;</span><br><span class="line">    setMemory(<span class="literal">null</span>, address, bytes, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>copyMemory</code>: 复制指定长度的内存块<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">copyMemory</span><span class="params">(Object srcBase, <span class="type">long</span> srcOffset, Object destBase, <span class="type">long</span> destOffset, <span class="type">long</span> bytes)</span>;</span><br></pre></td></tr></table></figure></li>
<li><code>putXxx</code>: 将指定偏移量处的内存设置为指定的值，其中 <code>Xxx</code> 可以是 <code>Object</code>、<code>int</code>、<code>long</code>、<code>float</code> 和 <code>double</code> 等。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">putObject</span><span class="params">(Object o, <span class="type">long</span> offset, Object x)</span>;</span><br></pre></td></tr></table></figure></li>
<li><code>getXxx</code>: 从指定偏移量处的内存读取值，其中 <code>Xxx</code> 可以是 <code>Object</code>、<code>int</code>、<code>long</code>、<code>float</code> 和 <code>double</code> 等。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title function_">getObject</span><span class="params">(Object o, <span class="type">long</span> offset)</span>;</span><br></pre></td></tr></table></figure></li>
<li><code>putXxx</code> 和 <code>getXxx</code> 也提供了按绝对基地址操作内存的方法。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">byte</span> <span class="title function_">getByte</span><span class="params">(<span class="type">long</span> address)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">putByte</span><span class="params">(<span class="type">long</span> address, <span class="type">byte</span> x)</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>从内存读取值时，除非满足以下情况之一，否则结果不确定：</p>
<ol>
<li>偏移量是通过 <code>objectFieldOffset</code> 从字段的 <code>Field</code> 对象获取的，<code>o</code> 指向的对象的类与字段所属的类兼容。</li>
<li>偏移量和 <code>o</code> 指向的对象（无论是否为 <code>null</code>）分别是通过 <code>staticFieldOffset</code> 和 <code>staticFieldBase</code> 从 <code>Field</code> 对象获得的。</li>
<li><code>o</code> 指向的是一个数组，偏移量是一个形式为 <code>B+N*S</code> 的整数，其中 <code>N</code> 是数组的有效索引，<code>B</code> 和 <code>S</code> 分别是通过 <code>arrayBaseOffset</code> 和 <code>arrayIndexScale</code> 获得的值。</li>
</ol>
<blockquote>
<p>做一些“不确定”的测试，比如使用 <code>byte</code> 相关的方法操作 <code>int</code> 所在的内存块，是有意思且有帮助的，了解如何破坏，也可以更好地学习如何保护。</p>
</blockquote>
<h3 id="分配堆外内存"><a href="#分配堆外内存" class="headerlink" title="分配堆外内存"></a>分配堆外内存</h3><p>在 <code>Java NIO</code>（<code>New I/O</code>）中，分配堆外内存使用了 <code>Unsafe</code> 类的 <code>allocateMemory</code> 方法。堆外内存是一种在 <code>Java</code> 虚拟机之外分配的内存，它不受 <code>Java</code> 堆内存管理机制的控制。这种内存分配的主要目的是提高 <code>I/O</code> 操作的性能，因为它可以直接与底层操作系统进行交互，而不涉及 <code>Java</code> 堆内存的复杂性。Java 虚拟机的垃圾回收器虽然不直接管理这块内存，但是它通过一种称为“引用清理”（<code>Reference Counting</code>）的机制来处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DirectByteBuffer(<span class="type">int</span> cap) &#123;</span><br><span class="line">    <span class="built_in">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">pa</span> <span class="operator">=</span> VM.isDirectMemoryPageAligned();</span><br><span class="line">    <span class="type">int</span> <span class="variable">ps</span> <span class="operator">=</span> Bits.pageSize();</span><br><span class="line">    <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> Math.max(<span class="number">1L</span>, (<span class="type">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line">    Bits.reserveMemory(size, cap);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 分配本地内存</span></span><br><span class="line">        base = unsafe.allocateMemory(size);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化本地内存</span></span><br><span class="line">    unsafe.setMemory(base, size, (<span class="type">byte</span>) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// Round up to page boundary</span></span><br><span class="line">        address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用虚引用 Cleaner 对象跟踪 DirectByteBuffer 对象的垃圾回收</span></span><br><span class="line">    cleaner = Cleaner.create(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">Deallocator</span>(base, size, cap));</span><br><span class="line">    att = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 <code>DirectByteBuffer</code> 对象仅被 <code>Cleaner</code> 对象（虚引用）引用时，它可以在任意一次 <code>GC</code> 中被垃圾回收。在 <code>DirectByteBuffer</code> 对象被垃圾回收后，<code>Cleaner</code> 对象会被加入到引用队列，<code>ReferenceHandler</code> 线程将调用 <code>Deallocator</code> 对象的 <code>run</code> 方法，从而实现本地内存的自动释放。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Deallocator</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> address;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Deallocator</span><span class="params">(<span class="type">long</span> address, <span class="type">long</span> size, <span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="keyword">assert</span> (address != <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (address == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Paranoia</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放本地内存</span></span><br><span class="line">        unsafe.freeMemory(address);</span><br><span class="line">        address = <span class="number">0</span>;</span><br><span class="line">        Bits.unreserveMemory(size, capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CAS-相关"><a href="#CAS-相关" class="headerlink" title="CAS 相关"></a>CAS 相关</h2><p><code>Unsafe</code> 提供了 <code>3</code> 个 <code>CAS</code> 相关操作的方法，方法将内存位置的值与预期原值比较，如果相匹配，则 <code>CPU</code> 会自动将该位置更新为新值，否则，<code>CPU</code> 不做任何操作。这些方法的底层实现对应着 <code>CPU</code> 指令 <code>cmpxchg</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果 Java 变量当前符合预期，则自动将其更新为 x。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapObject</span><span class="params">(Object o, <span class="type">long</span> offset, Object expected, Object x)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">int</span> expected, <span class="type">int</span> x)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapLong</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">long</span> expected, <span class="type">long</span> x)</span>;</span><br></pre></td></tr></table></figure>

<p>在 <code>AtomicInteger</code> 的实现中，静态字段 <code>valueOffset</code> 即为字段 <code>value</code> 的内存偏移地址，<code>valueOffset</code> 的值在 <code>AtomicInteger</code> 初始化时，在静态代码块中通过 <code>Unsafe</code> 的 <code>objectFieldOffset</code> 方法获取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicInteger</span> <span class="keyword">extends</span> <span class="title class_">Number</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">6214790243416807050L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CAS 更新变量的值的内存变化如下：</p>
<div style="width:80%;margin:auto"><img src="/2023/12/25/Unsafe-an-anti-Java-class/Pasted%20image%2020231226005107.png" class="" title="CAS 更新变量的值"></div>

<p>配合 <code>ClassLayout</code> 打印 <code>AtomicInteger</code> 的内部结构更直观地感受 <code>offset</code> 的含义：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">java.util.concurrent.atomic.AtomicInteger object internals:</span><br><span class="line">OFF  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8        (object header: mark)     0x0000000000000001 (non-biasable; age: 0)</span><br><span class="line">  8   4        (object header: class)    0xf8003dbc</span><br><span class="line"> 12   4    int AtomicInteger.value       1</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br></pre></td></tr></table></figure>



<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html">Java魔法类：Unsafe应用解析</a></li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>探索 Java 类 Cleaner 和 Finalizer</title>
    <url>/2023/12/28/explore-the-Java-classes-Cleaner-and-Finalizer/</url>
    <content><![CDATA[<p><code>Java</code> 类 <code>Cleaner</code> 和 <code>Finalizer</code> 都实现了一种 <code>finalization</code> 机制，前者更轻量和强大，你可能在了解 <code>NIO</code> 的堆外内存自动释放机制中注意过它；后者为人所诟病，<code>finalize</code> 方法被人强烈反对使用。本文想要解析它们的原因不在于它们实现的功能，而在于它们是 <code>Reference</code> 的具体子类。<br><code>Reference</code> 作为和 <code>GC</code> 紧密联系的类，你可能从很多文字描述中了解过 <code>SoftReference</code>、<code>WeakReference</code> 还有 <code>PhantomReference</code> 但是却很少从代码层面了解过它们，当你牢记“一个对象是否可以被回收的判断依据是它是否从 <code>Root</code> 对象可达”这条规则再面对 <code>Reference</code> 的子类时是否产生过割裂感；你是否好奇过 <code>Finalizer</code> 如何和重写 <code>finalize</code> 方法的类产生联系，本文将从 <code>Cleaner</code> 和 <code>Finalizer</code> 的源码揭示一些你可能已知的结论背后的朴素原理。</p>
<span id="more"></span>

<blockquote>
<p>本文的写作动机继承自 <a href="/2023/12/27/source-code-analysis-of-Java-class-Reference/" title="Java 类 Reference 的源码分析">Java 类 Reference 的源码分析</a>，有时候也会自我怀疑研究一个涉及大家极力劝阻使用的 <code>finalize</code> 是否浪费精力，只能说确实如此！要不是半途而废会膈应难受肯定就停了！只能说这个过程确实帮助自己对 <code>Java</code> 引用和 <code>GC</code> 对其的处理有更加深刻的理解。</p>
</blockquote>
<h2 id="虚引用之-Cleaner"><a href="#虚引用之-Cleaner" class="headerlink" title="虚引用之 Cleaner"></a>虚引用之 Cleaner</h2><h3 id="虚引用介绍"><a href="#虚引用介绍" class="headerlink" title="虚引用介绍"></a>虚引用介绍</h3><p><code>PhantomReference</code> 对象在垃圾收集器确定其<code>关联对象</code>可以被回收时或可以被回收后一段时间，将被入队。“可以被回收”更明确的描述是“虚引用的<code>关联对象</code>变成 <strong><code>phantom reachable</code></strong> ，即只有虚引用引用了它”。但是和软引用和弱引用不同，<strong>当虚引用入队时并不会被垃圾收集器自动清理（其关联对象）</strong>。一个 <code>phantom reachable</code> 的对象会一直维持原样直到所有虚引用被清理或者它们自身变得不可达。</p>
<p><code>PhantomReference</code> 的代码非常简单：</p>
<ol>
<li><code>PhantomReference</code> 仅提供了一个 <code>public</code> 构造函数，必须提供 <code>ReferenceQueue</code> 参数。它不像 <code>SoftReference</code> 和 <code>WeakReference</code> 可以离开 <code>ReferenceQueue</code> 单独使用，尽管 <code>queue</code> 可以为 <code>null</code>，但是这样做并没有意义。</li>
<li><code>get()</code> 返回 <code>null</code>，这意味着不能通过 <code>PhantomReference</code> 获取其关联的对象 <code>referent</code>。</li>
</ol>
<blockquote>
<p><code>get()</code> 返回 <code>null</code> 并不是可以随意忽略的事情，它保证了 <code>phantom reachable</code> 对象不会被重新触达和修改（这是为清理工作留出时间吗）。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhantomReference</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Reference</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PhantomReference</span><span class="params">(T referent, ReferenceQueue&lt;? <span class="built_in">super</span> T&gt; q)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(referent, q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以下示例验证 <code>GC</code> 不会自动清理虚引用的关联对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">100</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    ReferenceQueue&lt;<span class="type">byte</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">    PhantomReference&lt;<span class="type">byte</span>[]&gt; phantomReference = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(bytes, queue);</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Reference&lt;? <span class="keyword">extends</span> <span class="title class_">byte</span>[]&gt; remove = queue.remove(<span class="number">0</span>);</span><br><span class="line">                System.out.println(remove + <span class="string">&quot; enqueued&quot;</span>);</span><br><span class="line">                <span class="comment">// 需要调用 clear 主动清理关联对象，可以验证 gc 后总堆内存占用下降</span></span><br><span class="line">                <span class="comment">// remove.clear();</span></span><br><span class="line">                <span class="comment">// System.gc();</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; interrupt&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;暂停查看堆内存占用&quot;</span>);</span><br><span class="line">    scanner.next();</span><br><span class="line"></span><br><span class="line">    bytes = <span class="literal">null</span>;</span><br><span class="line">    System.gc();</span><br><span class="line">    System.out.println(<span class="string">&quot;gc 后 sleep 3s，查看总堆内存占用未下降&quot;</span>);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    scanner.next();</span><br><span class="line">    thread.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Cleaner-介绍"><a href="#Cleaner-介绍" class="headerlink" title="Cleaner 介绍"></a>Cleaner 介绍</h3><p>虚引用最常用于以比 <code>finalization</code> 更灵活的方式安排清理工作，比如其子类 <code>Cleaner</code> 就是一种基于虚引用的清理器，它比 <code>finalization</code> 更轻量但更强大。<code>Cleaner</code> 追踪其<code>关联对象</code>并封装任意的清理代码，在 <code>GC</code> 检测到其<code>关联对象</code>变成 <code>phantom reachable</code> 后一段时间，<code>Reference-Handler</code> 线程将运行清理代码。同时 <code>Cleaner</code> 可以被直接调用，它是线程安全的并且可以保证清理代码最多运行一次。但是 <code>Cleaner</code> 不是 <code>finalization</code> 的替代品，为了避免阻塞 <code>Reference-Handler</code> 线程，清理代码应极其简单和直接。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p><code>Cleaner</code> 的构造函数为 <code>private</code>，仅可通过 <code>create</code> 方法创建实例。</p>
<ul>
<li><code>referent</code>: <code>关联对象</code></li>
<li><code>dummyQueue</code>: 假队列，需要它仅仅是因为 <code>PhantomReference</code> 的构造函数需要一个 <code>queue</code> 参数，但是这个 <code>queue</code> 完全没用，在 <code>Reference</code> 中 <code>Reference-Handler</code> 线程会显式调用 <code>cleaners</code> 而不会执行入队操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cleaner</span> <span class="keyword">extends</span> <span class="title class_">PhantomReference</span>&lt;Object&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReferenceQueue&lt;Object&gt; dummyQueue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable thunk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Cleaner</span><span class="params">(Object referent, Runnable thunk)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(referent, dummyQueue);</span><br><span class="line">        <span class="built_in">this</span>.thunk = thunk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Cleaner <span class="title function_">create</span><span class="params">(Object ob, Runnable thunk)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (thunk == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 添加到 Cleaner 自身维护的双链表</span></span><br><span class="line">        <span class="keyword">return</span> add(<span class="keyword">new</span> <span class="title class_">Cleaner</span>(ob, thunk));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加-cleaner"><a href="#添加-cleaner" class="headerlink" title="添加 cleaner"></a>添加 <code>cleaner</code></h3><ul>
<li>使用 <code>synchronized</code> 同步</li>
<li><code>Cleaner</code> 自身维护一个双向链表存储 <code>cleaners</code>，通过静态变量 <code>first</code> 存储头节点，以防止 <code>cleaners</code> 比其<code>关联对象</code>更早被 <code>GC</code>。</li>
</ul>
<div style="width:70%;margin:auto"><img src="/2023/12/28/explore-the-Java-classes-Cleaner-and-Finalizer/Pasted%20image%2020231228220806.png" class="" title="Cleaner 双向链表"></div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">private</span> <span class="type">Cleaner</span> <span class="variable">first</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 双向指针</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">Cleaner</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>, prev = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Cleaner <span class="title function_">add</span><span class="params">(Cleaner cl)</span> &#123;</span><br><span class="line">    <span class="comment">// 头插法</span></span><br><span class="line">    <span class="keyword">if</span> (first != <span class="literal">null</span>) &#123;</span><br><span class="line">        cl.next = first;</span><br><span class="line">        first.prev = cl;</span><br><span class="line">    &#125;</span><br><span class="line">    first = cl;</span><br><span class="line">    <span class="keyword">return</span> cl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="clean-方法"><a href="#clean-方法" class="headerlink" title="clean 方法"></a>clean 方法</h3><p>在 <code>Reference</code> 中 <code>Reference-Handler</code> 线程对于 <code>Cleaner</code> 类型的对象，会显式地调用其 <code>clean</code> 方法并返回，而不会将其入队。</p>
<ol>
<li>使用 <code>synchronized</code> 同步，从双链表上移除自身</li>
<li>调用 <code>thunk</code> 的 <code>run</code> 方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clean</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!remove(<span class="built_in">this</span>))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        thunk.run();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable x) &#123;</span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (System.err != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Cleaner terminated abnormally&quot;</span>, x).printStackTrace();</span><br><span class="line">                System.exit(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Cleaner cl)</span> &#123;</span><br><span class="line">    <span class="comment">// next 指针指向自身代表已经移除，可以避免重复移除和执行</span></span><br><span class="line">    <span class="keyword">if</span> (cl.next == cl)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 更新双链表</span></span><br><span class="line">    <span class="keyword">if</span> (first == cl) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cl.next != <span class="literal">null</span>)</span><br><span class="line">            first = cl.next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            first = cl.prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cl.next != <span class="literal">null</span>)</span><br><span class="line">        cl.next.prev = cl.prev;</span><br><span class="line">    <span class="keyword">if</span> (cl.prev != <span class="literal">null</span>)</span><br><span class="line">        cl.prev.next = cl.next;</span><br><span class="line">    <span class="comment">// 通过将 next 指针指向自身表示已经被移除</span></span><br><span class="line">    cl.next = cl;</span><br><span class="line">    cl.prev = cl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Cleaner-处理流程"><a href="#Cleaner-处理流程" class="headerlink" title="Cleaner 处理流程"></a>Cleaner 处理流程</h3><ul>
<li>创建的 <code>Cleaner</code> 对象被 <code>Cleaner</code> 类的双链表直接或间接引用（强引用），因此不会被垃圾回收</li>
<li>一切的起点仍然是 <code>GC</code> 特殊地对待虚引用的关联对象，当关联对象从 <code>reachable</code> 变成 <code>phantom reachable</code>，<code>GC</code> 将 <code>Cleaner</code> 对象将加入 <code>pending-list</code></li>
<li><code>Reference-Handler</code> 线程又将其移除并调用 <code>clean</code> 方法</li>
<li>在调用完毕后，<code>Cleaner</code> 对象变成 <code>unreachable</code> 并最终被垃圾回收，其关联对象也被垃圾回收</li>
</ul>
<blockquote>
<p>注意，Cleaner 对象本身在被调用完毕之前始终是被静态变量引用，是 <code>reachable</code> 的，我们讨论的被判定为可回收的、变成 <code>phantom reachable</code> 状态的是关联对象。</p>
</blockquote>
<div style="width:70%;margin:auto"><img src="/2023/12/28/explore-the-Java-classes-Cleaner-and-Finalizer/Pasted%20image%2020231229012917.png" class="" title="Cleaner 处理流程"></div>

<blockquote>
<p>事实上，个人猜测“虚引用的关联对象不像软引用和弱引用会被自动清理”描述的仅仅是一个表象，判断是否要被垃圾回收的根本法则仍然是“对象是否从 <code>Root</code> 对象可达”，软引用和弱引用的<code>关联对象</code>之所以会被垃圾回收是因为它们在加入 <code>pending-list</code> 时被从<code>引用对象</code>断开，否则当<code>引用对象</code>被添加到<code>引用队列</code>时，<code>引用队列</code>如果从 <code>Root</code> 对象可达，将导致<code>关联对象</code>也从 <code>Root</code> 对象可达。在 <code>Reference</code> 的 <code>clear()</code> 的注释中提及该方法只被 <code>Java</code> 代码调用，<code>GC</code> 不需要调用该方法就可以直接清理，肯定是 <code>GC</code> 有直接清理<code>关联对象</code>的场景。同时 <code>Reference</code> 类有一句注释“<code>GC</code> 在检测到<code>关联对象</code>有特定的可达性变化后，将把<code>引用对象</code>添加到<code>引用队列</code>”，它并未将特定的可达性变化直接描述为<code>关联对象</code>变为不可达。目前尚未从 <code>JVM</code> 源代码验证该猜测。</p>
</blockquote>
<h2 id="终结引用之-Finalizer"><a href="#终结引用之-Finalizer" class="headerlink" title="终结引用之 Finalizer"></a>终结引用之 Finalizer</h2><p><code>FinalReference</code> 用于实现 <code>finalization</code>，其代码很简单。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FinalReference</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Reference</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FinalReference</span><span class="params">(T referent, ReferenceQueue&lt;? <span class="built_in">super</span> T&gt; q)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(referent, q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其子类 <code>Finalizer</code> 继承自 <code>FinalReference</code>，<code>Cleaner</code> 在代码设计上和它非常相似。</p>
<h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><p><code>Finalizer</code> 的构造函数为 <code>private</code>，仅可通过 <code>register</code> 方法创建实例。</p>
<ul>
<li><code>finalizee</code>: <code>关联对象</code>，即重写了 <code>finalize</code> 方法的类的实例</li>
<li><code>queue</code>: 引用队列</li>
</ul>
<blockquote>
<p>根据注释 <code>register</code> 由 <code>VM</code> 调用，我们可以合理猜测，这里就是重写了 <code>finalize</code> 方法的类的实例和 <code>Finalizer</code> 对象关联的起点。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Finalizer</span> <span class="keyword">extends</span> <span class="title class_">FinalReference</span>&lt;Object&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Finalizer</span><span class="params">(Object finalizee)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(finalizee, queue);</span><br><span class="line">        add();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由 VM 调用</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Object finalizee)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Finalizer</span>(finalizee);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加-Finalizer"><a href="#添加-Finalizer" class="headerlink" title="添加 Finalizer"></a>添加 <code>Finalizer</code></h3><ul>
<li>使用 <code>synchronized</code> 同步</li>
<li><code>Finalizer</code> 自身维护一个双向链表存储 <code>finalizers</code>，通过静态变量 <code>unfinalized</code> 存储头节点</li>
</ul>
<div style="width:70%;margin:auto"><img src="/2023/12/28/explore-the-Java-classes-Cleaner-and-Finalizer/Pasted%20image%2020231228230444.png" class="" title="Finalizer 双向链表"></div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Finalizer</span> <span class="variable">unfinalized</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="type">Finalizer</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>, prev = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (unfinalized != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.next = unfinalized;</span><br><span class="line">            unfinalized.prev = <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        unfinalized = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Finalizer-线程"><a href="#Finalizer-线程" class="headerlink" title="Finalizer 线程"></a><code>Finalizer</code> 线程</h3><p><code>finalizers</code> 的清理通常是由一条名为 <code>Finalizer</code> 的线程处理。启动任意一个非常简单的 <code>Java</code> 程序，通过 <code>JVM</code> 相关的工具，比如 <code>JConsole</code>，你都能看到一个名为 <code>Finalizer</code> 的线程。</p>
<div style="width:70%;margin:auto"><img src="/2023/12/28/explore-the-Java-classes-Cleaner-and-Finalizer/Snipaste_2023-12-28_23-09-21.png" class="" title="Finalizer 线程"></div>

<h4 id="run-方法"><a href="#run-方法" class="headerlink" title="run 方法"></a>run 方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">FinalizerThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> running;</span><br><span class="line">    FinalizerThread(ThreadGroup g) &#123;</span><br><span class="line">        <span class="built_in">super</span>(g, <span class="string">&quot;Finalizer&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 防止递归调用 run（什么场景？）</span></span><br><span class="line">        <span class="keyword">if</span> (running)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// Finalizer thread 在 System.initializeSystemClass 被调用前启动，等待 JavaLangAccess 可用</span></span><br><span class="line">        <span class="keyword">while</span> (!VM.isBooted()) &#123;</span><br><span class="line">            <span class="comment">// 推迟直到 VM 初始化完成</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                VM.awaitBooted();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">                <span class="comment">// 忽略并继续</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">JavaLangAccess</span> <span class="variable">jla</span> <span class="operator">=</span> SharedSecrets.getJavaLangAccess();</span><br><span class="line">        <span class="comment">// 标记为运行中</span></span><br><span class="line">        running = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 从队列中移除</span></span><br><span class="line">                <span class="type">Finalizer</span> <span class="variable">f</span> <span class="operator">=</span> (Finalizer)queue.remove();</span><br><span class="line">                <span class="comment">// 调用 runFinalizer</span></span><br><span class="line">                f.runFinalizer(jla);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">                <span class="comment">// 忽略并继续</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建和启动"><a href="#创建和启动" class="headerlink" title="创建和启动"></a>创建和启动</h4><p><code>Finalizer</code> 线程是通过静态代码块创建和启动的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 向上获取父线程组，直到系统线程组</span></span><br><span class="line">    <span class="type">ThreadGroup</span> <span class="variable">tg</span> <span class="operator">=</span> Thread.currentThread().getThreadGroup();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">ThreadGroup</span> <span class="variable">tgn</span> <span class="operator">=</span> tg;</span><br><span class="line">            tgn != <span class="literal">null</span>;</span><br><span class="line">            tg = tgn, tgn = tg.getParent());</span><br><span class="line">    <span class="comment">// 创建 FinalizerThread 并启动</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">finalizer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FinalizerThread</span>(tg);</span><br><span class="line">    <span class="comment">// 设置优先级为最高减 2</span></span><br><span class="line">    finalizer.setPriority(Thread.MAX_PRIORITY - <span class="number">2</span>);</span><br><span class="line">    finalizer.setDaemon(<span class="literal">true</span>);</span><br><span class="line">    finalizer.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取-Finalizer-并调用"><a href="#获取-Finalizer-并调用" class="headerlink" title="获取 Finalizer 并调用"></a>获取 Finalizer 并调用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">runFinalizer</span><span class="params">(JavaLangAccess jla)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断是否已经终结过</span></span><br><span class="line">        <span class="keyword">if</span> (hasBeenFinalized()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 从双链表上移除</span></span><br><span class="line">        remove();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取关联的 finalizee</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">finalizee</span> <span class="operator">=</span> <span class="built_in">this</span>.get();</span><br><span class="line">        <span class="comment">// 如果不为 null 且不是 Enum 类型</span></span><br><span class="line">        <span class="keyword">if</span> (finalizee != <span class="literal">null</span> &amp;&amp; !(finalizee <span class="keyword">instanceof</span> java.lang.Enum)) &#123;</span><br><span class="line">            <span class="comment">// 调用 invokeFinalize</span></span><br><span class="line">            jla.invokeFinalize(finalizee);</span><br><span class="line">            <span class="comment">// 清理栈槽以降低保守 GC 时误保留的可能性</span></span><br><span class="line">            finalizee = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable x) &#123; &#125;</span><br><span class="line">    <span class="comment">// 清理关联对象</span></span><br><span class="line">    <span class="built_in">super</span>.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和 Cleaner 类似，使用 next 指向自身表示已被移除</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasBeenFinalized</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (next == <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和 Cleaner 类似的处理</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (unfinalized == <span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                unfinalized = <span class="built_in">this</span>.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                unfinalized = <span class="built_in">this</span>.prev;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.next.prev = <span class="built_in">this</span>.prev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.prev != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.prev.next = <span class="built_in">this</span>.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.next = <span class="built_in">this</span>;</span><br><span class="line">        <span class="built_in">this</span>.prev = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="finalize-的调用原理"><a href="#finalize-的调用原理" class="headerlink" title="finalize 的调用原理"></a>finalize 的调用原理</h3><p>关于如何调用 <code>finalize</code> 方法涉及不少平时接触不到的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取 JavaLangAccess</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">JavaLangAccess</span> <span class="variable">jla</span> <span class="operator">=</span> SharedSecrets.getJavaLangAccess();</span><br><span class="line"><span class="comment">// 通过 JavaLangAccess 调用 finalizee 的 finalize 方法</span></span><br><span class="line">jla.invokeFinalize(finalizee);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setJavaLangAccess</span><span class="params">(JavaLangAccess jla)</span> &#123;</span><br><span class="line">    javaLangAccess = jla;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SharedSecrets</code> 的 <code>javaLangAccess</code> 通过 <code>setJavaLangAccess</code> 设置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setJavaLangAccess</span><span class="params">(JavaLangAccess jla)</span> &#123;</span><br><span class="line">    javaLangAccess = jla;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> JavaLangAccess <span class="title function_">getJavaLangAccess</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> javaLangAccess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>setJavaLangAccess</code> 方法在 <code>System</code> 中被调用，<code>javaLangAccess</code> 被设置为一个匿名类实例，其中 <code>invokeFinalize</code> 方法间接调用了传入对象的 <code>finalize</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setJavaLangAccess</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Allow privileged classes outside of java.lang</span></span><br><span class="line">    sun.misc.SharedSecrets.setJavaLangAccess(<span class="keyword">new</span> <span class="title class_">sun</span>.misc.JavaLangAccess()&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invokeFinalize</span><span class="params">(Object o)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">            o.finalize();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>System</code> 的 <code>setJavaLangAccess</code> 方法在 <code>initializeSystemClass</code> 方法中被调用。这里正对应着 <code>FinalizerThread</code> 的 <code>run</code> 方法中等待 <code>VM</code> 初始化完成的处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化 System class，在线程初始化之后调用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initializeSystemClass</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// register shared secrets</span></span><br><span class="line">    setJavaLangAccess();</span><br><span class="line">    <span class="comment">// 通知 wait 的线程</span></span><br><span class="line">    sun.misc.VM.booted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Finalizer-的注册时机"><a href="#Finalizer-的注册时机" class="headerlink" title="Finalizer 的注册时机"></a>Finalizer 的注册时机</h3><p>你是否好奇过 <code>JVM</code> 是如何保证 <code>finalize</code> 方法最多被调用一次的？如果曾经猜测过 <code>JVM</code> 可能在对象中留有标记，那么在我们研究过对象的内部结构之后可以确认其中并没有用于记录对象是否已经 <code>finalized</code> 的地方。同时我们注意到 <code>hasBeenFinalized</code> 方法通过 <code>next</code> 指针是否指向自己表示是否已经 <code>finalized</code>。我们可以合理猜测 <code>register</code> 的调用时机是在对象创建时，因此最多仅有一次被注册。</p>
<p>通过以下示例可以测试：</p>
<ul>
<li>在创建重写了 <code>finalize</code> 方法的类创建对象期间会调用 <code>register</code> 创建并注册 <code>Finalizer</code></li>
<li>在未重写 <code>finalize</code> 方法的类创建对象期间不会调用<code>register</code></li>
<li><code>Finalizer</code> 不仅可以保证 <code>finalize</code> 只会被调用一次，甚至不会第二次被添加到 <code>pending-list</code>，因为 <code>runFinalizer</code> 最后调用了 <code>super.clear()</code>，<code>JVM</code> 不会特殊对待复活的对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalReferenceTest_1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">FinalizeObj</span> <span class="variable">save</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建 finalize obj，使用 Debug 强制运行到 Finalizer.register&quot;</span>);</span><br><span class="line">        <span class="type">FinalizeObj</span> <span class="variable">finalizeObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FinalizeObj</span>();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;gc&quot;</span>);</span><br><span class="line">        finalizeObj = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">&quot;sleep 1s&quot;</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        save.echo();</span><br><span class="line"></span><br><span class="line">        save = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">&quot;sleep 1s&quot;</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(save == <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">FinalizeObj</span> &#123;</span><br><span class="line">        FinalizeObj() &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;SaveSelf created&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finalized&quot;</span>);</span><br><span class="line">            save = <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">echo</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I am alive.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://stackoverflow.com/questions/21809922/how-is-an-object-marked-as-finalized-in-java-so-that-the-finalize-method-wouldn">How is an object marked as finalized in Java (so that the finalize method wouldn’t be called the second time)?</a></li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈 MySQL 事务的隔离性</title>
    <url>/2024/01/06/talk-about-isolation-of-MySQL-transactions/</url>
    <content><![CDATA[<p>事务就是一组数据库操作，它具有原子性（<code>Atomicity</code>）、一致性（<code>Consistency</code>）、隔离性（<code>Isolation</code>）和持久性（<code>Durability</code>），简称为 <code>ACID</code>。本文将介绍 <code>MySQL</code> 事务的<strong>隔离性</strong>以及对其的思考。<br>尽管这是一个老生常谈的话题，网上也有很多相关的资料，但是要理解它并不容易。即使林晓斌老师在 <strong>《MySQL 实战 45 讲》</strong> 中用了两个章节进行介绍，但是你在评论区中会发现有些分享或讨论的观点彼此矛盾。原因可能有很多，比如为了易于理解使用简化概念进行分析，有些具体细节各人各执一词同时它们又不好通过测试进行验证，用词不严谨等等。本文尽可能为自己梳理出一个完善并且前后一致的认知体系，再针对一些容易引起误解的地方作进一步的说明。</p>
<span id="more"></span>

<h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p><code>SQL</code> 标准的事务隔离级别包括：读未提交（<code>read uncommitted</code>）、读提交（<code>read committed</code>）、可重复读（<code>repeatable read</code>）和串行化（<code>serializable</code>）。当多个事务同时执行时，不同的隔离级别可能发生脏读（<code>dirty read</code>）、不可重复读（<code>non-repeatable read</code>）、幻读（<code>phantom read</code>）等一个或多个现象。<strong>隔离级别越高，效率越低</strong>，因此很多时候，我们需要在二者之间寻找一个平衡点。</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交</td>
<td><strong>Y</strong></td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>读提交</td>
<td>N</td>
<td><strong>Y</strong></td>
<td>Y</td>
</tr>
<tr>
<td>可重复读</td>
<td>N</td>
<td>N</td>
<td><strong>Y</strong></td>
</tr>
<tr>
<td>串行化</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
</tbody></table>
<blockquote>
<p>读未提交和串行化很少在实际应用中使用。</p>
</blockquote>
<p>通过以下示例说明隔离级别的影响，<code>V1</code>、<code>V2</code> 和 <code>V3</code> 在不同隔离级别下的值有所不同。</p>
<table>
<thead>
<tr>
<th>事务 A</th>
<th>事务 B</th>
<th>读未提交</th>
<th>读提交</th>
<th>可重复读</th>
<th>串行化</th>
</tr>
</thead>
<tbody><tr>
<td>开启事务</td>
<td>开启事务</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>查询得到值 1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>查询得到值 1</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td><strong>修改值为 2</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>查询得到值 V1</td>
<td></td>
<td><strong>2（读到B未提交的修改）</strong></td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td><strong>提交事务</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>查询得到值 V2</td>
<td></td>
<td>2</td>
<td><strong>2（读到B已提交的修改）</strong></td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td><strong>提交事务</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>查询得到值 V3</td>
<td></td>
<td>2</td>
<td>2</td>
<td><strong>2（A在事务期间数据一致）</strong></td>
<td>1</td>
</tr>
<tr>
<td>补充说明</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><strong>B的修改阻塞至A提交</strong></td>
</tr>
</tbody></table>
<p>通过测试验证以上结论可以帮助你更直观地感受隔离级别的作用：</p>
<ul>
<li>新建连接 <code>mysql –h localhost –u root -P 3306 –p</code></li>
<li>查看会话的事务隔离级别 <code>show variables like &#39;transaction_isolation&#39;;</code></li>
<li>设置会话的事务隔离级别 <code>set session transaction isolation level read uncommitted|read committed|repeatable read|serializable;</code></li>
<li>测试和验证</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;transaction_isolation&#x27;;</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">| Variable_name         | Value           |</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">| transaction_isolation | REPEATABLE-READ |</span><br><span class="line">+-----------------------+-----------------+</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>5.7</code> 引入了 <code>transaction_isolation</code> 作为 <code>tx_isolation</code> 的别名，<code>8.0.3</code> 废弃后者。</p>
</blockquote>
<p>了解数据库的隔离级别及其影响对于理解自身正在使用的数据库的行为、根据业务场景设置隔离级别优化性能以及迁移数据都是有帮助的。<code>Oracle</code> 数据库的默认隔离级别是“读提交”，<code>MySQL</code> 的默认隔离级别是“可重复读”。</p>
<h2 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h2><blockquote>
<p>在 <code>MySQL</code> 中，事务隔离是通过 <code>lock</code>、<code>undo log</code> 和 <code>read view</code> 共同协作实现的。很多时候，我们关注 MVCC 在“读提交”和“可重复读”隔离级别中的作用而忽视事务隔离和锁的关系。</p>
</blockquote>
<p><code>MySQL</code> 各个事务隔离级别的实现原理简述如下:</p>
<ul>
<li>串行化：读加共享锁，写加排他锁，读写互斥</li>
<li>读未提交：写加排他锁，读不加锁</li>
<li>可重复读：<strong>第一次读操作</strong>时创建快照，基于该快照进行读取</li>
<li>读提交：<strong>每次读操作时</strong>重置快照，基于该快照进行读取</li>
</ul>
<p>前两者通过锁（<code>lock</code>）实现比较容易理解；后两者通过多版本并发控制（<code>MVCC</code>）实现。<code>MVCC</code> 是一种实现非阻塞并发读的设计思路，在 <code>InnoDB</code> 引擎中主要通过 <code>undo log</code> 和 <code>read view</code> 实现。</p>
<p>以下示意图表现了在 <code>InnoDB</code> 引擎中，同一行数据存在多个“快照”版本，这就是数据库的多版本并发控制（<code>MVCC</code>），当你基于快照读取时可以获得旧版本的数据。</p>
<ul>
<li>假设一个值从 1 按顺序被修改为 2、3、4，最新值为 4。</li>
<li>事务将基于各自拥有的“快照”读取数据而不受其他事务更新的影响，也不阻塞其他事务的更新。</li>
</ul>
<div style="width:70%;margin:auto"><img src="/2024/01/06/talk-about-isolation-of-MySQL-transactions/Pasted%20image%2020240111155021.png" class="" title="MySQL undolog 和 read-view"></div>

<p>在接下来我们将通过锁、事务 <code>ID</code>、回滚日志和一致性视图逐步介绍 <code>InnoDB</code> 事务隔离的实现原理。</p>
<h3 id="锁（lock）"><a href="#锁（lock）" class="headerlink" title="锁（lock）"></a>锁（lock）</h3><p>事务在本质上是一个并发控制问题，而锁是解决并发问题的常见基础方案。<code>MySQL</code> 正是通过<strong>共享锁</strong>和<strong>排他锁</strong>实现串行化隔离级别。但是读加共享锁影响性能，尤其是在读写冲突频繁时，若不加发生“脏读”的缺陷又比较大，<code>MVCC</code> 就是用于在即使有读写冲突的情况下，不加读锁实现非阻塞并发读。</p>
<blockquote>
<p>在 <code>InnoDB</code> 的事务中，行锁（共享锁或排他锁）是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放，这个就是<strong>两阶段锁协议</strong>。</p>
</blockquote>
<p>理解两阶段锁协议，你会更深地体会读写冲突频繁时锁对性能的影响以及 <code>MVCC</code> 的作用。长事务可能导致一个锁被长时间持有，导致拖垮整个库。</p>
<h3 id="事务-ID"><a href="#事务-ID" class="headerlink" title="事务 ID"></a>事务 ID</h3><p>在 <code>InnoDB</code> 引擎中，每个事务都有唯一的一个事务 <code>ID</code>，叫做 <code>transaction id</code>。它是在事务开始的时候向 <code>InnoDB</code> 的事务系统申请的，是按申请顺序严格递增的。同时每一行数据有一个隐藏字段 <code>trx_id</code>，记录了插入或更新该行数据的事务 <code>ID</code>。</p>
<div style="width:40%;margin:auto"><img src="/2024/01/06/talk-about-isolation-of-MySQL-transactions/Pasted%20image%2020240111233121.png" class="" title="MySQL 数据行隐藏字段 trx_id"></div>

<h4 id="创建事务的时机"><a href="#创建事务的时机" class="headerlink" title="创建事务的时机"></a>创建事务的时机</h4><p>事务启动方式如下：</p>
<ol>
<li>显式启动事务语句是 <code>begin</code> 或 <code>start transaction</code>，配套的提交语句是 <code>commit</code>，回滚语句是 <code>rollback</code>。</li>
<li>隐式启动事务语句是 <code>set autocommit = 0</code>，该设置将关闭自动提交。当你执行 <code>select</code>，将自动启动一个事务，直到你主动 <code>commit</code> 或 <code>rollback</code>。</li>
</ol>
<p>但注意，实际上不论是显式启动事务情况下的 <code>begin</code> 或 <code>start transaction</code>，还是隐式启动事务情况下的 <code>commit</code> 或 <code>rollback</code> 都不会立即创建一个新事务，而是<strong>直到第一次操作 <code>InnoDB</code> 表的语句执行时，才会真正创建一个新事务</strong>。</p>
<p>可以通过以下语句查看当前“活跃”的事务进行验证：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.innodb_trx;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>只读事务的事务 <code>ID</code> 和更新事务不同。</p>
</blockquote>
<blockquote>
<p>可以使用 <code>commit work and chain;</code> 在提交的同时开启下一次事务，减少一次 <code>begin;</code> 指令的交互开销。</p>
</blockquote>
<h3 id="回滚日志（undo-log）"><a href="#回滚日志（undo-log）" class="headerlink" title="回滚日志（undo log）"></a>回滚日志（undo log）</h3><p>在 <code>InnoDB</code> 引擎中，每条记录在更新的时候都会同时记录一条回滚操作。记录的最新值，通过回滚操作，可以得到之前版本的值。它的作用是：</p>
<ul>
<li>数据回滚：当事务回滚或者数据库崩溃时，通过 <code>undolog</code> 进行数据回滚。</li>
<li>多版本并发控制：当读取一行记录时，如果该行记录已经被其他事务修改，通过 <code>undo log</code> 读取之前版本的数据，以此实现非阻塞并发读。</li>
</ul>
<p>实际上，每一行数据还有一个隐藏字段 <code>roll_ptr</code>。很多相关资料简单地描述“<code>roll_ptr</code> 用于指向该行数据的上一个版本”，但是该说法容易让人误解旧版本的数据是物理上真实存在的，好像有一张链表结构的历史记录表按顺序记录了每一个版本的数据。</p>
<div style="width:70%;margin:auto"><img src="/2024/01/06/talk-about-isolation-of-MySQL-transactions/Pasted%20image%2020240111231216.png" class="" title="MySQL 多版本数据示意图（误解版）"></div>

<p>有些资料会特地强调旧版本的数据不是物理上真实存在的，<code>undo log</code> 是逻辑日志，记录了与实际操作语句相反的操作，旧版本的数据是通过 <code>undo log</code> 计算得到的。</p>
<div style="width:70%;margin:auto"><img src="/2024/01/06/talk-about-isolation-of-MySQL-transactions/Pasted%20image%2020240112145730.png" class="" title="MySQL 多版本数据示意图（undolog计算版）"></div>

<blockquote>
<p>说实话，在不了解细节的前提下，通过计算得到旧版本的数据更加反直觉。总而言之，<code>InnoDB</code> 的数据总是存储最新版本，尽管该版本所属的事务可能尚未提交；任何事务其实都是从最新版本开始回溯，直到获得该事务认为可见的版本。</p>
</blockquote>
<h4 id="回滚日志的删除时机"><a href="#回滚日志的删除时机" class="headerlink" title="回滚日志的删除时机"></a>回滚日志的删除时机</h4><p>回滚日志不会一直保留，在没有事务需要的时候，系统会自动判断和删除。基于该结论，我们应该避免使用长事务。长事务意味着系统里面可能会存在很老的 <code>read view</code>，这些事务可能访问数据库里的任何数据，所以在这个事务提交之前，数据库里它可能用到的回滚日志都必须保留，这就会导致大量存储空间被占用。在 <code>MySQL 5.5</code> 及之前的版本中，回滚日志是和数据字典一起放在 ibdata 文件里的，即使长事务最终提交，回滚段被清理，但只是代表那部分存储空间可复用，文件并不会变小，需要重建整个库才能解决问题。</p>
<h3 id="一致性视图（read-view）"><a href="#一致性视图（read-view）" class="headerlink" title="一致性视图（read view）"></a>一致性视图（read view）</h3><p>一致性读视图（<code>read view</code>）又可以称之为快照（<code>snapshot</code>），它是基于<strong>整库</strong>的，但是它并不是真的拷贝了整个数据库的数据，否则随着数据量的增长，显然无法实现秒级创建快照。<code>read view</code> 可以理解为发出一个声明：“<strong>以我创建的时刻为准，如果一个数据版本所属的事务是在这之前提交的，就可见；如果是在这之后提交的，就不可见，需要回溯上一个版本判断，重复直到获得可见的版本；如果该数据版本属于当前事务自身，是可见的</strong>”。</p>
<blockquote>
<p>以上声明类似于功能的需求描述，它比具体实现更简洁和易于理解。</p>
</blockquote>
<p>“快照”结合“多版本”等词，和 <code>undo log</code> 的情况类似很容易让人误解为有一个物理上真实存在的数据快照，但实际上 <code>read view</code> 只是在沿着数据版本链回溯时用于判断该版本对当前事务是否可见的依据。在具体实现上，<code>InnoDB</code> 为每一个事务构造了一个数组用于保存创建 <code>read view</code> 时，<strong>当前正在“活跃”的所有事务 <code>ID</code></strong> ，其中“活跃”指的是启动了但尚未提交。<strong>数组中事务 <code>ID</code> 的最小值记为低水位，当前系统里面已经创建过的事务 <code>ID</code> 的最大值加 1 记为高水位</strong>。这个数组和高水位就组成了当前事务的一致性视图（<code>read view</code>）。对于当前事务的 <code>read view</code> 而言，一个数据版本的 <code>trx_id</code>，有以下几种可能：</p>
<ul>
<li>如果小于低水位，表示这个版本是已提交的事务生成的，可见</li>
<li>如果大于等于高水位，表示这个版本是创建 <code>read view</code> 之后启动的事务，不可见</li>
<li>如果大于等于低水位且小于高水位<ul>
<li>如果这个版本的 <code>trx_id</code> 在数组中，表示这个版本是已启动但尚未提交的事务生成的，不可见</li>
<li>如果这个版本的 <code>trx_id</code> 不在数组中，表示这个版本是已提交的事务生成的，可见</li>
</ul>
</li>
</ul>
<p><code>InnoDB</code> 利用“所有数据都有多个版本，每个版本都记录了所属事务 <code>ID</code>”这个特性，实现了“秒级创建快照”的能力。有了这个能力，系统里面随后发生的更新，就和当前事务可见的数据无关了，当前事务读取时也不必再加锁。</p>
<blockquote>
<p>以上“具体实现”相较于之前的“需求描述”显得有些啰嗦和复杂，然而这里的细节是值得推敲的。即便是林晓斌老师在《MySQL 实战 45 讲》中的详细讲解也让部分读者包括我本人感到困惑。</p>
</blockquote>
<p>林晓斌老师的数据版本可见性示意图如下，容易让人产生误解的地方在于三段式的划分给人<strong>一种已提交的事务全都是小于低水位的错觉</strong>。</p>
<div style="width:70%;margin:auto"><img src="/2024/01/06/talk-about-isolation-of-MySQL-transactions/Snipaste_2024-01-12_16-50-18.png" class="" title="数据版本可见性规则（林晓斌老师版）"></div>

<p>事实上，已提交事务的分布可能如下，大部分人的疑问其实只是“在大于等于低水位小于高水位的范围中，为什么会有已提交的事务”。</p>
<div style="width:70%;margin:auto"><img src="/2024/01/06/talk-about-isolation-of-MySQL-transactions/Pasted%20image%2020240112170313.png" class="" title="数据版本可见性规则"></div>

<p>要理解该问题需要理解另外一个问题——“创建 <code>read view</code> 的时机”。</p>
<h4 id="创建-read-view-的时机"><a href="#创建-read-view-的时机" class="headerlink" title="创建 read view 的时机"></a>创建 read view 的时机</h4><p>很多资料介绍“可重复读”隔离级别下的 <code>read view</code> 创建时机为在事务启动时，但这并不严谨，还会导致理解 <code>read view</code> 数组困难。<strong>创建事务并不等于创建 <code>read view</code></strong> 。</p>
<blockquote>
<p>官方文档：With REPEATABLE READ isolation level, the snapshot is based on the time when the first read operation is performed. With READ COMMITTED isolation level, the snapshot is reset to the time of each consistent read operation.</p>
</blockquote>
<ul>
<li>对于“读提交”隔离级别，每次读操作都会重置快照。这意味着只要当前事务持续足够长的时间，它最后读取时完全可能熬到在它之前甚至之后创建的事务提交。</li>
<li>对于“可重复读”隔离级别，在第一次执行快照读时创建快照。这意味着当前事务可以执行很多次以及很久的 <code>update</code> 语句后再执行读取，熬到在它之前甚至之后创建的事务提交。</li>
</ul>
<p>有些人可能想到了前者，但对于后者存疑或者不知道如何验证，其实测试并不复杂：</p>
<table>
<thead>
<tr>
<th>事务 A</th>
<th>事务 B</th>
</tr>
</thead>
<tbody><tr>
<td><code>begin;</code></td>
<td><code>begin;</code></td>
</tr>
<tr>
<td><code>update t set k = 2 where id = 2;</code>(创建事务)</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>update t set k = 666 where id = 1;</code>(创建事务)</td>
</tr>
<tr>
<td></td>
<td><code>commit;</code></td>
</tr>
<tr>
<td><code>select * from t where id = 1;</code>(创建 <code>read view</code>，k &#x3D; 666)</td>
<td></td>
</tr>
<tr>
<td><code>commit;</code></td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>因此，严谨地说，创建事务的时机和创建一致性视图的时机是不同的。通过 <code>start transaction with consistent snapshot;</code> 可以在开启事务的同时立即创建 <code>read view</code>。</p>
</blockquote>
<h2 id="当前读和快照读"><a href="#当前读和快照读" class="headerlink" title="当前读和快照读"></a>当前读和快照读</h2><p>现在我们知道在 <code>InnoDB</code> 引擎中，一行数据存在多个版本。<code>MVCC</code> 使得在“可重复读”隔离级别下的事务好像与世无争。但是在以下示例中，事务 B 是在事务 A 的一致性视图之后创建和提交的，为什么事务 A 查询到的 <code>k</code> 为 3 呢？</p>
<table>
<thead>
<tr>
<th>事务 A</th>
<th>事务 B</th>
</tr>
</thead>
<tbody><tr>
<td><code>start transaction with consistent snapshot;</code>（k &#x3D; 1）</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>update t set k = k + 1 where id = 1;</code>（自动提交事务）</td>
</tr>
<tr>
<td><code>update t set k = k + 1 where id = 1;</code>（<strong>当前读</strong>）</td>
<td></td>
</tr>
<tr>
<td><code>select * from t where id = 1;</code>（k &#x3D; 3）</td>
<td></td>
</tr>
<tr>
<td><code>commit;</code></td>
<td></td>
</tr>
</tbody></table>
<p>其实，更新数据是先读后写的，并且是“当前读”。</p>
<ul>
<li>当前读：读取一行数据的最新版本，并保证在读取时其他事务不能修改该行数据，因此需要在读取时加锁。以下操作属于当前读的情况：<ul>
<li>共享锁：<code>select lock in share mode</code></li>
<li>排他锁：<code>select for update</code>，<code>update</code>，<code>insert</code>，<code>delete</code></li>
</ul>
</li>
<li>快照读：在不加锁的情况下通过 <code>select</code> 读取一行数据，但和“读未提交”隔离级别下单纯地读取最新版本不同，它是基于一个“快照”进行读取。</li>
</ul>
<p>因此在事务 A 中更新时，读取到的是事务 B 更新后的最新值，在事务 A 更新后，依据 <code>read view</code> 的可见性原则，它可以看到自身事务的更新后的最新值 3。</p>
<p>如果事务 B 尚未提交的情况下，事务 A 发起更新，会如何呢？这时候就轮到“两阶段锁协议”派上用场了：</p>
<ul>
<li>事务 B 在更新时，对改行数据加排他锁，在事务 B 提交时才会释放</li>
<li>当事务 A 发起更新，将阻塞直到事务 B 提交</li>
</ul>
<table>
<thead>
<tr>
<th>事务 A</th>
<th>事务 B</th>
</tr>
</thead>
<tbody><tr>
<td><code>start transaction with consistent snapshot;</code>（k &#x3D; 1）</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>begin;</code></td>
</tr>
<tr>
<td></td>
<td><code>update t set k = k + 1 where id = 1;</code>（<strong>排他锁</strong>）</td>
</tr>
<tr>
<td><code>update t set k = k + 1 where id = 1;</code>（<strong>阻塞至 B 提交</strong>）</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>commit;</code></td>
</tr>
<tr>
<td><code>select * from t where id = 1;</code>（k &#x3D; 3）</td>
<td></td>
</tr>
<tr>
<td><code>commit;</code></td>
<td></td>
</tr>
</tbody></table>
<p>至此，我们将锁和 <code>MVCC</code> 在事务隔离的实现原理中串联起来了。两者是互相独立又互相协作的两个机制，前者实现了“当前读”，后者实现了“快照读”。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>卡壳好几天，想到有不少好的文章却仍然会给读者留下困惑，想到自己在当初学习时对一些不严谨的表达抓耳挠腮想不通为什么，就有点不知道如何下笔。最终围绕着自己当初的一些困惑，一点一点修修补补完了。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://time.geekbang.org/column/article/68963">03 | 事务隔离：为什么你改了我还看不见</a></li>
<li><a href="https://time.geekbang.org/column/article/70562">08 | 事务到底是隔离的还是不隔离的？</a></li>
</ul>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
</search>
