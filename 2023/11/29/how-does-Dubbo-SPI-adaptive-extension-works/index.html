<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.moralok.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="直接展示一个具体的 Dubbo SPI 自适应拓展是什么样子，是一种非常好的表现其作用的方式。正如官方博客中所说的，它让人对自适应拓展有更加感性的认识，避免读者一开始就陷入复杂的代码生成逻辑。本文在此基础上，从更原始的使用方式上展现“动态加载”技术对“按需加载”的天然倾向，从更普遍的角度解释自适应拓展的本质目的，在介绍 Dubbo 的具体实现是如何约束自身从而规避缺点之后，详细梳理了 Dubbo">
<meta property="og:type" content="article">
<meta property="og:title" content="Dubbo SPI 自适应拓展的工作原理">
<meta property="og:url" content="https://www.moralok.com/2023/11/29/how-does-Dubbo-SPI-adaptive-extension-works/index.html">
<meta property="og:site_name" content="Moralok">
<meta property="og:description" content="直接展示一个具体的 Dubbo SPI 自适应拓展是什么样子，是一种非常好的表现其作用的方式。正如官方博客中所说的，它让人对自适应拓展有更加感性的认识，避免读者一开始就陷入复杂的代码生成逻辑。本文在此基础上，从更原始的使用方式上展现“动态加载”技术对“按需加载”的天然倾向，从更普遍的角度解释自适应拓展的本质目的，在介绍 Dubbo 的具体实现是如何约束自身从而规避缺点之后，详细梳理了 Dubbo">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-11-29T05:40:07.000Z">
<meta property="article:modified_time" content="2024-03-09T15:36:19.936Z">
<meta property="article:author" content="Moralok">
<meta property="article:tag" content="java">
<meta property="article:tag" content="dubbo">
<meta property="article:tag" content="spi">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://www.moralok.com/2023/11/29/how-does-Dubbo-SPI-adaptive-extension-works/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.moralok.com/2023/11/29/how-does-Dubbo-SPI-adaptive-extension-works/","path":"2023/11/29/how-does-Dubbo-SPI-adaptive-extension-works/","title":"Dubbo SPI 自适应拓展的工作原理"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Dubbo SPI 自适应拓展的工作原理 | Moralok</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-2MBCXKHJL0"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-2MBCXKHJL0","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Moralok</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-number">1.</span> <span class="nav-text">原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.1.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%B9%E8%BF%9B"><span class="nav-number">1.2.</span> <span class="nav-text">改进</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%8B%E5%B7%A5%E7%BC%96%E7%A0%81%E7%9A%84%E8%87%AA%E9%80%82%E5%BA%94%E6%8B%93%E5%B1%95"><span class="nav-number">1.3.</span> <span class="nav-text">手工编码的自适应拓展</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">2.</span> <span class="nav-text">源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Adaptive-%E6%B3%A8%E8%A7%A3"><span class="nav-number">2.1.</span> <span class="nav-text">Adaptive 注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E8%87%AA%E9%80%82%E5%BA%94%E6%8B%93%E5%B1%95"><span class="nav-number">2.2.</span> <span class="nav-text">获取自适应拓展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%87%AA%E9%80%82%E5%BA%94%E6%8B%93%E5%B1%95"><span class="nav-number">2.3.</span> <span class="nav-text">创建自适应拓展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E8%87%AA%E9%80%82%E5%BA%94%E6%8B%93%E5%B1%95%E7%B1%BB"><span class="nav-number">2.4.</span> <span class="nav-text">获取自适应拓展类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E8%87%AA%E9%80%82%E5%BA%94%E6%8B%93%E5%B1%95%E7%B1%BB"><span class="nav-number">2.5.</span> <span class="nav-text">生成自适应拓展类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E9%80%82%E5%BA%94%E6%8B%93%E5%B1%95%E7%B1%BB%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8"><span class="nav-number">2.6.</span> <span class="nav-text">自适应拓展类代码生成器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B-Adaptive-%E6%B3%A8%E8%A7%A3"><span class="nav-number">2.6.1.</span> <span class="nav-text">检测 Adaptive 注解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E7%B1%BB"><span class="nav-number">2.6.2.</span> <span class="nav-text">生成类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E6%96%B9%E6%B3%95"><span class="nav-number">2.6.3.</span> <span class="nav-text">生成方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%A0-Adaptive-%E6%B3%A8%E8%A7%A3%E6%A0%87%E6%B3%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">2.6.3.1.</span> <span class="nav-text">无 Adaptive 注解标注的方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%89-Adaptive-%E6%B3%A8%E8%A7%A3%E6%A0%87%E6%B3%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">2.6.3.2.</span> <span class="nav-text">有 Adaptive 注解标注的方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE-URL-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-number">2.6.3.3.</span> <span class="nav-text">查找 URL 类型的参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96-Adaptive-%E6%B3%A8%E8%A7%A3%E7%9A%84-value"><span class="nav-number">2.6.3.4.</span> <span class="nav-text">获取 Adaptive 注解的 value</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B-Invocation-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-number">2.6.3.5.</span> <span class="nav-text">检测 Invocation 类型的参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%8B%93%E5%B1%95%E5%90%8D"><span class="nav-number">2.6.3.6.</span> <span class="nav-text">获取拓展名</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E6%8B%93%E5%B1%95"><span class="nav-number">2.6.3.7.</span> <span class="nav-text">加载拓展</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E4%B8%8E%E8%BF%94%E5%9B%9E"><span class="nav-number">2.6.3.8.</span> <span class="nav-text">调用与返回</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="nav-number">3.</span> <span class="nav-text">参考文章</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Moralok</p>
  <div class="site-description" itemprop="description">假如生命只剩一天</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">48</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/moralok" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;moralok" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.moralok.com/2023/11/29/how-does-Dubbo-SPI-adaptive-extension-works/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Moralok">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Moralok">
      <meta itemprop="description" content="假如生命只剩一天">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Dubbo SPI 自适应拓展的工作原理 | Moralok">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Dubbo SPI 自适应拓展的工作原理
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-29 13:40:07" itemprop="dateCreated datePublished" datetime="2023-11-29T13:40:07+08:00">2023-11-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-09 23:36:19" itemprop="dateModified" datetime="2024-03-09T23:36:19+08:00">2024-03-09</time>
    </span>

  
    <span id="/2023/11/29/how-does-Dubbo-SPI-adaptive-extension-works/" class="post-meta-item leancloud_visitors" data-flag-title="Dubbo SPI 自适应拓展的工作原理" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>18 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>直接展示一个具体的 <code>Dubbo SPI</code> 自适应拓展是什么样子，是一种非常好的表现其作用的方式。正如官方博客中所说的，它让人对自适应拓展有更加感性的认识，避免读者一开始就陷入复杂的代码生成逻辑。本文在此基础上，从更原始的使用方式上展现“动态加载”技术对“按需加载”的天然倾向，从更普遍的角度解释自适应拓展的本质目的，在介绍 <code>Dubbo</code> 的具体实现是如何约束自身从而规避缺点之后，详细梳理了 <code>Dubbo SPI</code> 自适应拓展的相关源码和工作原理。</p>
<span id="more"></span>

<blockquote>
<p>站在现有设计回头看的视角更偏向于展现为什么这样设计很好，却并不好展现如果不这样设计会有什么问题，以至于有时候会有种这个设计很妙，但妙在哪里体会不够深的感觉。思考一项技术如何从最初发展到现在，解决以及试图解决哪些问题，因此可能引入哪些问题，也许脑补的并不完全符合历史事实，但仍然会让人更加深刻地认识这项技术本身，体会设计中的巧思，并避免一直陷在庞杂的细节处理中。</p>
</blockquote>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在 <code>Dubbo</code> 中，很多拓展都是通过 <code>SPI</code> 机制动态加载的，比如 <code>Protocol</code>、<code>Cluster</code> 和 <code>LoadBalance</code> 等。有些拓展我们并不想在框架启动阶段被加载，而是希望在拓展方法被调用时，根据运行时参数进行加载。为了让大家对自适应拓展有一个感性的认识，下面我们通过一个实例进行演示。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>定义一个接口 <code>Animal</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义两个实现类 <code>Dog</code> 和 <code>Cat</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog bark...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cat bark...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在运行时根据参数动态地加载拓展。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">(String type)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;type == null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过 SPI 动态地加载具体的 Animal</span></span><br><span class="line">    <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> ExtensionLoader.getExtensionLoader(Animal.class).getExtension(type);</span><br><span class="line">    <span class="comment">// 调用目标方法</span></span><br><span class="line">    animal.bark();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>是不是感觉平平无奇？没错，当你拥有动态加载的能力后，按需加载是自然而然会产生的想法，并不是什么高大上的设计。两者甚至不仅仅是天性相合，可能更像是你中有我，我中有你。在正常场景中，这样一段代码也并不需要进一步被抽象和重构，它本身就很简洁。现在设想一下，你的应用中，有大量的拓展需要动态加载，你可能需要在很多地方写很多根据运行时参数动态加载拓展并调用方法的代码，就像下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> ExtensionLoader.getExtensionLoader(Animal.class).getExtension(type);</span><br><span class="line">animal.bark();</span><br><span class="line"></span><br><span class="line"><span class="type">WeelMaker</span> <span class="variable">weelMaker</span> <span class="operator">=</span> ExtensionLoader.getExtensionLoader(WeelMaker.class).getExtension(weelMakerName);</span><br><span class="line">weelMaker.makeWeel();</span><br><span class="line"></span><br><span class="line"><span class="type">LoadBalance</span> <span class="variable">loadBalance</span> <span class="operator">=</span> ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(invocation.getLoadBalanceType());</span><br><span class="line">loadBalance.select();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>这会带来一些小问题，总是需要写 <code>ExtensionLoader.getExtensionLoader(XXX.class).getExtension(parameter)</code> 这样重复的代码；引入了 <code>ExtensionLoader</code> 这个“中介”，不能直面拓展本身。后者可能有点难以体会，以动物园 <code>Zoo</code> 和 动物 <code>Animal</code> 举例。</p>
<p>在非动态加载情况下，我们可能会这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zoo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Animal&gt; animals;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Animal animal : animals) &#123;</span><br><span class="line">            <span class="keyword">if</span> (type.equals(animal.name)) &#123;</span><br><span class="line">                animal.bark();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在动态加载情况下，我们可能会这样写。在这种情况下，<code>Zoo</code> 没有合适的方式直接持有 <code>Animal</code>，而是通过 <code>ExtensionLoader</code> 间接地持有。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zoo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ExtensionLoader&lt;Animal&gt; extensionLoader = ExtensionLoader.getExtensionLoader(Animal.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> extensionLoader.getExtension(type);</span><br><span class="line">        animal.bark();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们更想要以下这种直接持有 <code>Animal</code> 的方式，在运行时 <code>animal</code> 可以是 <code>Dog</code>，也可以是 <code>Cat</code>，还可以是其他的动物。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zoo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Animal animal;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        animal.bark();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Dubbo</code> 采用了一种称为“自适应拓展”的巧妙设计，通过代理的方式，将动态加载拓展的代码整合到代理类（具体实现类）中。使用方调用代理对象，代理对象根据参数动态加载拓展并调用。例如 <code>Animal</code> 的自适应拓展，就像下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdaptiveAnimal</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;type == null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> ExtensionLoader.getExtensionLoader(Animal.class).getExtension(type);</span><br><span class="line">        animal.bark();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AdaptiveAnimal</span>();</span><br><span class="line">animal.bark(type);</span><br></pre></td></tr></table></figure>

<p>当然，我们不希望需要手动地为每一个拓展编写 <code>Adaptive</code> 代理类，事实上，我们以往接触到的代理方案，大都是自动生成代理的，应该也不会有人会接受完全手写的方式。然而你可能会注意到一个不够和谐的缺点，<code>bark</code> 方法的参数列表中新增了 <code>type</code> 类型，这不太符合面向对象的设计原则。想象一个更奇怪的场景，我们要为一个方法引入与它本身格格不入的参数用于获取拓展。另外，我们可能需要通过一些标记或约定来告诉代理生成器，方法参数列表中哪一个参数是用于获取拓展的。事实上，<code>Dubbo</code> 的另一个设计规避了这一缺点，<code>Dubbo</code> 在<a target="_blank" rel="noopener" href="https://cn.dubbo.apache.org/zh-cn/docsv2.7/dev/contract/">公共契约</a>中提到：<strong>所有扩展点参数都包含 <code>URL</code> 参数，<code>URL</code> 作为上下文信息贯穿整个扩展点设计体系</strong>。因此围绕着 <code>Dubbo</code> 以 <code>URL</code> 为中心的拓展体系，你很难设计出 <code>Animal.bark(URL url)</code> 这样不和谐的方法签名，也不用担心参数列表千奇百怪的情况。同时 <code>Dubbo</code> 并未完全抛弃手工编写自适应拓展的方式，而是予以保留。</p>
<h3 id="手工编码的自适应拓展"><a href="#手工编码的自适应拓展" class="headerlink" title="手工编码的自适应拓展"></a>手工编码的自适应拓展</h3><p>在在 <code>Dubbo</code> 中，尽管很少但仍然存在手工编码的自适应拓展，<strong>这类拓展允许你不使用 <code>URL</code> 作为参数</strong>，查看它们的代码可以帮助我们更好地理解自适应拓展是如何在真实的应用场景中发挥作用的。以下是 <code>ExtensionFactory</code> 的自适应拓展，当你调用它的 <code>getExtension</code> 方法时，它就是将工作全权委托给 <code>factory.getExtension(type, name)</code> 完成的，而 <code>factories</code> 在创建 <code>AdaptiveExtensionFactory</code> 时就已经获取了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Adaptive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdaptiveExtensionFactory</span> <span class="keyword">implements</span> <span class="title class_">ExtensionFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ExtensionFactory&gt; factories;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AdaptiveExtensionFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取 ExtensionFactory 的 ExtensionLoader</span></span><br><span class="line">        ExtensionLoader&lt;ExtensionFactory&gt; loader = ExtensionLoader.getExtensionLoader(ExtensionFactory.class);</span><br><span class="line">        List&lt;ExtensionFactory&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ExtensionFactory&gt;();</span><br><span class="line">        <span class="comment">// 获取全部支持的（不包含自适应拓展）拓展名称，依次获取拓展加入 factories</span></span><br><span class="line">        <span class="keyword">for</span> (String name : loader.getSupportedExtensions()) &#123;</span><br><span class="line">            list.add(loader.getExtension(name));</span><br><span class="line">        &#125;</span><br><span class="line">        factories = Collections.unmodifiableList(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getExtension</span><span class="params">(Class&lt;T&gt; type, String name)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (ExtensionFactory factory : factories) &#123;</span><br><span class="line">            <span class="comment">// 委托给其他 ExtensionFactory 拓展获取，比如 SpiExtensionFactory</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">extension</span> <span class="operator">=</span> factory.getExtension(type, name);</span><br><span class="line">            <span class="keyword">if</span> (extension != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> extension;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们提到了按需加载是具备动态加载能力后自然的倾向，介绍了在拥有大量拓展情况下演变而来的自适应拓展设计，它的缺点和 Dubbo 是如何规避的。接下来，我们将进入源码分析部分。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="Adaptive-注解"><a href="#Adaptive-注解" class="headerlink" title="Adaptive 注解"></a>Adaptive 注解</h3><p><code>Adaptive</code> 注解是一个与自适应拓展息息相关的注解，该定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Adaptive &#123;</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据 <code>Target</code> 注解的 <code>value</code> 可知，<code>Adaptive</code> 注解可标注在类或者方法上。当 <code>Adaptive</code> 注解标注在类上时，<code>Dubbo</code> 不会为该类生成代理类。当 <code>Adaptive</code> 注解标注在接口方法上时，<code>Dubbo</code> 则会为该方法生成代理逻辑。<code>Adaptive</code> 注解在类上的情况很少，在 <code>Dubbo</code> 中，仅有两个类被 <code>Adaptive</code> 注解标注，分别是 <code>AdaptiveCompiler</code> 和 <code>AdaptiveExtensionFactory</code>。在这种情况下，拓展的加载逻辑由人工编码完成。在更多时候，<code>Adaptive</code> 注解是标注在接口方法上的，这表示拓展的加载逻辑需由框架自动生成。</p>
<h3 id="获取自适应拓展"><a href="#获取自适应拓展" class="headerlink" title="获取自适应拓展"></a>获取自适应拓展</h3><p>获取自适应拓展的入口方法是 <code>getAdaptiveExtension</code>，使用 <code>getOrCreate</code> 的模式获取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">getAdaptiveExtension</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 双重检查</span></span><br><span class="line">    <span class="comment">// 从缓存中获取自适应拓展</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> cachedAdaptiveInstance.get();</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建自适应拓展失败的结果也会被缓存，避免重复尝试</span></span><br><span class="line">        <span class="keyword">if</span> (createAdaptiveInstanceError != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Failed to create adaptive instance: &quot;</span> +</span><br><span class="line">                    createAdaptiveInstanceError.toString(),</span><br><span class="line">                    createAdaptiveInstanceError);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (cachedAdaptiveInstance) &#123;</span><br><span class="line">            instance = cachedAdaptiveInstance.get();</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 创建自适应拓展</span></span><br><span class="line">                    instance = createAdaptiveExtension();</span><br><span class="line">                    <span class="comment">// 将自适应拓展设置到缓存中</span></span><br><span class="line">                    cachedAdaptiveInstance.set(instance);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    createAdaptiveInstanceError = t;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Failed to create adaptive instance: &quot;</span> + t.toString(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建自适应拓展"><a href="#创建自适应拓展" class="headerlink" title="创建自适应拓展"></a>创建自适应拓展</h3><p>当缓存为空时，就会通过 <code>createAdaptiveExtension</code> 方法创建。方法包含以下三个处理逻辑：</p>
<ol>
<li>调用 <code>getAdaptiveExtensionClass</code> 方法获取自适应拓展的 <code>Class</code> 对象。</li>
<li>通过反射进行实例化。</li>
<li>调用 <code>injectExtension</code> 方法对拓展实例进行依赖注入。</li>
</ol>
<blockquote>
<p><strong>手工编码的自适应拓展可能依赖其他拓展，但是框架生成的自适应拓展并不依赖其他拓展</strong>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> T <span class="title function_">createAdaptiveExtension</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> injectExtension((T) getAdaptiveExtensionClass().newInstance());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Can&#x27;t create adaptive extension &quot;</span> + type + <span class="string">&quot;, cause: &quot;</span> + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取自适应拓展类"><a href="#获取自适应拓展类" class="headerlink" title="获取自适应拓展类"></a>获取自适应拓展类</h3><p>获取自适应拓展类的 <code>getAdaptiveExtensionClass</code> 方法包含以下三个处理逻辑：</p>
<ol>
<li>通过 <code>getExtensionClasses</code> 方法获取所有拓展类。</li>
<li>检查缓存 <code>cachedAdaptiveClass</code>，如果不为 <code>null</code>，则返回缓存。</li>
<li>如果缓存为 <code>null</code>，则调用 <code>createAdaptiveExtensionClass</code> 创建自适应拓展类（代理类）。</li>
</ol>
<p>在<a href="/2023/11/28/how-does-Dubbo-SPI-works/" title="Dubbo SPI 的工作原理">Dubbo SPI 的工作原理</a>中我们分析过 <code>getExtensionClasses</code> 方法，在获取拓展的所有实现类时，如果某个实现类被 <code>Adaptive</code> 注解标注了，那么该类就会被赋值给 <code>cachedAdaptiveClass</code> 变量。“原理”部分介绍的 <code>AdaptiveExtensionFactory</code> 就属于这种情况，我们不再细谈。按前文所说，在绝大多数情况下，<code>Adaptive</code> 注解都是用于标注方法而非标注具体的实现类，因此在大多数情况下程序都会走第三个步骤，由框架自动生成自适应拓展类（代理类）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; getAdaptiveExtensionClass() &#123;</span><br><span class="line">    getExtensionClasses();</span><br><span class="line">    <span class="keyword">if</span> (cachedAdaptiveClass != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cachedAdaptiveClass;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">return</span> <span class="variable">cachedAdaptiveClass</span> <span class="operator">=</span> createAdaptiveExtensionClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>到目前为止，<strong>获取自适应拓展的过程和获取普通拓展的过程是非常相似的</strong>，使用 <code>getOrCreate</code> 的模式获取拓展，如果缓存为空则创建，创建的时候会先加载全部的拓展实现类，从中获取目标类，通过反射进行实例化，最后进行依赖注入。区别在于获取目标类时，在自适应拓展情况下，返回的可能是一个生成的代理类。生成的过程非常复杂，是我们接下来关注的重点。</p>
</blockquote>
<h3 id="生成自适应拓展类"><a href="#生成自适应拓展类" class="headerlink" title="生成自适应拓展类"></a>生成自适应拓展类</h3><p>生成自适应拓展类的方式相比于以往接触的生成代理类的方式更加“直观且容易理解”，但是相应的，拼接字符串部分的代码并不容易阅读。</p>
<ol>
<li>通过拼接字符串得到代理类的源码。</li>
<li>使用编译器编译得到 <code>Class</code> 对象。</li>
</ol>
<blockquote>
<p>在新版本中，这部分代码的可读性有了非常大的提升，原先冗长的处理逻辑被抽象为多个命名含义清晰的方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; createAdaptiveExtensionClass() &#123;</span><br><span class="line">    <span class="comment">// 区别于旧版本：新版本抽象出一个 AdaptiveClassCodeGenerator 用于生成代码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AdaptiveClassCodeGenerator</span>(type, cachedDefaultName).generate();</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> findClassLoader();</span><br><span class="line">    <span class="comment">// 获取编译器拓展</span></span><br><span class="line">    org.apache.dubbo.common.compiler.<span class="type">Compiler</span> <span class="variable">compiler</span> <span class="operator">=</span></span><br><span class="line">            ExtensionLoader.getExtensionLoader(org.apache.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();</span><br><span class="line">    <span class="comment">// 编译代码，生成 Class 对象</span></span><br><span class="line">    <span class="keyword">return</span> compiler.compile(code, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>为了更直观地了解代码生成的效果及其实现的功能，以 <code>Protocol</code> 为例，生成的完整代码（已经经过格式化）展示如下</em>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.dubbo.rpc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.common.extension.ExtensionLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Protocol$Adaptive</span> <span class="keyword">implements</span> <span class="title class_">org</span>.apache.dubbo.rpc.Protocol &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(</span><br><span class="line">                <span class="string">&quot;The method public abstract void org.apache.dubbo.rpc.Protocol.destroy() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDefaultPort</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(</span><br><span class="line">                <span class="string">&quot;The method public abstract int org.apache.dubbo.rpc.Protocol.getDefaultPort() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> org.apache.dubbo.rpc.Invoker <span class="title function_">refer</span><span class="params">(java.lang.Class arg0, org.apache.dubbo.common.URL arg1)</span></span><br><span class="line">            <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException &#123;</span><br><span class="line">        <span class="keyword">if</span> (arg1 == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;url == null&quot;</span>);</span><br><span class="line">        org.apache.dubbo.common.<span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> arg1;</span><br><span class="line">        <span class="type">String</span> <span class="variable">extName</span> <span class="operator">=</span> (url.getProtocol() == <span class="literal">null</span> ? <span class="string">&quot;dubbo&quot;</span> : url.getProtocol());</span><br><span class="line">        <span class="keyword">if</span> (extName == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Failed to get extension (org.apache.dubbo.rpc.Protocol) name from url (&quot;</span></span><br><span class="line">                    + url.toString() + <span class="string">&quot;) use keys([protocol])&quot;</span>);</span><br><span class="line">        org.apache.dubbo.rpc.<span class="type">Protocol</span> <span class="variable">extension</span> <span class="operator">=</span> (org.apache.dubbo.rpc.Protocol) ExtensionLoader</span><br><span class="line">                .getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.refer(arg0, arg1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> java.util.List <span class="title function_">getServers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(</span><br><span class="line">                <span class="string">&quot;The method public default java.util.List org.apache.dubbo.rpc.Protocol.getServers() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> org.apache.dubbo.rpc.Exporter <span class="title function_">export</span><span class="params">(org.apache.dubbo.rpc.Invoker arg0)</span></span><br><span class="line">            <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException &#123;</span><br><span class="line">        <span class="keyword">if</span> (arg0 == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;org.apache.dubbo.rpc.Invoker argument == null&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (arg0.getUrl() == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;org.apache.dubbo.rpc.Invoker argument getUrl() == null&quot;</span>);</span><br><span class="line">        org.apache.dubbo.common.<span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> arg0.getUrl();</span><br><span class="line">        <span class="type">String</span> <span class="variable">extName</span> <span class="operator">=</span> (url.getProtocol() == <span class="literal">null</span> ? <span class="string">&quot;dubbo&quot;</span> : url.getProtocol());</span><br><span class="line">        <span class="keyword">if</span> (extName == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Failed to get extension (org.apache.dubbo.rpc.Protocol) name from url (&quot;</span></span><br><span class="line">                    + url.toString() + <span class="string">&quot;) use keys([protocol])&quot;</span>);</span><br><span class="line">        org.apache.dubbo.rpc.<span class="type">Protocol</span> <span class="variable">extension</span> <span class="operator">=</span> (org.apache.dubbo.rpc.Protocol) ExtensionLoader</span><br><span class="line">                .getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.export(arg0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成的代理类需完成以下功能：</p>
<ol>
<li>非 <code>adaptive</code> 方法，直接抛出异常。</li>
<li><code>adaptive</code> 方法：<ul>
<li>准备工作：在参数判空校验之后，从中获取到 <code>URL</code> 对象，结合 <code>URL</code> 对象和默认拓展名得到最终的拓展名 <code>extName</code>。</li>
<li>核心功能：先获取拓展的 <code>ExtensionLoader</code>，再根据拓展名 <code>extName</code> 获取拓展，最后调用拓展的同名方法。</li>
</ul>
</li>
</ol>
<p>以上的功能在表面上看来并不复杂，事实上，想要实现的目标处理逻辑也并不复杂，只在为了提供足够的可扩展性，具体实现变得很复杂。复杂的处理逻辑主要集中在如何为“准备工作”部分生成相应的代码，大概可以总结为：在获取拓展前，<code>Dubbo</code> 会直接或间接地从参数列表中查找 <code>URL</code> 对象，所谓直接就是 <code>URL</code> 对象直接在参数列表中，所谓间接就是 <code>URL</code> 对象是其中一个参数的属性。在得到 <code>URL</code> 对象后，<code>Dubbo</code> 会尝试以 <code>Adaptive</code> 注解的 <code>value</code> 为 <code>key</code>，从 <code>URL</code> 中获取值作为拓展名，如果获取不到则使用默认拓展名 <code>defaultExtName</code>。实际的实现更加复杂，需要耐心阅读和测试。</p>
<h3 id="自适应拓展类代码生成器"><a href="#自适应拓展类代码生成器" class="headerlink" title="自适应拓展类代码生成器"></a>自适应拓展类代码生成器</h3><p>新版本将代码生成的逻辑抽象到自适应拓展类代码生成器中，注意参数只有 <code>type</code> 和 <code>defaultExtName</code>，从这里也可以看出如何确定最终加载的拓展，取决于这两个参数和被调用方法的入参。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AdaptiveClassCodeGenerator</span><span class="params">(Class&lt;?&gt; type, String defaultExtName)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.type = type;</span><br><span class="line">    <span class="built_in">this</span>.defaultExtName = defaultExtName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">generate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 检测是否至少存在一个方法标注了 Adaptive 注解</span></span><br><span class="line">    <span class="keyword">if</span> (!hasAdaptiveMethod()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No adaptive method exist on extension &quot;</span> + type.getName() + <span class="string">&quot;, refuse to create the adaptive class!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 区别于旧版本：抽象为几个命名含义清晰的方法，提升了可读性</span></span><br><span class="line">    <span class="comment">// 生成类：包名、导入、类声明</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">code</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    code.append(generatePackageInfo());</span><br><span class="line">    code.append(generateImports());</span><br><span class="line">    code.append(generateClassDeclaration());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成方法</span></span><br><span class="line">    Method[] methods = type.getMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        code.append(generateMethod(method));</span><br><span class="line">    &#125;</span><br><span class="line">    code.append(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(code.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> code.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="检测-Adaptive-注解"><a href="#检测-Adaptive-注解" class="headerlink" title="检测 Adaptive 注解"></a>检测 Adaptive 注解</h4><p>在生成代理类源码之前，<code>generate</code> 方法会先通过反射检测接口方法中是否至少有一个标注了 <code>Adaptive</code> 注解，若不满足，就会抛出异常。</p>
<blockquote>
<p>流式编程使用得当的话很有可读性啊。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasAdaptiveMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(type.getMethods()).anyMatch(m -&gt; m.isAnnotationPresent(Adaptive.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="生成类"><a href="#生成类" class="headerlink" title="生成类"></a>生成类</h4><p>生成代理类源码的顺序和普通 <code>Java</code> 类文件中内容的顺序一致：</p>
<ul>
<li>package</li>
<li>import</li>
<li>类声明</li>
</ul>
<p>先忽略“生成方法”的部分，以 <code>Dubbo</code> 的 <code>Protocol</code> 拓展为例，生成的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.dubbo.rpc;</span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.common.extension.ExtensionLoader;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Protocol$Adaptive</span> <span class="keyword">implements</span> <span class="title class_">org</span>.apache.dubbo.rpc.Protocol &#123;</span><br><span class="line">    <span class="comment">// 省略方法代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="生成方法"><a href="#生成方法" class="headerlink" title="生成方法"></a>生成方法</h4><p>生成方法的过程同样被抽象为几个命名含义清晰的方法，包含以下五个部分：</p>
<ul>
<li>返回值</li>
<li>方法名</li>
<li><strong>方法内容</strong></li>
<li>方法参数</li>
<li>方法抛出的异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">generateMethod</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodReturnType</span> <span class="operator">=</span> method.getReturnType().getCanonicalName();</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> method.getName();</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodContent</span> <span class="operator">=</span> generateMethodContent(method);</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodArgs</span> <span class="operator">=</span> generateMethodArguments(method);</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodThrows</span> <span class="operator">=</span> generateMethodThrows(method);</span><br><span class="line">    <span class="keyword">return</span> String.format(CODE_METHOD_DECLARATION, methodReturnType, methodName, methodArgs, methodThrows, methodContent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了最重要的“方法内容”部分，其他部分都是复制原方法的信息，并不复杂。生成“方法内容”部分，分为是否被 <code>Adaptive</code> 注解标注。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">generateMethodContent</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">    <span class="type">Adaptive</span> <span class="variable">adaptiveAnnotation</span> <span class="operator">=</span> method.getAnnotation(Adaptive.class);</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">code</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">512</span>);</span><br><span class="line">    <span class="comment">// 检测方法是否被 Adaptive 注解标注</span></span><br><span class="line">    <span class="keyword">if</span> (adaptiveAnnotation == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> generateUnsupported(method);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> code.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="无-Adaptive-注解标注的方法"><a href="#无-Adaptive-注解标注的方法" class="headerlink" title="无 Adaptive 注解标注的方法"></a>无 Adaptive 注解标注的方法</h5><p>对于无 <code>Adaptive</code> 注解标注的方法，生成逻辑很简单，就是生成抛出异常的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">generateUnsupported</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> String.format(CODE_UNSUPPORTED, method, type.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>以 <code>Protocol</code> 接口的 <code>destroy</code> 方法为例，生成的内容如下</em>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;The method public abstract void org.apache.dubbo.rpc.Protocol.destroy() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="有-Adaptive-注解标注的方法"><a href="#有-Adaptive-注解标注的方法" class="headerlink" title="有 Adaptive 注解标注的方法"></a>有 Adaptive 注解标注的方法</h5><p>对于有 Adaptive 注解标注的方法，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找 URL 类型的参数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">urlTypeIndex</span> <span class="operator">=</span> getUrlTypeIndex(method);</span><br><span class="line"><span class="keyword">if</span> (urlTypeIndex != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 生成 URL 判空检查和赋值的代码</span></span><br><span class="line">    code.append(generateUrlNullCheck(urlTypeIndex));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果参数中没有直接出现 URL 类型，生成间接情况下的 URL 判空和赋值代码</span></span><br><span class="line">    code.append(generateUrlAssignmentIndirectly(method));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取方法的 Adaptive 注解的 value</span></span><br><span class="line">String[] value = getMethodAdaptiveValue(adaptiveAnnotation);</span><br><span class="line"><span class="comment">// 检测是否有 Invocation 类型的参数</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">hasInvocation</span> <span class="operator">=</span> hasInvocationArgument(method);</span><br><span class="line"><span class="comment">// 生成 Invocation 判空检查代码</span></span><br><span class="line">code.append(generateInvocationArgumentNullCheck(method));</span><br><span class="line"><span class="comment">// 生成拓展名赋值代码</span></span><br><span class="line">code.append(generateExtNameAssignment(value, hasInvocation));</span><br><span class="line"><span class="comment">// 生成拓展名判空检查代码</span></span><br><span class="line">code.append(generateExtNameNullCheck(value));</span><br><span class="line"><span class="comment">// 生成获取拓展和赋值代码</span></span><br><span class="line">code.append(generateExtensionAssignment());</span><br><span class="line"><span class="comment">// 生成调用和返回代码</span></span><br><span class="line">code.append(generateReturnAndInvocation(method));</span><br></pre></td></tr></table></figure>

<h5 id="查找-URL-类型的参数"><a href="#查找-URL-类型的参数" class="headerlink" title="查找 URL 类型的参数"></a>查找 URL 类型的参数</h5><p><strong>直接</strong>从方法的参数类型列表中查找<strong>第一个</strong> <code>URL</code> 类型的参数，返回其索引。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getUrlTypeIndex</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">urlTypeIndex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 遍历方法的参数类型列表</span></span><br><span class="line">    Class&lt;?&gt;[] pts = method.getParameterTypes();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pts.length; ++i) &#123;</span><br><span class="line">        <span class="comment">// 查找第一个 URL 类型的参数</span></span><br><span class="line">        <span class="keyword">if</span> (pts[i].equals(URL.class)) &#123;</span><br><span class="line">            urlTypeIndex = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> urlTypeIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成 URL 参数判空检查和赋值代码</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">generateUrlNullCheck</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> String.format(CODE_URL_NULL_CHECK, index, URL.class.getName(), index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>间接</strong>从方法的参数类型列表中，查找 <code>URL</code> 类型的参数，并生成判空检查和赋值代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">generateUrlAssignmentIndirectly</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">    Class&lt;?&gt;[] pts = method.getParameterTypes();</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Integer&gt; getterReturnUrl = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 遍历方法的参数类型列表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pts.length; ++i) &#123;</span><br><span class="line">        <span class="comment">// 遍历某一个参数类型的全部方法，查找可以返回 URL 类型的 “getter” 方法</span></span><br><span class="line">        <span class="keyword">for</span> (Method m : pts[i].getMethods()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> m.getName();</span><br><span class="line">            <span class="comment">// 1. 方法名以 get 开头，或者方法名大于 3 个字符</span></span><br><span class="line">            <span class="comment">// 2. 方法的访问权限为 public</span></span><br><span class="line">            <span class="comment">// 3. 非静态方法</span></span><br><span class="line">            <span class="comment">// 4. 方法参数数量为 0</span></span><br><span class="line">            <span class="comment">// 5. 方法返回值类型为 URL</span></span><br><span class="line">            <span class="keyword">if</span> ((name.startsWith(<span class="string">&quot;get&quot;</span>) || name.length() &gt; <span class="number">3</span>)</span><br><span class="line">                    &amp;&amp; Modifier.isPublic(m.getModifiers())</span><br><span class="line">                    &amp;&amp; !Modifier.isStatic(m.getModifiers())</span><br><span class="line">                    &amp;&amp; m.getParameterTypes().length == <span class="number">0</span></span><br><span class="line">                    &amp;&amp; m.getReturnType() == URL.class) &#123;</span><br><span class="line">                <span class="comment">// 保存方法名-&gt;索引的映射</span></span><br><span class="line">                getterReturnUrl.put(name, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getterReturnUrl.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果没有找到 “getter” 方法，抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Failed to create adaptive class for interface &quot;</span> + type.getName()</span><br><span class="line">                + <span class="string">&quot;: not found url parameter or url attribute in parameters of method &quot;</span> + method.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优先选择方法名为 getUrl 的方法，如果没有则选第一个</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">index</span> <span class="operator">=</span> getterReturnUrl.get(<span class="string">&quot;getUrl&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (index != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> generateGetUrlNullCheck(index, pts[index], <span class="string">&quot;getUrl&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Map.Entry&lt;String, Integer&gt; entry = getterReturnUrl.entrySet().iterator().next();</span><br><span class="line">        <span class="keyword">return</span> generateGetUrlNullCheck(entry.getValue(), pts[entry.getValue()], entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成 URL 参数判空检查和赋值代码</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">generateGetUrlNullCheck</span><span class="params">(<span class="type">int</span> index, Class&lt;?&gt; type, String method)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">code</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    code.append(String.format(<span class="string">&quot;if (arg%d == null) throw new IllegalArgumentException(\&quot;%s argument == null\&quot;);\n&quot;</span>,</span><br><span class="line">            index, type.getName()));</span><br><span class="line">    code.append(String.format(<span class="string">&quot;if (arg%d.%s() == null) throw new IllegalArgumentException(\&quot;%s argument %s() == null\&quot;);\n&quot;</span>,</span><br><span class="line">            index, method, type.getName(), method));</span><br><span class="line"></span><br><span class="line">    code.append(String.format(<span class="string">&quot;%s url = arg%d.%s();\n&quot;</span>, URL.class.getName(), index, method));</span><br><span class="line">    <span class="keyword">return</span> code.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>以 <code>Protocol</code> 的 <code>refer</code> 和 <code>export</code> 方法为例，生成的内容如下</em>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// refer</span></span><br><span class="line"><span class="keyword">if</span> (arg1 == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;url == null&quot;</span>);</span><br><span class="line">org.apache.dubbo.common.<span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> arg1;</span><br><span class="line"><span class="comment">// export</span></span><br><span class="line"><span class="keyword">if</span> (arg0 == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;org.apache.dubbo.rpc.Invoker argument == null&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (arg0.getUrl() == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;org.apache.dubbo.rpc.Invoker argument getUrl() == null&quot;</span>);</span><br><span class="line">org.apache.dubbo.common.<span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> arg0.getUrl();</span><br></pre></td></tr></table></figure>

<h5 id="获取-Adaptive-注解的-value"><a href="#获取-Adaptive-注解的-value" class="headerlink" title="获取 Adaptive 注解的 value"></a>获取 Adaptive 注解的 value</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String[] getMethodAdaptiveValue(Adaptive adaptiveAnnotation) &#123;</span><br><span class="line">    String[] value = adaptiveAnnotation.value();</span><br><span class="line">    <span class="comment">// 如果 value 为空，使用类名生成 value</span></span><br><span class="line">    <span class="comment">// 效果：LoadBalance -&gt; load.balance</span></span><br><span class="line">    <span class="keyword">if</span> (value.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">splitName</span> <span class="operator">=</span> StringUtils.camelToSplitName(type.getSimpleName(), <span class="string">&quot;.&quot;</span>);</span><br><span class="line">        value = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;splitName&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="检测-Invocation-类型的参数"><a href="#检测-Invocation-类型的参数" class="headerlink" title="检测 Invocation 类型的参数"></a>检测 Invocation 类型的参数</h5><p>检测是否有 <code>Invocation</code> 类型的参数，并生成判空检查代码和赋值代码。从 <code>Invocation</code> 可以获得 <code>methodName</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasInvocationArgument</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">    Class&lt;?&gt;[] pts = method.getParameterTypes();</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(pts).anyMatch(p -&gt; CLASSNAME_INVOCATION.equals(p.getName()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">generateInvocationArgumentNullCheck</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">    Class&lt;?&gt;[] pts = method.getParameterTypes();</span><br><span class="line">    <span class="keyword">return</span> IntStream.range(<span class="number">0</span>, pts.length).filter(i -&gt; CLASSNAME_INVOCATION.equals(pts[i].getName()))</span><br><span class="line">                    .mapToObj(i -&gt; String.format(CODE_INVOCATION_ARGUMENT_NULL_CHECK, i, i))</span><br><span class="line">                    .findFirst().orElse(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以 <code>LoadBalance</code> 的 <code>select</code> 方法为例，生成的内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (arg2 == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;invocation == null&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> arg2.getMethodName();</span><br></pre></td></tr></table></figure>

<h5 id="获取拓展名"><a href="#获取拓展名" class="headerlink" title="获取拓展名"></a>获取拓展名</h5><p>本方法用于根据 <code>SPI</code> 和 <code>Adaptive</code> 注解的 <code>value</code> 生成“获取拓展名”的代码，同时生成逻辑还受 <code>Invocation</code> 影响，因此相对复杂。总结的规则如下：</p>
<ol>
<li>正常情况下，使用 url.getParameter(value[i]) 获取</li>
<li>如果默认拓展名非空，使用 url.getParameter(value[i], defaultExtName) 获取</li>
<li>如果存在 Invocation，不论默认拓展名是否为空，总是使用 url.getMethodParameter(methodName, value[i], defaultExtName) 获取</li>
<li>因为 protocol 是 url 的一部分，所以可以直接通过 getProtocol 获取。是否使用默认拓展名的方式就退化为原始的三元表达式。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">generateExtNameAssignment</span><span class="params">(String[] value, <span class="type">boolean</span> hasInvocation)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> refactor it</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">getNameCode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 逆序遍历 value（Adaptive 的 value）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> value.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="comment">// 当 i 为最后一个元素的索引（因为是逆序遍历，第一轮就进入本分支）</span></span><br><span class="line">        <span class="keyword">if</span> (i == value.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 默认拓展名非空</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != defaultExtName) &#123;</span><br><span class="line">                <span class="comment">// protocol 是 url 的一部分，可以通过 getProtocol 方法获取，其他的则必须从 URL 参数中获取</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="string">&quot;protocol&quot;</span>.equals(value[i])) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (hasInvocation) &#123;</span><br><span class="line">                        <span class="comment">// 如果有 Invocation，则使用 url.getMethodParameter 获取</span></span><br><span class="line">                        <span class="comment">// url.getMethodParameter(methodName, value[i], defaultExtName)</span></span><br><span class="line">                        getNameCode = String.format(<span class="string">&quot;url.getMethodParameter(methodName, \&quot;%s\&quot;, \&quot;%s\&quot;)&quot;</span>, value[i], defaultExtName);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// url.getParameter(value[i], defaultExtName)</span></span><br><span class="line">                        getNameCode = String.format(<span class="string">&quot;url.getParameter(\&quot;%s\&quot;, \&quot;%s\&quot;)&quot;</span>, value[i], defaultExtName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// ( url.getProtocol() == null ? defaultExtName : url.getProtocol() )</span></span><br><span class="line">                    getNameCode = String.format(<span class="string">&quot;( url.getProtocol() == null ? \&quot;%s\&quot; : url.getProtocol() )&quot;</span>, defaultExtName);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">// 默认拓展名为空</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="string">&quot;protocol&quot;</span>.equals(value[i])) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (hasInvocation) &#123;</span><br><span class="line">                        <span class="comment">// url.getMethodParameter(methodName, value[i], defaultExtName)</span></span><br><span class="line">                        getNameCode = String.format(<span class="string">&quot;url.getMethodParameter(methodName, \&quot;%s\&quot;, \&quot;%s\&quot;)&quot;</span>, value[i], defaultExtName);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// url.getParameter(value[i])</span></span><br><span class="line">                        getNameCode = String.format(<span class="string">&quot;url.getParameter(\&quot;%s\&quot;)&quot;</span>, value[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// url.getProtocol()</span></span><br><span class="line">                    getNameCode = <span class="string">&quot;url.getProtocol()&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="string">&quot;protocol&quot;</span>.equals(value[i])) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hasInvocation) &#123;</span><br><span class="line">                    <span class="comment">// url.getMethodParameter(methodName, value[i], defaultExtName)</span></span><br><span class="line">                    getNameCode = String.format(<span class="string">&quot;url.getMethodParameter(methodName, \&quot;%s\&quot;, \&quot;%s\&quot;)&quot;</span>, value[i], defaultExtName);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// url.getParameter(value[i], getNameCode)</span></span><br><span class="line">                    getNameCode = String.format(<span class="string">&quot;url.getParameter(\&quot;%s\&quot;, %s)&quot;</span>, value[i], getNameCode);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// url.getProtocol() == null ? &quot;dubbo&quot; : url.getProtocol()</span></span><br><span class="line">                getNameCode = String.format(<span class="string">&quot;url.getProtocol() == null ? (%s) : url.getProtocol()&quot;</span>, getNameCode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> String.format(CODE_EXT_NAME_ASSIGNMENT, getNameCode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="加载拓展"><a href="#加载拓展" class="headerlink" title="加载拓展"></a>加载拓展</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">generateExtensionAssignment</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> String.format(CODE_EXTENSION_ASSIGNMENT, type.getName(), ExtensionLoader.class.getSimpleName(), type.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以 <code>Protocol</code> 接口的 <code>refer</code> 方法为例，生成的内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.dubbo.rpc.<span class="type">Protocol</span> <span class="variable">extension</span> <span class="operator">=</span> (org.apache.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);</span><br></pre></td></tr></table></figure>

<h5 id="调用与返回"><a href="#调用与返回" class="headerlink" title="调用与返回"></a>调用与返回</h5><p>生成方法调用语句，如有必要，返回结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">generateReturnAndInvocation</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">returnStatement</span> <span class="operator">=</span> method.getReturnType().equals(<span class="keyword">void</span>.class) ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;return &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">args</span> <span class="operator">=</span> IntStream.range(<span class="number">0</span>, method.getParameters().length)</span><br><span class="line">            .mapToObj(i -&gt; String.format(CODE_EXTENSION_METHOD_INVOKE_ARGUMENT, i))</span><br><span class="line">            .collect(Collectors.joining(<span class="string">&quot;, &quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> returnStatement + String.format(<span class="string">&quot;extension.%s(%s);\n&quot;</span>, method.getName(), args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以 <code>Protocol</code> 接口的 <code>refer</code> 方法为例，生成的内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> extension.refer(arg0, arg1);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>新版本通过提炼方法、使用流式编程和使用 <code>String.format()</code> 代替 StringBuilder，提供了更好的代码可读性。官方写得源码解析真好。</p>
</blockquote>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a target="_blank" rel="noopener" href="https://cn.dubbo.apache.org/zh-cn/docsv2.7/dev/source/adaptive-extension/">SPI 自适应拓展</a></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
              <a href="/tags/dubbo/" rel="tag"># dubbo</a>
              <a href="/tags/spi/" rel="tag"># spi</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/11/28/how-does-Dubbo-SPI-works/" rel="prev" title="Dubbo SPI 的工作原理">
                  <i class="fa fa-angle-left"></i> Dubbo SPI 的工作原理
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/12/01/Nginx-reverse-proxy-for-home-networks/" rel="next" title="Nginx 反向代理在家庭网络中的应用">
                  Nginx 反向代理在家庭网络中的应用 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Moralok</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">125k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">6:56</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  


  <script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"3EC6DlIt15eVYStwSVsDsQ2P-MdYXbMMI","app_key":"KKBQicvLunsmAfgH3DJJXvng","server_url":null,"security":false}</script>
  <script src="/js/third-party/statistics/lean-analytics.js"></script>



</body>
</html>
