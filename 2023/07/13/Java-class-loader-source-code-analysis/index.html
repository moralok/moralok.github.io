<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.moralok.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="组织类加载工作：loadClass当 Java 程序启动的时候，Java 虚拟机会调用 java.lang.ClassLoader#loadClass(java.lang.String) 加载 main 方法所在的类。 123public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;    re">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 类加载器源码分析">
<meta property="og:url" content="https://www.moralok.com/2023/07/13/Java-class-loader-source-code-analysis/index.html">
<meta property="og:site_name" content="Moralok">
<meta property="og:description" content="组织类加载工作：loadClass当 Java 程序启动的时候，Java 虚拟机会调用 java.lang.ClassLoader#loadClass(java.lang.String) 加载 main 方法所在的类。 123public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;    re">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-07-13T20:08:11.000Z">
<meta property="article:modified_time" content="2024-01-17T11:10:41.663Z">
<meta property="article:author" content="Moralok">
<meta property="article:tag" content="java">
<meta property="article:tag" content="class loader">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://www.moralok.com/2023/07/13/Java-class-loader-source-code-analysis/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.moralok.com/2023/07/13/Java-class-loader-source-code-analysis/","path":"2023/07/13/Java-class-loader-source-code-analysis/","title":"Java 类加载器源码分析"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java 类加载器源码分析 | Moralok</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-2MBCXKHJL0"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-2MBCXKHJL0","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Moralok</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E7%BB%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%B7%A5%E4%BD%9C%EF%BC%9AloadClass"><span class="nav-number">1.</span> <span class="nav-text">组织类加载工作：loadClass</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E5%B9%B6%E8%A1%8C%E5%9C%B0%E5%8A%A0%E8%BD%BD%E7%B1%BB-getClassLoadingLock"><span class="nav-number">1.1.</span> <span class="nav-text">怎么并行地加载类 getClassLoadingLock</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-%E2%80%9CClassLoader-%E5%AF%B9%E8%B1%A1%E6%B3%A8%E5%86%8C%E4%B8%BA%E5%85%B7%E6%9C%89%E5%B9%B6%E8%A1%8C%E8%83%BD%E5%8A%9B%E2%80%9D%E5%91%A2%EF%BC%9F"><span class="nav-number">1.1.1.</span> <span class="nav-text">什么是 “ClassLoader 对象注册为具有并行能力”呢？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E8%BF%99%E4%B8%A4%E4%B8%AA%E6%9D%A1%E4%BB%B6%E6%88%90%E7%AB%8B%E5%91%A2%EF%BC%9F"><span class="nav-number">1.1.2.</span> <span class="nav-text">怎么保证这两个条件成立呢？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C%E5%B7%A5%E4%BD%9C%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.1.3.</span> <span class="nav-text">注册工作做了什么？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%80%9C%E6%B3%A8%E5%86%8C%E2%80%9D%E6%80%8E%E4%B9%88%E5%92%8C%E9%94%81%E4%BA%A7%E7%94%9F%E8%81%94%E7%B3%BB%EF%BC%9F"><span class="nav-number">1.1.4.</span> <span class="nav-text">“注册”怎么和锁产生联系？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B3%A8%E5%86%8C%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%8D%E8%83%BD%E5%86%99%E5%9C%A8%E6%9E%84%E9%80%A0%E5%99%A8%E6%96%B9%E6%B3%95%E9%87%8C%EF%BC%9F"><span class="nav-number">1.1.5.</span> <span class="nav-text">为什么注册的代码不能写在构造器方法里？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E7%9B%AE%E6%A0%87%E7%B1%BB%E6%98%AF%E5%90%A6%E5%B7%B2%E5%8A%A0%E8%BD%BD"><span class="nav-number">1.2.</span> <span class="nav-text">检查目标类是否已加载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%9D%E8%AF%81%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%9A%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.3.</span> <span class="nav-text">保证核心类库的安全性：双亲委派模型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E8%BF%99%E5%A5%97%E5%A5%87%E6%80%AA%E7%9A%84%E6%9C%BA%E5%88%B6"><span class="nav-number">1.3.1.</span> <span class="nav-text">为什么要用这套奇怪的机制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E7%B1%BB%E8%B5%84%E6%BA%90%EF%BC%9AfindClass"><span class="nav-number">2.</span> <span class="nav-text">查找类资源：findClass</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E7%B1%BB%E7%9A%84%E7%9B%AE%E5%BD%95%E5%88%97%E8%A1%A8%EF%BC%9AURLClassPath"><span class="nav-number">2.1.</span> <span class="nav-text">查找类的目录列表：URLClassPath</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#URLClassPath-getResource"><span class="nav-number">2.1.1.</span> <span class="nav-text">URLClassPath#getResource</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#URLClassPath-getNextLoader"><span class="nav-number">2.1.2.</span> <span class="nav-text">URLClassPath#getNextLoader</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#URLClassPath-getLoader-int"><span class="nav-number">2.1.3.</span> <span class="nav-text">URLClassPath#getLoader(int)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#URLClassPath-getLoader-java-net-URL"><span class="nav-number">2.1.4.</span> <span class="nav-text">URLClassPath#getLoader(java.net.URL)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#URLClassPath-FileLoader-getResource"><span class="nav-number">2.2.</span> <span class="nav-text">URLClassPath.FileLoader#getResource</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ClassLoader-%E7%9A%84%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84"><span class="nav-number">2.3.</span> <span class="nav-text">ClassLoader 的搜索路径</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#bootstrap-class-loader"><span class="nav-number">2.3.1.</span> <span class="nav-text">bootstrap class loader</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ExtClassLoader"><span class="nav-number">2.3.2.</span> <span class="nav-text">ExtClassLoader</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AppClassLoader"><span class="nav-number">2.3.3.</span> <span class="nav-text">AppClassLoader</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%E4%B8%BA-Class-%E5%AE%9E%E4%BE%8B%EF%BC%9AdefineClass"><span class="nav-number">3.</span> <span class="nav-text">字节数据转换为 Class 实例：defineClass</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#URLClassLoader-defineClass"><span class="nav-number">3.1.</span> <span class="nav-text">URLClassLoader#defineClass</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SecureClassLoader-defineClass"><span class="nav-number">3.2.</span> <span class="nav-text">SecureClassLoader#defineClass</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#getPermissions"><span class="nav-number">3.2.1.</span> <span class="nav-text">getPermissions</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ProtectionDomain"><span class="nav-number">3.2.2.</span> <span class="nav-text">ProtectionDomain</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ClassLoader-defineClass"><span class="nav-number">3.3.</span> <span class="nav-text">ClassLoader#defineClass</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#preDefineClass"><span class="nav-number">3.3.1.</span> <span class="nav-text">preDefineClass</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#defineClassSourceLocation"><span class="nav-number">3.3.2.</span> <span class="nav-text">defineClassSourceLocation</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#defineClassX-%E6%96%B9%E6%B3%95"><span class="nav-number">3.3.3.</span> <span class="nav-text">defineClassX 方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#postDefineClass"><span class="nav-number">3.3.4.</span> <span class="nav-text">postDefineClass</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Moralok</p>
  <div class="site-description" itemprop="description">假如生命只剩一天</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">45</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/moralok" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;moralok" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.moralok.com/2023/07/13/Java-class-loader-source-code-analysis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Moralok">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Moralok">
      <meta itemprop="description" content="假如生命只剩一天">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Java 类加载器源码分析 | Moralok">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java 类加载器源码分析
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-07-14 04:08:11" itemprop="dateCreated datePublished" datetime="2023-07-14T04:08:11+08:00">2023-07-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-01-17 19:10:41" itemprop="dateModified" datetime="2024-01-17T19:10:41+08:00">2024-01-17</time>
    </span>

  
    <span id="/2023/07/13/Java-class-loader-source-code-analysis/" class="post-meta-item leancloud_visitors" data-flag-title="Java 类加载器源码分析" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>27 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h3 id="组织类加载工作：loadClass"><a href="#组织类加载工作：loadClass" class="headerlink" title="组织类加载工作：loadClass"></a>组织类加载工作：loadClass</h3><p>当 <code>Java</code> 程序启动的时候，<code>Java</code> 虚拟机会调用 <code>java.lang.ClassLoader#loadClass(java.lang.String)</code> 加载 <code>main</code> 方法所在的类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">return</span> loadClass(name, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据注释可知，此方法加载具有指定二进制名称的类，它由 <code>Java</code> 虚拟机调用来解析类引用，调用它等同于调用 <code>loadClass(name, false)</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 以二进制名称获取类加载的锁进行同步</span></span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        <span class="comment">// 首先检查类是否已加载，根据该方法注释可知：</span></span><br><span class="line">        <span class="comment">// 如果当前类加载器已经被 Java 虚拟机记录为具有该二进制名称的类的加载器（initiating loader），Java 虚拟机可以直接返回 Class 对象。</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果类还未加载，先委派给父·类加载器进行加载，如果父·类加载器为 null，则使用虚拟机内建的类加载器进行加载</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 递归调用</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 递归调用的终结点</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                <span class="comment">// 当父·类加载器长尝试加载但是失败，捕获异常但是什么都不做，因为接下来，当前类加载器需要自己也尝试加载。</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                <span class="comment">// 父·类加载器未找到类，当前类加载器自己找。</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据注释可知，<code>java.lang.ClassLoader#loadClass(java.lang.String, boolean)</code> 同样是加载“具有指定二进制名称的类”，此方法的实现按以下顺序搜索类：</p>
<ol>
<li>调用 <code>findLoadedClass(String)</code> 以检查该类是否已加载。</li>
<li>在父·类加载器上调用 <code>loadClass</code> 方法。如果父·类加载器为空，则使用虚拟机内置的类加载器。</li>
<li>调用 <code>findClass(String)</code> 方法来查找该类。</li>
</ol>
<p>如果使用上述步骤找到了该类（找到并定义类），并且解析标志为 <code>true</code>，则此方法将对生成的 <code>Class</code> 对象调用 <code>resolveClass(Class)</code> 方法。鼓励 <code>ClassLoader</code> 的子类重写 <code>findClass(String)</code>，而不是此方法。除非被重写，否则此方法在整个类加载过程中以 <code>getClassLoadingLock</code> 方法的结果进行同步。</p>
<blockquote>
<p>注意：<strong>父·类加载器</strong>并非<strong>父类·类加载器</strong>（当前类加载器的父类），而是当前的类加载器的 <code>parent</code> 属性被赋值另外一个类加载器实例，其含义更接近于“可以委派类加载工作的另一个类加载器（一个帮忙干活的上级）”。虽然绝大多数说法中，当一个类加载器的 <code>parent</code> 值为 <code>null</code> 时，它的父·类加载器是引导类加载器（<code>bootstrap class loader</code>），但是当看到 <code>findBootstrapClassOrNull</code> 方法时，我有点困惑，因为我以为会看到语义类似于 <code>loadClassByBootstrapClassLoader</code> 这样的方法名。从注释和代码的语义上看，<code>bootstrap class loader</code> 不像是任何一个类加载器的父·类加载器，但是从类加载的机制设计上说，它是，只是因为它并非由 Java 语言编写而成，不能实例化并赋值给 <code>parent</code> 属性。<code>findBootstrapClassOrNull</code> 方法的语义更接近于：当一个类加载器的父·类加载器为 <code>null</code> 时，将准备加载的目标类先当作启动类（<code>Bootstrap Class</code>）尝试查找，如果找不到就返回 <code>null</code>。</p>
</blockquote>
<h4 id="怎么并行地加载类-getClassLoadingLock"><a href="#怎么并行地加载类-getClassLoadingLock" class="headerlink" title="怎么并行地加载类 getClassLoadingLock"></a>怎么并行地加载类 getClassLoadingLock</h4><p>需要加载的类可能很多很多，我们很容易想到如果可以并行地加载类就好了。显然，<code>JDK</code> 的编写者考虑到了这一点。<br>此方法返回类加载操作的锁对象。为了向后兼容，此方法的默认实现的行为如下。如果此 <code>ClassLoader</code> 对象注册为具备并行能力，则该方法返回与指定类名关联的专用对象。 否则，该方法返回此 <code>ClassLoader</code> 对象。<br>简单地说，如果 <code>ClassLoader</code> 对象注册为具备并行能力，那么一个 <code>name</code> 一个锁对象，已创建的锁对象保存在 <code>ConcurrentHashMap</code> 类型的 <code>parallelLockMap</code> 中，这样类加载工作可以并行；否则所有类加载工作共用一个锁对象，就是 <code>ClassLoader</code> 对象本身。<br>这个方案意味着非同名的目标类可以认为在加载时没有冲突？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getClassLoadingLock</span><span class="params">(String className)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (parallelLockMap != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">newLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        lock = parallelLockMap.putIfAbsent(className, newLock);</span><br><span class="line">        <span class="keyword">if</span> (lock == <span class="literal">null</span>) &#123;</span><br><span class="line">            lock = newLock;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="什么是-“ClassLoader-对象注册为具有并行能力”呢？"><a href="#什么是-“ClassLoader-对象注册为具有并行能力”呢？" class="headerlink" title="什么是 “ClassLoader 对象注册为具有并行能力”呢？"></a>什么是 “<code>ClassLoader</code> 对象注册为具有并行能力”呢？</h5><p><code>AppClassLoader</code> 中有一段 <code>static</code> 代码。事实上 <code>java.lang.ClassLoader#registerAsParallelCapable</code> 是将 <code>ClassLoader</code> 对象注册为具有并行能力唯一的入口。因此，所有想要注册为具有并行能力的 <code>ClassLoader</code> 都需要调用一次该方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    ClassLoader.registerAsParallelCapable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>java.lang.ClassLoader#registerAsParallelCapable</code> 方法有一个注解 <code>@CallerSensitive</code>，这是因为它的代码中调用的 <code>native</code> 方法 <code>sun.reflect.Reflection#getCallerClass()</code> 方法。由注释可知，当且仅当以下所有条件全部满足时才注册成功：</p>
<ol>
<li>尚未创建调用者的实例（类加载器尚未实例化）</li>
<li>调用者的所有超类（<code>Object</code> 类除外）都注册为具有并行能力。</li>
</ol>
<h5 id="怎么保证这两个条件成立呢？"><a href="#怎么保证这两个条件成立呢？" class="headerlink" title="怎么保证这两个条件成立呢？"></a>怎么保证这两个条件成立呢？</h5><ol>
<li>对于第一个条件，可以通过将调用的代码写在 <code>static</code> 代码块中来实现。如果写在构造器方法里，并且通过单例模式保证只实例化一次可以吗？答案是不行的，后续会解释这个“注册”行为在构造器方法中是如何被使用以及为何不能写在构造器方法里。</li>
<li>对于第二个条件，由于 <code>Java</code> 虚拟机加载类时，总是会先尝试加载其父类，又因为加载类时会先调用 <code>static</code> 代码块，因此父类的 <code>static</code> 代码块总是先于子类的 <code>static</code> 代码块。</li>
</ol>
<p>你可以看到 <code>AppClassLoader-&gt;URLClassLoader-&gt;SecureClassLoader-&gt;ClassLoader</code> 均在 <code>static</code> 代码块实现注册，以保证满足以上两个条件。</p>
<h5 id="注册工作做了什么？"><a href="#注册工作做了什么？" class="headerlink" title="注册工作做了什么？"></a>注册工作做了什么？</h5><p>简单地说就是保存了类加载器所属 <code>Class</code> 的 <code>Set</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">registerAsParallelCapable</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获得此方法的调用者的 Class 实例，asSubClass 可以将 Class&lt;?&gt; 类型的 Class 转换为代表指定类的子类的 Class&lt;? extends U&gt; 类型的 Class。</span></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">ClassLoader</span>&gt; callerClass =</span><br><span class="line">        Reflection.getCallerClass().asSubclass(ClassLoader.class);</span><br><span class="line">    <span class="comment">// 注册调用者的 Class 为具有并行能力</span></span><br><span class="line">    <span class="keyword">return</span> ParallelLoaders.register(callerClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法 <code>java.lang.ClassLoader.ParallelLoaders#register</code>。<code>ParallelLoaders</code> 封装了一组具有并行能力的加载器类型。就是持有 <code>ClassLoader</code> 的 <code>Class</code> 实例的集合，并保证添加时加同步锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// private 修饰，只有其外部类 ClassLoader 才可以使用</span></span><br><span class="line"><span class="comment">// static 修饰，内部类如果需要定义 static 方法或者 static 变量，必须用 static 修饰</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ParallelLoaders</span> &#123;</span><br><span class="line">    <span class="comment">// private 修饰构造器方法，不希望这个类被实例化，只想要使用它的静态变量和方法。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ParallelLoaders</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the set of parallel capable loader types</span></span><br><span class="line">    <span class="comment">// 使用 loaderTypes 时通过 synchronized 加同步锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">ClassLoader</span>&gt;&gt; loaderTypes =</span><br><span class="line">        Collections.newSetFromMap(</span><br><span class="line">            <span class="comment">// todo: 为什么使用弱引用来实现？为了卸载类时的垃圾回收？</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">ClassLoader</span>&gt;, Boolean&gt;());</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 将 ClassLoader 本身注册为具有并行能力</span></span><br><span class="line">        <span class="keyword">synchronized</span> (loaderTypes) &#123; loaderTypes.add(ClassLoader.class); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Registers the given class loader type as parallel capabale.</span></span><br><span class="line"><span class="comment">     * Returns &#123;<span class="doctag">@code</span> true&#125; is successfully registered; &#123;<span class="doctag">@code</span> false&#125; if</span></span><br><span class="line"><span class="comment">     * loader&#x27;s super class is not registered.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">register</span><span class="params">(Class&lt;? extends ClassLoader&gt; c)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (loaderTypes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (loaderTypes.contains(c.getSuperclass())) &#123;</span><br><span class="line">                <span class="comment">// register the class loader as parallel capable</span></span><br><span class="line">                <span class="comment">// if and only if all of its super classes are.</span></span><br><span class="line">                <span class="comment">// Note: given current classloading sequence, if</span></span><br><span class="line">                <span class="comment">// the immediate super class is parallel capable,</span></span><br><span class="line">                <span class="comment">// all the super classes higher up must be too.</span></span><br><span class="line">                <span class="comment">// 当且仅当其所有超类都具有并行能力时，才将类加载器注册为具有并行能力。</span></span><br><span class="line">                <span class="comment">// 注意：给定当前的类加载顺序（加载类时，Java 虚拟机总是先尝试加载其父类），如果直接超类具有并行能力，则所有更高的超类也必然具有并行能力。</span></span><br><span class="line">                loaderTypes.add(c);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &#123;<span class="doctag">@code</span> true&#125; if the given class loader type is</span></span><br><span class="line"><span class="comment">     * registered as parallel capable.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isRegistered</span><span class="params">(Class&lt;? extends ClassLoader&gt; c)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (loaderTypes) &#123;</span><br><span class="line">            <span class="keyword">return</span> loaderTypes.contains(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="“注册”怎么和锁产生联系？"><a href="#“注册”怎么和锁产生联系？" class="headerlink" title="“注册”怎么和锁产生联系？"></a>“注册”怎么和锁产生联系？</h5><p>但是以上的注册过程只是起到一个“标记”作用，没有涉及和锁相关的代码，那么这个“标记”是怎么和真正的锁产生联系呢？<code>ClassLoader</code> 提供了三个构造器方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">ClassLoader</span><span class="params">(Void unused, ClassLoader parent)</span> &#123;</span><br><span class="line">    <span class="comment">// 由 private 修饰，不允许子类重写</span></span><br><span class="line">    <span class="built_in">this</span>.parent = parent;</span><br><span class="line">    <span class="keyword">if</span> (ParallelLoaders.isRegistered(<span class="built_in">this</span>.getClass())) &#123;</span><br><span class="line">        <span class="comment">// 如果类加载器已经注册为具有并行能力，则做一些赋值操作</span></span><br><span class="line">        parallelLockMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 保存 package-&gt;certs 的 map 映射，相关的工作也可以并行进行</span></span><br><span class="line">        package2certs = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">        assertionLock = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// no finer-grained lock; lock on the classloader instance</span></span><br><span class="line">        parallelLockMap = <span class="literal">null</span>;</span><br><span class="line">        package2certs = <span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;&gt;();</span><br><span class="line">        assertionLock = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由 protect 修饰，允许子类重写，传递了父·类加载器。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">ClassLoader</span><span class="params">(ClassLoader parent)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(checkCreateClassLoader(), parent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由 protect 修饰，允许子类重写，父·类加载器使用 getSystemClassLoader 方法返回的系统类加载器。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">ClassLoader</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(checkCreateClassLoader(), getSystemClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ClassLoader</code> 的构造器方法最终都调用 <code>private</code> 修饰的 <code>java.lang.ClassLoader#ClassLoader(java.lang.Void, java.lang.ClassLoader)</code>，又因为父类的构造器方法总是先于子类的构造器方法被执行，这样一来，所有继承 <code>ClassLoader</code> 的类加载器在创建的时候都会根据在创建实例之前是否注册为具有并行能力而做不同的操作。</p>
<h5 id="为什么注册的代码不能写在构造器方法里？"><a href="#为什么注册的代码不能写在构造器方法里？" class="headerlink" title="为什么注册的代码不能写在构造器方法里？"></a>为什么注册的代码不能写在构造器方法里？</h5><p>使用“注册”的代码也解释了 <code>java.lang.ClassLoader#registerAsParallelCapable</code> 为了满足调用成功的第一个条件为什么不能写在构造器方法中，因为使用这个机制的代码先于你在子类构造器方法里编写的代码被执行。<br>同时，不论是 <code>loadLoader</code> 还是 <code>getClassLoadingLock</code> 都是由 <code>protect</code> 修饰，允许子类重写，来自定义并行加载类的能力。</p>
<blockquote>
<p>todo: 讨论自定义类加载器的时候，印象里似乎对并行加载类的提及比较少，之后留意一下。</p>
</blockquote>
<h4 id="检查目标类是否已加载"><a href="#检查目标类是否已加载" class="headerlink" title="检查目标类是否已加载"></a>检查目标类是否已加载</h4><p>加载类之前显然需要检查目标类是否已加载，这项工作最终是交给 <code>native</code> 方法，在虚拟机中执行，就像在黑盒中一样。<br>todo: 不同类加载器同一个类名会如何判定？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass(String name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!checkName(name))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> findLoadedClass0(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass0(String name);</span><br></pre></td></tr></table></figure>

<h4 id="保证核心类库的安全性：双亲委派模型"><a href="#保证核心类库的安全性：双亲委派模型" class="headerlink" title="保证核心类库的安全性：双亲委派模型"></a>保证核心类库的安全性：双亲委派模型</h4><p>正如在代码和注释中所看到的，正常情况下，类的加载工作先委派给自己的父·类加载器，即 <code>parent</code> 属性的值——另一个类加载器实例。一层一层向上委派直到 <code>parent</code> 为 <code>null</code>，代表类加载工作会尝试先委派给虚拟机内建的 <code>bootstrap class loader</code> 处理，然后由 <code>bootstrap class loader</code> 首先尝试加载。如果被委派方加载失败，委派方会自己再尝试加载。<br>正常加载类的是应用类加载器 <code>AppClassLoader</code>，它的 <code>parent</code> 为 <code>ExtClassLoader</code>，<code>ExtClassLoader</code> 的 <code>parent</code> 为 <code>null</code>。</p>
<blockquote>
<p>在网上也能看到有人提到以前大家称之为“父·类加载器委派机制”，“双亲”一词易引人误解。</p>
</blockquote>
<h5 id="为什么要用这套奇怪的机制"><a href="#为什么要用这套奇怪的机制" class="headerlink" title="为什么要用这套奇怪的机制"></a>为什么要用这套奇怪的机制</h5><p>这样设计很明显的一个目的就是保证核心类库的类加载安全性。比如 <code>Object</code> 类，设计者不希望编写代码的人重新写一个 <code>Object</code> 类并加载到 <code>Java</code> 虚拟机中，但是加载类的本质就是读取字节数据传递给 <code>Java</code> 虚拟机创建一个 <code>Class</code> 实例，使用这套机制的目的之一就是为了让核心类库先加载，同时先加载的类不会再次被加载。</p>
<p>通常流程如下：</p>
<ol>
<li><code>AppClassLoader</code> 调用 <code>loadClass</code> 方法，先委派给 <code>ExtClassLoader</code>。</li>
<li><code>ExtClassLoader</code> 调用 <code>loadClass</code> 方法，先委派给 <code>bootstrap class loader</code>。</li>
<li><code>bootstrap class loader</code> 在其设置的类路径中无法找到 <code>BananaTest</code> 类，抛出 <code>ClassNotFoundException</code> 异常。</li>
<li><code>ExtClassLoader</code> 捕获异常，然后自己调用 <code>findClass</code> 方法尝试进行加载。</li>
<li><code>ExtClassLoader</code> 在其设置的类路径中无法找到 <code>BananaTest</code> 类，抛出 <code>ClassNotFoundException</code> 异常。</li>
<li><code>AppClassLoader</code> 捕获异常，然后自己调用 <code>findClass</code> 方法尝试进行加载。</li>
</ol>
<p>注释中提到鼓励重写 <code>findClass</code> 方法而不是 <code>loadClass</code>，因为正是该方法实现了所谓的“双亲委派模型”，<code>java.lang.ClassLoader#findClass</code> 实现了如何查找加载类。如果不是专门为了破坏这个类加载模型，应该选择重写 <code>findClass</code>；其次是因为该方法中涉及并行加载类的机制。</p>
<h3 id="查找类资源：findClass"><a href="#查找类资源：findClass" class="headerlink" title="查找类资源：findClass"></a>查找类资源：findClass</h3><p>默认情况下，类加载器在自己尝试进行加载时，会调用 <code>java.lang.ClassLoader#findClass</code> 方法，该方法由子类重写。<code>AppClassLoader</code> 和 <code>ExtClassLoader</code> 都是继承 <code>URLClassLoader</code>，而 <code>URLClassLoader</code> 重写了 <code>findClass</code> 方法。根据注释可知，该方法会从 <code>URL</code> 搜索路径查找并加载具有指定名称的类。任何引用 <code>Jar</code> 文件的 <code>URL</code> 都会根据需要加载并打开，直到找到该类。</p>
<p>过程如下：</p>
<ol>
<li>将 <code>name</code> 转换为 <code>path</code>，比如 <code>com.example.BananaTest</code> 转换为 <code>com/example/BananaTest.class</code>。</li>
<li>使用 <code>URL</code> 搜索路径 <code>URLClassPath</code> 和 <code>path</code> 中获取 <code>Resource</code>，本质上就是轮流将可能存放的目录列表拼接上文件路径进行查找。</li>
<li>调用 <code>URLClassLoader</code> 的私有方法 <code>defineClass</code>，该方法调用父类 <code>SecureClassLoader</code> 的 <code>defineClass</code> 方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(<span class="keyword">final</span> String name)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// todo:</span></span><br><span class="line">        result = AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PrivilegedExceptionAction</span>&lt;Class&lt;?&gt;&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> Class&lt;?&gt; run() <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">                    <span class="comment">// 将 name 转换为 path</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> name.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>).concat(<span class="string">&quot;.class&quot;</span>);</span><br><span class="line">                    <span class="comment">// 从 URLClassPath 中查找 Resource</span></span><br><span class="line">                    <span class="type">Resource</span> <span class="variable">res</span> <span class="operator">=</span> ucp.getResource(path, <span class="literal">false</span>);</span><br><span class="line">                    <span class="keyword">if</span> (res != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> defineClass(name, res);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name, e);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (ClassFormatError e2) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (res.getDataError() != <span class="literal">null</span>) &#123;</span><br><span class="line">                                e2.addSuppressed(res.getDataError());</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">throw</span> e2;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, acc);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.security.PrivilegedActionException pae) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (ClassNotFoundException) pae.getException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="查找类的目录列表：URLClassPath"><a href="#查找类的目录列表：URLClassPath" class="headerlink" title="查找类的目录列表：URLClassPath"></a>查找类的目录列表：URLClassPath</h4><p><code>URLClassLoader</code> 拥有一个 <code>URLClassPath</code> 类型的属性 <code>ucp</code>。由注释可知，<code>URLClassPath</code> 类用于维护一个 <code>URL</code> 的搜索路径，以便从 <code>Jar</code> 文件和目录中加载类和资源。<br><code>URLClassPath</code> 的核心构造器方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">URLClassPath</span><span class="params">(URL[] urls,</span></span><br><span class="line"><span class="params">                    URLStreamHandlerFactory factory,</span></span><br><span class="line"><span class="params">                    AccessControlContext acc)</span> &#123;</span><br><span class="line">    <span class="comment">// 将 urls 保存到 ArrayList 类型的属性 path 中，根据注释，path 的含义为 URL 的原始搜索路径。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; urls.length; i++) &#123;</span><br><span class="line">        path.add(urls[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将 urls 保存到 Stack 类型的属性 urls 中，根据注释，urls 的含义为未打开的 URL 列表。</span></span><br><span class="line">    push(urls);</span><br><span class="line">    <span class="keyword">if</span> (factory != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果 factory 不为 null，使用它创建一个 URLStreamHandler 实例处理 Jar 文件。</span></span><br><span class="line">        jarHandler = factory.createURLStreamHandler(<span class="string">&quot;jar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (DISABLE_ACC_CHECKING)</span><br><span class="line">        <span class="built_in">this</span>.acc = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">this</span>.acc = acc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="URLClassPath-getResource"><a href="#URLClassPath-getResource" class="headerlink" title="URLClassPath#getResource"></a>URLClassPath#getResource</h5><p><code>URLClassLoader</code> 调用 <code>sun.misc.URLClassPath#getResource(java.lang.String, boolean)</code> 方法获取指定名称对应的资源。根据注释，该方法会查找 <code>URL</code> 搜索路径上的第一个资源，如果找不到资源，则返回 <code>null</code>。<br>显然，这里的 <code>Loader</code> 不是我们前面提到的类加载器。<code>Loader</code> 是 <code>URLClassPath</code> 的内部类，用于表示根据一个基本 <code>URL</code> 创建的资源和类的加载器。也就是说一个基本 <code>URL</code> 对应一个 <code>Loader</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Resource <span class="title function_">getResource</span><span class="params">(String name, <span class="type">boolean</span> check)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;URLClassPath.getResource(\&quot;&quot;</span> + name + <span class="string">&quot;\&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Loader loader;</span><br><span class="line">    <span class="comment">// 获取缓存（默认没有用）</span></span><br><span class="line">    <span class="type">int</span>[] cache = getLookupCache(name);</span><br><span class="line">    <span class="comment">// 不断获取下一个 Loader 来获取 Resource，直到获取到或者没有下一个 Loader</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; (loader = getNextLoader(cache, i)) != <span class="literal">null</span>; i++) &#123;</span><br><span class="line">        <span class="type">Resource</span> <span class="variable">res</span> <span class="operator">=</span> loader.getResource(name, check);</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="URLClassPath-getNextLoader"><a href="#URLClassPath-getNextLoader" class="headerlink" title="URLClassPath#getNextLoader"></a>URLClassPath#getNextLoader</h5><p>获取下一个 <code>Loader</code>，其实根据 <code>index</code> 从一个存放已创建 <code>Loader</code> 的 <code>ArrayList</code> 中获取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> Loader <span class="title function_">getNextLoader</span><span class="params">(<span class="type">int</span>[] cache, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; cache.length) &#123;</span><br><span class="line">            <span class="type">Loader</span> <span class="variable">loader</span> <span class="operator">=</span> loaders.get(cache[index]);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_LOOKUP_CACHE) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;HASCACHE: Loading from : &quot;</span> + cache[index]</span><br><span class="line">                                    + <span class="string">&quot; = &quot;</span> + loader.getBaseURL());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> loader;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// finished iterating over cache[]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取 Loader</span></span><br><span class="line">        <span class="keyword">return</span> getLoader(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="URLClassPath-getLoader-int"><a href="#URLClassPath-getLoader-int" class="headerlink" title="URLClassPath#getLoader(int)"></a>URLClassPath#getLoader(int)</h5><ol>
<li>用 <code>index</code> 到存放已创建 <code>Loader</code> 的列表中去获取（调用方传入的 <code>index</code> 从 <code>0</code> 开始不断递增直到超过范围）。</li>
<li>如果 <code>index</code> 超过范围，说明已有的 <code>Loader</code> 都找不到目标 <code>Resource</code>，需要到未打开的 <code>URL</code> 中查找。</li>
<li>从未打开的 <code>URL</code> 中取出（<code>pop</code>）一个来创建 <code>Loader</code>，如果 <code>urls</code> 已经为空，则返回 <code>null</code>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> Loader <span class="title function_">getLoader</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Expand URL search path until the request can be satisfied</span></span><br><span class="line">    <span class="comment">// or the URL stack is empty.</span></span><br><span class="line">    <span class="keyword">while</span> (loaders.size() &lt; index + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// Pop the next URL from the URL stack</span></span><br><span class="line">        <span class="comment">// 如果 index 超过数组范围，需要从未打开的 URL 中取出一个，创建 Loader 并返回</span></span><br><span class="line">        URL url;</span><br><span class="line">        <span class="keyword">synchronized</span> (urls) &#123;</span><br><span class="line">            <span class="keyword">if</span> (urls.empty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                url = urls.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Skip this URL if it already has a Loader. (Loader</span></span><br><span class="line">        <span class="comment">// may be null in the case where URL has not been opened</span></span><br><span class="line">        <span class="comment">// but is referenced by a JAR index.)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">urlNoFragString</span> <span class="operator">=</span> URLUtil.urlNoFragString(url);</span><br><span class="line">        <span class="keyword">if</span> (lmap.containsKey(urlNoFragString)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Otherwise, create a new Loader for the URL.</span></span><br><span class="line">        Loader loader;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 根据 URL 创建 Loader</span></span><br><span class="line">            loader = getLoader(url);</span><br><span class="line">            <span class="comment">// If the loader defines a local class path then add the</span></span><br><span class="line">            <span class="comment">// URLs to the list of URLs to be opened.</span></span><br><span class="line">            URL[] urls = loader.getClassPath();</span><br><span class="line">            <span class="keyword">if</span> (urls != <span class="literal">null</span>) &#123;</span><br><span class="line">                push(urls);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// Silently ignore for now...</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException se) &#123;</span><br><span class="line">            <span class="comment">// Always silently ignore. The context, if there is one, that</span></span><br><span class="line">            <span class="comment">// this URLClassPath was given during construction will never</span></span><br><span class="line">            <span class="comment">// have permission to access the URL.</span></span><br><span class="line">            <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;Failed to access &quot;</span> + url + <span class="string">&quot;, &quot;</span> + se );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Finally, add the Loader to the search path.</span></span><br><span class="line">        validateLookupCache(loaders.size(), urlNoFragString);</span><br><span class="line">        loaders.add(loader);</span><br><span class="line">        lmap.put(urlNoFragString, loader);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_LOOKUP_CACHE) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;NOCACHE: Loading from : &quot;</span> + index );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loaders.get(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="URLClassPath-getLoader-java-net-URL"><a href="#URLClassPath-getLoader-java-net-URL" class="headerlink" title="URLClassPath#getLoader(java.net.URL)"></a>URLClassPath#getLoader(java.net.URL)</h5><p>根据指定的 <code>URL</code> 创建 <code>Loader</code>，不同类型的 <code>URL</code> 会返回不同具体实现的 <code>Loader</code>。</p>
<ol>
<li>如果 <code>URL</code> 不是以 <code>/</code> 结尾，认为是 <code>Jar</code> 文件，则返回 <code>JarLoader</code> 类型，比如 <code>file:/C:/Users/xxx/.jdks/corretto-1.8.0_342/jre/lib/rt.jar</code>。</li>
<li>如果 <code>URL</code> 以 <code>/</code> 结尾，且协议为 <code>file</code>，则返回 <code>FileLoader</code> 类型，比如 <code>file:/C:/Users/xxx/IdeaProjects/java-test/target/classes/</code>。</li>
<li>如果 <code>URL</code> 以 <code>/</code> 结尾，且协议不会 <code>file</code>，则返回 <code>Loader</code> 类型。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Loader <span class="title function_">getLoader</span><span class="params">(<span class="keyword">final</span> URL url)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> java.security.AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">java</span>.security.PrivilegedExceptionAction&lt;Loader&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> Loader <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">file</span> <span class="operator">=</span> url.getFile();</span><br><span class="line">                <span class="keyword">if</span> (file != <span class="literal">null</span> &amp;&amp; file.endsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">&quot;file&quot;</span>.equals(url.getProtocol())) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FileLoader</span>(url);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Loader</span>(url);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JarLoader</span>(url, jarHandler, lmap, acc);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, acc);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.security.PrivilegedActionException pae) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (IOException)pae.getException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="URLClassPath-FileLoader-getResource"><a href="#URLClassPath-FileLoader-getResource" class="headerlink" title="URLClassPath.FileLoader#getResource"></a>URLClassPath.FileLoader#getResource</h4><p>以 <code>FileLoader</code> 的 <code>getResource</code> 为例，如果文件找到了，就会将文件包装成一个 <code>FileInputStream</code>，再将 <code>FileInputStream</code> 包装成一个 <code>Resource</code> 返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Resource <span class="title function_">getResource</span><span class="params">(<span class="keyword">final</span> String name, <span class="type">boolean</span> check)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> URL url;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">normalizedBase</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(getBaseURL(), <span class="string">&quot;.&quot;</span>);</span><br><span class="line">        url = <span class="keyword">new</span> <span class="title class_">URL</span>(getBaseURL(), ParseUtil.encodePath(name, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (url.getFile().startsWith(normalizedBase.getFile()) == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="comment">// requested resource had ../..&#x27;s in path</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (check)</span><br><span class="line">            URLClassPath.check(url);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> File file;</span><br><span class="line">        <span class="keyword">if</span> (name.indexOf(<span class="string">&quot;..&quot;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">            file = (<span class="keyword">new</span> <span class="title class_">File</span>(dir, name.replace(<span class="string">&#x27;/&#x27;</span>, File.separatorChar)))</span><br><span class="line">                    .getCanonicalFile();</span><br><span class="line">            <span class="keyword">if</span> ( !((file.getPath()).startsWith(dir.getPath())) ) &#123;</span><br><span class="line">                <span class="comment">/* outside of base dir */</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            file = <span class="keyword">new</span> <span class="title class_">File</span>(dir, name.replace(<span class="string">&#x27;/&#x27;</span>, File.separatorChar));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Resource</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; <span class="keyword">return</span> name; &#125;;</span><br><span class="line">                <span class="keyword">public</span> URL <span class="title function_">getURL</span><span class="params">()</span> &#123; <span class="keyword">return</span> url; &#125;;</span><br><span class="line">                <span class="keyword">public</span> URL <span class="title function_">getCodeSourceURL</span><span class="params">()</span> &#123; <span class="keyword">return</span> getBaseURL(); &#125;;</span><br><span class="line">                <span class="keyword">public</span> InputStream <span class="title function_">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br><span class="line">                    &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file); &#125;;</span><br><span class="line">                <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getContentLength</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br><span class="line">                    &#123; <span class="keyword">return</span> (<span class="type">int</span>)file.length(); &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ClassLoader-的搜索路径"><a href="#ClassLoader-的搜索路径" class="headerlink" title="ClassLoader 的搜索路径"></a>ClassLoader 的搜索路径</h4><p>从上文可知，<code>ClassLoader</code> 调用 <code>findClass</code> 方法查找类的时候，并不是漫无目的地查找，而是根据设置的类路径进行查找，不同的 <code>ClassLoader</code> 有不同的类路径。</p>
<p>以下是通过 <code>IDEA</code> 启动 <code>Java</code> 程序时的命令，可以看到其中通过 <code>-classpath</code> 指定了应用·类加载器 <code>AppClassLoader</code> 的类路径，该类路径除了包含常规的 <code>JRE</code> 的文件路径外，还额外添加了当前 <code>maven</code> 工程编译生成的 <code>target\classes</code> 目录。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\xxx\.jdks\corretto-1.8.0_342\bin\java.exe -agentlib:jdwp=transport=dt_socket,address=127.0.0.1:52959,suspend=y,server=n -javaagent:C:\Users\xxx\AppData\Local\JetBrains\IntelliJIdea2022.3\captureAgent\debugger-agent.jar -Dfile.encoding=UTF-8 -classpath &quot;C:\Users\xxx\.jdks\corretto-1.8.0_342\jre\lib\charsets.jar;C:\Users\xxx\.jdks\corretto-1.8.0_342\jre\lib\ext\access-bridge-64.jar;C:\Users\xxx\.jdks\corretto-1.8.0_342\jre\lib\ext\cldrdata.jar;C:\Users\xxx\.jdks\corretto-1.8.0_342\jre\lib\ext\dnsns.jar;C:\Users\xxx\.jdks\corretto-1.8.0_342\jre\lib\ext\jaccess.jar;C:\Users\xxx\.jdks\corretto-1.8.0_342\jre\lib\ext\jfxrt.jar;C:\Users\xxx\.jdks\corretto-1.8.0_342\jre\lib\ext\localedata.jar;C:\Users\xxx\.jdks\corretto-1.8.0_342\jre\lib\ext\nashorn.jar;C:\Users\xxx\.jdks\corretto-1.8.0_342\jre\lib\ext\sunec.jar;C:\Users\xxx\.jdks\corretto-1.8.0_342\jre\lib\ext\sunjce_provider.jar;C:\Users\xxx\.jdks\corretto-1.8.0_342\jre\lib\ext\sunmscapi.jar;C:\Users\xxx\.jdks\corretto-1.8.0_342\jre\lib\ext\sunpkcs11.jar;C:\Users\xxx\.jdks\corretto-1.8.0_342\jre\lib\ext\zipfs.jar;C:\Users\xxx\.jdks\corretto-1.8.0_342\jre\lib\jce.jar;C:\Users\xxx\.jdks\corretto-1.8.0_342\jre\lib\jfr.jar;C:\Users\xxx\.jdks\corretto-1.8.0_342\jre\lib\jfxswt.jar;C:\Users\xxx\.jdks\corretto-1.8.0_342\jre\lib\jsse.jar;C:\Users\xxx\.jdks\corretto-1.8.0_342\jre\lib\management-agent.jar;C:\Users\xxx\.jdks\corretto-1.8.0_342\jre\lib\resources.jar;C:\Users\xxx\.jdks\corretto-1.8.0_342\jre\lib\rt.jar;C:\Users\xxx\IdeaProjects\java-test\target\classes;C:\Program Files\JetBrains\IntelliJ IDEA 2022.3.3\lib\idea_rt.jar&quot; org.example.BananaTest</span><br></pre></td></tr></table></figure>

<h5 id="bootstrap-class-loader"><a href="#bootstrap-class-loader" class="headerlink" title="bootstrap class loader"></a>bootstrap class loader</h5><p>启动·类加载器 <code>bootstrap class loader</code>，加载核心类库，即 <code>&lt;JRE_HOME&gt;/lib</code> 目录中的部分类库，如 <code>rt.jar</code>，只有名字符合要求的 <code>jar</code> 才能被识别。 启动 Java 虚拟机时可以通过选项 <code>-Xbootclasspath</code> 修改默认的类路径，有三种使用方式：</p>
<ul>
<li><code>-Xbootclasspath:</code>：完全覆盖核心类库的类路径，不常用，除非重写核心类库。</li>
<li><code>-Xbootclasspath/a:</code> 以后缀的方式拼接在原搜索路径后面，常用。</li>
<li><code>-Xbootclasspath/p:</code> 以前缀的方式拼接再原搜索路径前面.不常用，避免引起不必要的冲突。</li>
</ul>
<p>在 <code>IDEA</code> 中编辑启动配置，添加 <code>VM</code> 选项，<code>-Xbootclasspath:C:\Software</code>，里面没有类文件，启动虚拟机失败，提示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Error occurred during initialization of VM</span><br><span class="line">java/lang/NoClassDefFoundError: java/lang/Object</span><br><span class="line"></span><br><span class="line">进程已结束,退出代码1</span><br></pre></td></tr></table></figure>

<h5 id="ExtClassLoader"><a href="#ExtClassLoader" class="headerlink" title="ExtClassLoader"></a>ExtClassLoader</h5><p>扩展·类加载器 <code>ExtClassLoader</code>，加载 <code>&lt;JRE_HOME&gt;/lib/ext/</code> 目录中的类库。启动 <code>Java</code> 虚拟机时可以通过选项 <code>-Djava.ext.dirs</code> 修改默认的类路径。显然修改不当同样可能会引起 <code>Java</code> 程序的异常。</p>
<h5 id="AppClassLoader"><a href="#AppClassLoader" class="headerlink" title="AppClassLoader"></a>AppClassLoader</h5><p>应用·类加载器 <code>AppClassLoader</code> ，加载应用级别的搜索路径中的类库。可以使用系统的环境变量 <code>CLASSPATH</code> 的值，也可以在启动 Java 虚拟机时通过选项 <code>-classpath</code> 修改。</p>
<p><code>CLASSPATH</code> 在 <code>Windows</code> 中，多个文件路径使用分号 <code>;</code> 分隔，而 <code>Linux</code> 中则使用冒号 <code>:</code> 分隔。以下例子表示当前目录和另一个文件路径拼接而成的类路径。</p>
<ul>
<li>Windows：<code>.;C:\path\to\classes</code></li>
<li>Linux：<code>.:/path/to/classes</code></li>
</ul>
<p>事实上，<code>AppClassLoader</code> 最终的类路径，不仅仅包含 <code>-classpath</code> 的值，还会包含 <code>-javaagent</code> 指定的值。</p>
<h3 id="字节数据转换为-Class-实例：defineClass"><a href="#字节数据转换为-Class-实例：defineClass" class="headerlink" title="字节数据转换为 Class 实例：defineClass"></a>字节数据转换为 Class 实例：defineClass</h3><p>方法 <code>defineClass</code>，顾名思义，就是定义类，将字节数据转换为 <code>Class</code> 实例。在 <code>ClassLoader</code> 以及其子类中有很多同名方法，方法内各种处理和包装，最终都是为了使用 <code>name</code> 和字节数据等参数，调用 <code>native</code> 方法获得一个 <code>Class</code> 实例。<br>以下是定义类时最终可能调用的 <code>native</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> Class&lt;?&gt; defineClass0(String name, <span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len,</span><br><span class="line">                                     ProtectionDomain pd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> Class&lt;?&gt; defineClass1(String name, <span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len,</span><br><span class="line">                                     ProtectionDomain pd, String source);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> Class&lt;?&gt; defineClass2(String name, java.nio.ByteBuffer b,</span><br><span class="line">                                     <span class="type">int</span> off, <span class="type">int</span> len, ProtectionDomain pd,</span><br><span class="line">                                     String source);</span><br></pre></td></tr></table></figure>

<p>其方法参数有：</p>
<ul>
<li><code>name</code>，目标类的名称。</li>
<li><code>byte[]</code> 或 <code>ByteBuffer</code> 类型的字节数据，<code>off</code> 和 <code>len</code> 只是为了定位传入的字节数组中关于目标类的字节数据，通常分别是 0 和字节数组的长度，毕竟专门构造一个包含无关数据的字节数组很无聊。</li>
<li><code>ProtectionDomain</code>，保护域，todo:</li>
<li><code>source</code>，<code>CodeSource</code> 的位置。</li>
</ul>
<p><code>defineClass</code> 方法的调用过程，其实就是从 <code>URLClassLoader</code> 开始，一层一层处理后再调用父类的 <code>defineClass</code> 方法，分别经过了 <code>SecureClassLoader</code> 和 <code>ClassLoader</code>。</p>
<h4 id="URLClassLoader-defineClass"><a href="#URLClassLoader-defineClass" class="headerlink" title="URLClassLoader#defineClass"></a>URLClassLoader#defineClass</h4><p>此方法是再 <code>URLClassLoader</code> 的 <code>findClass</code> 方法中，获得正确的 <code>Resource</code> 之后调用的，由 <code>private</code> 修饰。根据注释，它使用从指定资源获取的类字节来定义类，生成的类必须先解析才能使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; defineClass(String name, Resource res) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">    <span class="comment">// 获取最后一个 . 的位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> name.lastIndexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="comment">// 返回资源的 CodeSourceURL</span></span><br><span class="line">    <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> res.getCodeSourceURL();</span><br><span class="line">    <span class="keyword">if</span> (i != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 截取包名 com.example</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">pkgname</span> <span class="operator">=</span> name.substring(<span class="number">0</span>, i);</span><br><span class="line">        <span class="comment">// Check if package already loaded.</span></span><br><span class="line">        <span class="type">Manifest</span> <span class="variable">man</span> <span class="operator">=</span> res.getManifest();</span><br><span class="line">        definePackageInternal(pkgname, man, url);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Now read the class bytes and define the class</span></span><br><span class="line">    <span class="comment">// 先尝试以 ByteBuffer 的形式返回字节数据，如果资源的输入流不是在 ByteBuffer 之上实现的，则返回 null</span></span><br><span class="line">    java.nio.<span class="type">ByteBuffer</span> <span class="variable">bb</span> <span class="operator">=</span> res.getByteBuffer();</span><br><span class="line">    <span class="keyword">if</span> (bb != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Use (direct) ByteBuffer:</span></span><br><span class="line">        <span class="comment">// 不常用</span></span><br><span class="line">        CodeSigner[] signers = res.getCodeSigners();</span><br><span class="line">        <span class="type">CodeSource</span> <span class="variable">cs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CodeSource</span>(url, signers);</span><br><span class="line">        sun.misc.PerfCounter.getReadClassBytesTime().addElapsedTimeFrom(t0);</span><br><span class="line">        <span class="comment">// 调用 java.security.SecureClassLoader#defineClass(java.lang.String, java.nio.ByteBuffer, java.security.CodeSource)</span></span><br><span class="line">        <span class="keyword">return</span> defineClass(name, bb, cs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 以字节数组的形式返回资源数据</span></span><br><span class="line">        <span class="type">byte</span>[] b = res.getBytes();</span><br><span class="line">        <span class="comment">// must read certificates AFTER reading bytes.</span></span><br><span class="line">        <span class="comment">// 必须再读取字节数据后读取证书，todo:</span></span><br><span class="line">        CodeSigner[] signers = res.getCodeSigners();</span><br><span class="line">        <span class="comment">// 根据 URL 和签名者创建 CodeSource</span></span><br><span class="line">        <span class="type">CodeSource</span> <span class="variable">cs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CodeSource</span>(url, signers);</span><br><span class="line">        sun.misc.PerfCounter.getReadClassBytesTime().addElapsedTimeFrom(t0);</span><br><span class="line">        <span class="comment">// 调用 java.security.SecureClassLoader#defineClass(java.lang.String, byte[], int, int, java.security.CodeSource)</span></span><br><span class="line">        <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length, cs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Resource</code> 类提供了 <code>getBytes</code> 方法，此方法以字节数组的形式返回字节数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] getBytes() <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">byte</span>[] b;</span><br><span class="line">    <span class="comment">// Get stream before content length so that a FileNotFoundException</span></span><br><span class="line">    <span class="comment">// can propagate upwards without being caught too early</span></span><br><span class="line">    <span class="comment">// 在获取内容长度之前获取流，以便 FileNotFoundException 可以向上传播而不会过早被捕获（todo: 不理解）</span></span><br><span class="line">    <span class="comment">// 获取缓存的 InputStream</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> cachedInputStream();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This code has been uglified to protect against interrupts.</span></span><br><span class="line">    <span class="comment">// Even if a thread has been interrupted when loading resources,</span></span><br><span class="line">    <span class="comment">// the IO should not abort, so must carefully retry, failing only</span></span><br><span class="line">    <span class="comment">// if the retry leads to some other IO exception.</span></span><br><span class="line">    <span class="comment">// 该代码为了防止中断有点丑陋。即使线程在加载资源时被中断，IO 也不应该中止，因此必须小心重试，只有当重试导致其他 IO 异常时才会失败。</span></span><br><span class="line">    <span class="comment">// 检测当前线程是否收到中断信号，收到的话则返回 true 且清除中断状态，重新变更为未中断状态。</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isInterrupted</span> <span class="operator">=</span> Thread.interrupted();</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取内容长度，顺利的话就跳出循环</span></span><br><span class="line">            len = getContentLength();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedIOException iioe) &#123;</span><br><span class="line">            <span class="comment">// 如果获取内容长度时，线程被中断抛出了异常，捕获后清除中断状态</span></span><br><span class="line">            Thread.interrupted();</span><br><span class="line">            isInterrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (len == -<span class="number">1</span>) len = Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (pos &lt; len) &#123;</span><br><span class="line">            <span class="type">int</span> bytesToRead;</span><br><span class="line">            <span class="keyword">if</span> (pos &gt;= b.length) &#123; <span class="comment">// Only expand when there&#x27;s no room</span></span><br><span class="line">                <span class="comment">// 如果当前读取位置已经大于等于数组长度</span></span><br><span class="line">                <span class="comment">// 本次待读取字节长度 = 剩余未读取长度和 1024 取较小值</span></span><br><span class="line">                bytesToRead = Math.min(len - pos, b.length + <span class="number">1024</span>);</span><br><span class="line">                <span class="keyword">if</span> (b.length &lt; pos + bytesToRead) &#123;</span><br><span class="line">                    <span class="comment">// 如果当前读取位置 + 本次待读取字节长度 &gt; 数组长度，则创建新数组并复制数据</span></span><br><span class="line">                    b = Arrays.copyOf(b, pos + bytesToRead);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 数组还有空间，待读取字节长度 = 数组剩余空间</span></span><br><span class="line">                bytesToRead = b.length - pos;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cc</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 读取数据</span></span><br><span class="line">                cc = in.read(b, pos, bytesToRead);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedIOException iioe) &#123;</span><br><span class="line">                <span class="comment">// 如果读取时，线程被中断抛出了异常，捕获后清除中断状态</span></span><br><span class="line">                Thread.interrupted();</span><br><span class="line">                isInterrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果读取返回值 &lt; 0</span></span><br><span class="line">                <span class="keyword">if</span> (len != Integer.MAX_VALUE) &#123;</span><br><span class="line">                    <span class="comment">// 且长度并未无限，表示提前检测到 EOF，抛出异常</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EOFException</span>(<span class="string">&quot;Detect premature EOF&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果长度无限，表示读到了文件结尾，数组长度大于当前读取位置，创建新数组并复制长度</span></span><br><span class="line">                    <span class="keyword">if</span> (b.length != pos) &#123;</span><br><span class="line">                        b = Arrays.copyOf(b, pos);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pos += cc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedIOException iioe) &#123;</span><br><span class="line">            isInterrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ignore) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isInterrupted) &#123;</span><br><span class="line">            <span class="comment">// 如果 isInterrupted 为 true，代表中断过，重新将线程状态置为中断。</span></span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>getByteBuffer</code> 之后会缓存 <code>InputStream</code> 以便调用 <code>getBytes</code> 时使用，方法由 <code>synchronized</code> 修饰。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> InputStream <span class="title function_">cachedInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (cis == <span class="literal">null</span>) &#123;</span><br><span class="line">        cis = getInputStream();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Resource</code> 的实例是 <code>URLClassPath</code> 中的匿名类 <code>FileLoader</code> 以 <code>Resource</code> 的匿名类的方式创建的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> InputStream <span class="title function_">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在该匿名类中，getInputStream 的实现就是简单地根据 FileLoader 中保存的 File 实例创建 FileInputStream 并返回。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getContentLength</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在该匿名类中，getContentLength 的实现就是简单地根据 FileLoader 中保存的 File 实例获取长度。</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)file.length();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="SecureClassLoader-defineClass"><a href="#SecureClassLoader-defineClass" class="headerlink" title="SecureClassLoader#defineClass"></a>SecureClassLoader#defineClass</h4><p><code>URLClassLoader</code> 继承自 <code>SecureClassLoader</code>，<code>SecureClassLoader</code> 提供并重载了 <code>defineClass</code> 方法，两个方法的注释均比代码长得多。<br>由注释可知，方法的作用是将字节数据（<code>byte[]</code> 类型或者 <code>ByteBuffer</code> 类型）转换为 <code>Class</code> 类型的实例，有一个可选的 <code>CodeSource</code> 类型的参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name,</span><br><span class="line">                                     <span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len,</span><br><span class="line">                                     CodeSource cs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> defineClass(name, b, off, len, getProtectionDomain(cs));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, java.nio.ByteBuffer b,</span><br><span class="line">                                     CodeSource cs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> defineClass(name, b, getProtectionDomain(cs));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法中只是简单地将 <code>CodeSource</code> 类型的参数转换成 <code>ProtectionDomain</code> 类型，就调用 <code>ClassLoader</code> 的 <code>defineClass</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ProtectionDomain <span class="title function_">getProtectionDomain</span><span class="params">(CodeSource cs)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 CodeSource 为 null，直接返回 null</span></span><br><span class="line">    <span class="keyword">if</span> (cs == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">ProtectionDomain</span> <span class="variable">pd</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (pdcache) &#123;</span><br><span class="line">        <span class="comment">// 先从 Map 缓存中获取 ProtectionDomain</span></span><br><span class="line">        pd = pdcache.get(cs);</span><br><span class="line">        <span class="keyword">if</span> (pd == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 从 CodeSource 中获取 PermissionCollection</span></span><br><span class="line">            <span class="type">PermissionCollection</span> <span class="variable">perms</span> <span class="operator">=</span> getPermissions(cs);</span><br><span class="line">            <span class="comment">// 缓存中没有，则创建一个 ProtectionDomain 并放入缓存</span></span><br><span class="line">            pd = <span class="keyword">new</span> <span class="title class_">ProtectionDomain</span>(cs, perms, <span class="built_in">this</span>, <span class="literal">null</span>);</span><br><span class="line">            pdcache.put(cs, pd);</span><br><span class="line">            <span class="keyword">if</span> (debug != <span class="literal">null</span>) &#123;</span><br><span class="line">                debug.println(<span class="string">&quot; getPermissions &quot;</span>+ pd);</span><br><span class="line">                debug.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="getPermissions"><a href="#getPermissions" class="headerlink" title="getPermissions"></a>getPermissions</h5><p>根据注释可知，此方法会返回给定 <code>CodeSource</code> 对象的权限。此方法由 <code>protect</code> 修饰，<code>AppClassLoader</code> 和 <code>URLClassLoader</code> 都有重写。当前 <code>ClassLoader</code> 是 <code>AppClassLoader</code>。</p>
<p><code>AppClassLoader#getPermissions</code>，添加允许从类路径加载的任何类退出 VM的权限。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> PermissionCollection <span class="title function_">getPermissions</span><span class="params">(CodeSource codesource)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用父类 URLClassLoader 的 getPermissions</span></span><br><span class="line">    <span class="type">PermissionCollection</span> <span class="variable">perms</span> <span class="operator">=</span> <span class="built_in">super</span>.getPermissions(codesource);</span><br><span class="line">    <span class="comment">// 允许从类路径加载的任何类退出 VM的权限。</span></span><br><span class="line">    <span class="comment">// todo: 这是否自定义的类加载器加载的类，可能不能退出 VM。</span></span><br><span class="line">    perms.add(<span class="keyword">new</span> <span class="title class_">RuntimePermission</span>(<span class="string">&quot;exitVM&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> perms;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SecureClassLoader#getPermissions</code>，添加一个读文件或读目录的权限。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> PermissionCollection <span class="title function_">getPermissions</span><span class="params">(CodeSource codesource)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用父类 SecureClassLoader 的 getPermissions</span></span><br><span class="line">    <span class="type">PermissionCollection</span> <span class="variable">perms</span> <span class="operator">=</span> <span class="built_in">super</span>.getPermissions(codesource);</span><br><span class="line"></span><br><span class="line">    <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> codesource.getLocation();</span><br><span class="line"></span><br><span class="line">    Permission p;</span><br><span class="line">    URLConnection urlConnection;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// FileURLConnection 实例</span></span><br><span class="line">        urlConnection = url.openConnection();</span><br><span class="line">        <span class="comment">// 允许 read 的 FilePermission 实例</span></span><br><span class="line">        p = urlConnection.getPermission();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.io.IOException ioe) &#123;</span><br><span class="line">        p = <span class="literal">null</span>;</span><br><span class="line">        urlConnection = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p <span class="keyword">instanceof</span> FilePermission) &#123;</span><br><span class="line">        <span class="comment">// if the permission has a separator char on the end,</span></span><br><span class="line">        <span class="comment">// it means the codebase is a directory, and we need</span></span><br><span class="line">        <span class="comment">// to add an additional permission to read recursively</span></span><br><span class="line">        <span class="comment">// 如果文件路径以文件分隔符结尾，表示目录，需要在末尾添加&quot;-&quot;改为递归读的权限</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> p.getName();</span><br><span class="line">        <span class="keyword">if</span> (path.endsWith(File.separator)) &#123;</span><br><span class="line">            path += <span class="string">&quot;-&quot;</span>;</span><br><span class="line">            p = <span class="keyword">new</span> <span class="title class_">FilePermission</span>(path, SecurityConstants.FILE_READ_ACTION);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((p == <span class="literal">null</span>) &amp;&amp; (url.getProtocol().equals(<span class="string">&quot;file&quot;</span>))) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> url.getFile().replace(<span class="string">&#x27;/&#x27;</span>, File.separatorChar);</span><br><span class="line">        path = ParseUtil.decode(path);</span><br><span class="line">        <span class="keyword">if</span> (path.endsWith(File.separator))</span><br><span class="line">            path += <span class="string">&quot;-&quot;</span>;</span><br><span class="line">        p =  <span class="keyword">new</span> <span class="title class_">FilePermission</span>(path, SecurityConstants.FILE_READ_ACTION);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Not loading from a &#x27;file:&#x27; URL so we want to give the class</span></span><br><span class="line"><span class="comment">         * permission to connect to and accept from the remote host</span></span><br><span class="line"><span class="comment">         * after we&#x27;ve made sure the host is the correct one and is valid.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">URL</span> <span class="variable">locUrl</span> <span class="operator">=</span> url;</span><br><span class="line">        <span class="keyword">if</span> (urlConnection <span class="keyword">instanceof</span> JarURLConnection) &#123;</span><br><span class="line">            locUrl = ((JarURLConnection)urlConnection).getJarFileURL();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> locUrl.getHost();</span><br><span class="line">        <span class="keyword">if</span> (host != <span class="literal">null</span> &amp;&amp; (host.length() &gt; <span class="number">0</span>))</span><br><span class="line">            p = <span class="keyword">new</span> <span class="title class_">SocketPermission</span>(host,</span><br><span class="line">                                        SecurityConstants.SOCKET_CONNECT_ACCEPT_ACTION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make sure the person that created this class loader</span></span><br><span class="line">    <span class="comment">// would have this permission</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Permission</span> <span class="variable">fp</span> <span class="operator">=</span> p;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> SecurityException &#123;</span><br><span class="line">                    sm.checkPermission(fp);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, acc);</span><br><span class="line">        &#125;</span><br><span class="line">        perms.add(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> perms;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SecureClassLoader#getPermissions</code>，延迟设置权限，在创建 <code>ProtectionDomain</code> 时再设置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> PermissionCollection <span class="title function_">getPermissions</span><span class="params">(CodeSource codesource)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 检查以确保类加载器已初始化。在 SecureClassLoader 构造器最后会用一个布尔变量表示加载器初始化成功。</span></span><br><span class="line">    <span class="comment">// 从代码上看，似乎只能保证 SecureClassLoader 的构造器方法已执行完毕？</span></span><br><span class="line">    check();</span><br><span class="line">    <span class="comment">// ProtectionDomain 延迟绑定，Permissions 继承 PermissionCollection 类。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Permissions</span>(); <span class="comment">// ProtectionDomain defers the binding</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ProtectionDomain"><a href="#ProtectionDomain" class="headerlink" title="ProtectionDomain"></a>ProtectionDomain</h5><p><code>ProtectionDomain</code> 的相关构造器参数：</p>
<ul>
<li><code>CodeSource</code></li>
<li><code>PermissionCollection</code>，如果不为 <code>null</code>，会设置权限为只读，表示权限在使用过程中不再修改；同时检查是否需要设置拥有全部权限。</li>
<li><code>ClassLoader</code></li>
<li><code>Principal[]</code></li>
</ul>
<p>这样看来，<code>SecureClassLoader</code> 为了定义类做的处理，就是简单地创建一些关于权限的对象，并保存了 <code>CodeSource-&gt;ProtectionDomain</code> 的映射作为缓存。</p>
<h4 id="ClassLoader-defineClass"><a href="#ClassLoader-defineClass" class="headerlink" title="ClassLoader#defineClass"></a>ClassLoader#defineClass</h4><p>抽象类 <code>ClassLoader</code> 中最终用于定义类的 <code>native</code> 方法 <code>define0</code>，<code>define1</code>，<code>define2</code> 都是由 <code>private</code> 修饰的，<code>ClassLoader</code> 提供并重载了 <code>defineClass</code> 方法作为使用它们的入口，这些 <code>defineClass</code> 方法都由 <code>protect</code> <code>final</code> 修饰，这意味着这些方法只能被子类使用，并且不能被重写。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len)</span><br><span class="line">    <span class="keyword">throws</span> ClassFormatError</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> defineClass(name, b, off, len, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len,</span><br><span class="line">                                     ProtectionDomain protectionDomain)</span><br><span class="line">    <span class="keyword">throws</span> ClassFormatError</span><br><span class="line">&#123;</span><br><span class="line">    protectionDomain = preDefineClass(name, protectionDomain);</span><br><span class="line">    <span class="type">String</span> <span class="variable">source</span> <span class="operator">=</span> defineClassSourceLocation(protectionDomain);</span><br><span class="line">    Class&lt;?&gt; c = defineClass1(name, b, off, len, protectionDomain, source);</span><br><span class="line">    postDefineClass(c, protectionDomain);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, java.nio.ByteBuffer b,</span><br><span class="line">                                     ProtectionDomain protectionDomain)</span><br><span class="line">    <span class="keyword">throws</span> ClassFormatError</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> b.remaining();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use byte[] if not a direct ByteBufer:</span></span><br><span class="line">    <span class="keyword">if</span> (!b.isDirect()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b.hasArray()) &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, b.array(),</span><br><span class="line">                                b.position() + b.arrayOffset(), len,</span><br><span class="line">                                protectionDomain);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// no array, or read-only array</span></span><br><span class="line">            <span class="type">byte</span>[] tb = <span class="keyword">new</span> <span class="title class_">byte</span>[len];</span><br><span class="line">            b.get(tb);  <span class="comment">// get bytes out of byte buffer.</span></span><br><span class="line">            <span class="keyword">return</span> defineClass(name, tb, <span class="number">0</span>, len, protectionDomain);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protectionDomain = preDefineClass(name, protectionDomain);</span><br><span class="line">    <span class="type">String</span> <span class="variable">source</span> <span class="operator">=</span> defineClassSourceLocation(protectionDomain);</span><br><span class="line">    Class&lt;?&gt; c = defineClass2(name, b, b.position(), len, protectionDomain, source);</span><br><span class="line">    postDefineClass(c, protectionDomain);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要步骤：</p>
<ol>
<li><code>preDefineClass</code> 前置处理</li>
<li><code>defineClassX</code></li>
<li><code>postDefineClass</code> 后置处理</li>
</ol>
<h5 id="preDefineClass"><a href="#preDefineClass" class="headerlink" title="preDefineClass"></a>preDefineClass</h5><p>确定保护域 <code>ProtectionDomain</code>，并检查：</p>
<ol>
<li>未定义 <code>java.*</code> 类</li>
<li>该类的签名者与包（<code>package</code>）中其余类的签名者相匹配</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ProtectionDomain <span class="title function_">preDefineClass</span><span class="params">(String name,</span></span><br><span class="line"><span class="params">                                        ProtectionDomain pd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 检查 name 为 null 或者有可能是有效的二进制名称</span></span><br><span class="line">    <span class="keyword">if</span> (!checkName(name))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoClassDefFoundError</span>(<span class="string">&quot;IllegalName: &quot;</span> + name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note:  Checking logic in java.lang.invoke.MemberName.checkForTypeAlias</span></span><br><span class="line">    <span class="comment">// relies on the fact that spoofing is impossible if a class has a name</span></span><br><span class="line">    <span class="comment">// of the form &quot;java.*&quot;</span></span><br><span class="line">    <span class="comment">// 如果 name 以 java. 开头，则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> ((name != <span class="literal">null</span>) &amp;&amp; name.startsWith(<span class="string">&quot;java.&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span></span><br><span class="line">            (<span class="string">&quot;Prohibited package name: &quot;</span> +</span><br><span class="line">                name.substring(<span class="number">0</span>, name.lastIndexOf(<span class="string">&#x27;.&#x27;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果未传入 ProtectionDomain，取默认的 ProtectionDomain</span></span><br><span class="line">        pd = defaultDomain;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存放了 package-&gt;certs 的 map 映射作为缓存，检查一个包内的 certs 都是一样的</span></span><br><span class="line">    <span class="comment">// todo: certs</span></span><br><span class="line">    <span class="keyword">if</span> (name != <span class="literal">null</span>) checkCerts(name, pd.getCodeSource());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="defineClassSourceLocation"><a href="#defineClassSourceLocation" class="headerlink" title="defineClassSourceLocation"></a>defineClassSourceLocation</h5><p>确定 <code>Class</code> 的 <code>CodeSource</code> 位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">defineClassSourceLocation</span><span class="params">(ProtectionDomain pd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">CodeSource</span> <span class="variable">cs</span> <span class="operator">=</span> pd.getCodeSource();</span><br><span class="line">    <span class="type">String</span> <span class="variable">source</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (cs != <span class="literal">null</span> &amp;&amp; cs.getLocation() != <span class="literal">null</span>) &#123;</span><br><span class="line">        source = cs.getLocation().toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> source;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="defineClassX-方法"><a href="#defineClassX-方法" class="headerlink" title="defineClassX 方法"></a>defineClassX 方法</h5><p>这些 <code>native</code> 方法使用了 <code>name</code>，字节数据，<code>ProtectionDomain</code> 和 <code>source</code> 等参数，像黑盒一样，在虚拟机中定义了一个类。</p>
<h5 id="postDefineClass"><a href="#postDefineClass" class="headerlink" title="postDefineClass"></a>postDefineClass</h5><p>在定义类后使用 <code>ProtectionDomain</code> 中的 <code>certs</code> 补充 <code>Class</code> 实例的 <code>signer</code> 信息，猜测在 <code>native</code> 方法 <code>defineClassX</code> 方法中，对 <code>ProtectionDomain</code> 做了一些修改。事实上，从代码上看，将 <code>CodeSource</code> 包装为 <code>ProtectionDomain</code> 传入后，除了 <code>defineClassX</code> 方法外，其他地方都是取出 <code>CodeSource</code> 使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postDefineClass</span><span class="params">(Class&lt;?&gt; c, ProtectionDomain pd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pd.getCodeSource() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取证书</span></span><br><span class="line">        Certificate certs[] = pd.getCodeSource().getCertificates();</span><br><span class="line">        <span class="keyword">if</span> (certs != <span class="literal">null</span>)</span><br><span class="line">            setSigners(c, certs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
              <a href="/tags/class-loader/" rel="tag"># class loader</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/06/29/tmux-frequently-used-commands/" rel="prev" title="Tmux 常用命令和快捷键">
                  <i class="fa fa-angle-left"></i> Tmux 常用命令和快捷键
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/08/04/Spring-application-context-refresh-process/" rel="next" title="Spring 应用 context 刷新流程">
                  Spring 应用 context 刷新流程 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Moralok</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">120k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">6:39</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  


  <script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"3EC6DlIt15eVYStwSVsDsQ2P-MdYXbMMI","app_key":"KKBQicvLunsmAfgH3DJJXvng","server_url":null,"security":false}</script>
  <script src="/js/third-party/statistics/lean-analytics.js"></script>



</body>
</html>
